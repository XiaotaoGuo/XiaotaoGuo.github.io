<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[CMU-15-445/645]-Assignment 1</title>
    <url>/2020/04/22/CMU-DB-3-HW1/</url>
    <content><![CDATA[<p>这是我在学习 <a href="https://15445.courses.cs.cmu.edu/fall2019/" target="_blank" rel="noopener">Databases Systems CMU 15-445/645/ Fall 2019</a> 过程记录的一些笔记，本文了记录我在完成第一次作业的过程中完成结果和遇到的一些疑问。</p>
<a id="more"></a>
<h2 id="作业-amp-软件安装"><a href="#作业-amp-软件安装" class="headerlink" title="作业 &amp; 软件安装"></a>作业 &amp; 软件安装</h2><p>本次作业主要是熟悉以下SQL的各种用法，用的软件是Sqlite3，软件安装过程以及数据集下载都可以根据<a href="https://15445.courses.cs.cmu.edu/fall2019/homework1/" target="_blank" rel="noopener">作业指导</a>，下载完数据集之后用sqlite验证一下各部分是不是都完好，这一部分没遇到什么问题。以下是我的运行环境：</p>
<pre><code>    系统：Ubuntu18.04
    sqlite版本：
    $ sqlite3 -version
    3.22.0 2018-01-22 18:45:57 0c55d179733b46d8d0ba4d88e01a25e10677046ee3da1d5b1581e86726f2alt1
</code></pre><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h3 id="Q1-SAMPLE"><a href="#Q1-SAMPLE" class="headerlink" title="Q1 SAMPLE"></a>Q1 SAMPLE</h3><p>运行一下样本代码并保存。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 输出电影里面所有类别（不重复）</span><br><span class="line">sqlite&gt; select distinct(type) from titles order by type;</span><br><span class="line">movie</span><br><span class="line">short</span><br><span class="line">tvEpisode</span><br><span class="line">tvMiniSeries</span><br><span class="line">tvMovie</span><br><span class="line">tvSeries</span><br><span class="line">tvShort</span><br><span class="line">tvSpecial</span><br><span class="line">video</span><br><span class="line">videoGame</span><br></pre></td></tr></table></figure>
<h3 id="Q2-UNCOMMON-TYPE"><a href="#Q2-UNCOMMON-TYPE" class="headerlink" title="Q2 UNCOMMON_TYPE"></a>Q2 UNCOMMON_TYPE</h3><blockquote>
<p>List the longest title of each type along with the runtime minutes.</p>
</blockquote>
<p>找出每一类电影中时长最久的电影，如果有时长一样的话全部选择，最后输出电影类型，电影名和持续时间。输出时按照类别升序，类别相同时按照名称升序输出。<br>这道题最初想用嵌套查找+<code>RANK()</code>来做，类似课上讲的 <a href="https://guoxiaotao.xyz/2020/04/20/CMU-DB-2-Advanced-SQL/">输出每门课上id最高的学生</a> 的例子，但是sqlite3一直报括号附近语法错误，直接运行老师的代码都不行，最后也没弄明白，最后换了一种思路用  <code>with</code>来写，先找出每类最长电影的持续时长存在一个中间table里面，后面输出就比较简单了，结果和答案一样，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select longest runtime by type and its type</span></span><br><span class="line"><span class="keyword">WITH</span> temp(maxruntime, t) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(runtime_minutes), titles.type <span class="keyword">FROM</span> titles <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">type</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> titles.type, titles.primary_title, titles.runtime_minutes <span class="keyword">FROM</span> titles, temp</span><br><span class="line"><span class="keyword">WHERE</span> titles.runtime_minutes = temp.maxruntime</span><br><span class="line"><span class="keyword">AND</span> titles.type = temp.t</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">type</span> <span class="keyword">ASC</span>, primary_title <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">sqlite&gt; .read ./placeholder/q2_uncommon_type.sql</span><br><span class="line">movie|Logistics|51420</span><br><span class="line">short|Kuriocity|461</span><br><span class="line">tvEpisode|Téléthon 2012|1800</span><br><span class="line">tvMiniSeries|Kôya no yôjinbô|1755</span><br><span class="line">tvMovie|ArtQuench Presents Spirit Art|2112</span><br><span class="line">tvSeries|The Sharing Circle|8400</span><br><span class="line">tvShort|Paul McCartney Backstage at Super Bowl XXXIX|60</span><br><span class="line">tvShort|The People Next Door|60</span><br><span class="line">tvSpecial|Katy Perry Live: Witness World Wide|5760</span><br><span class="line">video|Midnight Movie Madness: 50 Movie Mega Pack|5135</span><br><span class="line">videoGame|Flushy Fish VR: Just Squidding Around|1500</span><br></pre></td></tr></table></figure>
<h3 id="Q3-TV-VS-MOVIE"><a href="#Q3-TV-VS-MOVIE" class="headerlink" title="Q3 TV_VS_MOVIE"></a>Q3 TV_VS_MOVIE</h3><blockquote>
<p>List all types of titles along with the number of associated titles.</p>
</blockquote>
<p>输出每个类别和该类别的电影数量，按数量升序输出。<br>这道题相对上一道题比较简单，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> type_number(<span class="keyword">type</span>, <span class="built_in">number</span>) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">type</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> titles <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">type</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> type_number <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">number</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">tvShort|4075</span><br><span class="line">videoGame|9044</span><br><span class="line">tvSpecial|9107</span><br><span class="line">tvMiniSeries|10291</span><br><span class="line">tvMovie|45431</span><br><span class="line">tvSeries|63631</span><br><span class="line">video|90069</span><br><span class="line">movie|197957</span><br><span class="line">short|262038</span><br><span class="line">tvEpisode|1603076</span><br></pre></td></tr></table></figure>
<h3 id="Q4-OLD-IS-NOT-GOLD"><a href="#Q4-OLD-IS-NOT-GOLD" class="headerlink" title="Q4 OLD_IS_NOT_GOLD"></a>Q4 OLD_IS_NOT_GOLD</h3><blockquote>
<p>Which decades saw the most number of titles getting premiered? List the number of titles in every decade. Like <code>2010s|2789741</code>.</p>
</blockquote>
<p>按电影年代输出每个年代的电影数量，按电影数量降序输出。</p>
<p>这道题一开始想到用一个<code>WITH</code>创建了临时表格存储年代以及对应的电影，最后可以通过按年代<code>COUNT</code>输出年代以及数量（上映年份为<code>NULL</code>的去除），但是这样不能用数量作为排序标准，后来参考<a href="https://cakebytheoceanluo.github.io/2020/03/07/CMU-15445-HomeWork1-19Fall/" target="_blank" rel="noopener">这个博主的做法</a>，创建了两个临时表格最后输出，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">period</span>(<span class="keyword">year</span>, movie) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="keyword">CAST</span>(premiered <span class="keyword">AS</span> <span class="built_in">TEXT</span>), <span class="number">1</span>, <span class="number">3</span>) ||  <span class="string">"0s"</span>,</span><br><span class="line">                primary_title <span class="keyword">FROM</span> titles</span><br><span class="line">        <span class="keyword">WHERE</span> premiered <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">), year_num(<span class="keyword">year</span>, <span class="keyword">num</span>) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">year</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> <span class="keyword">period</span></span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">year</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>, <span class="keyword">num</span> <span class="keyword">FROM</span> year_num <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 输出</span></span><br><span class="line">sqlite&gt; .read ./placeholder/q4_old_is_not_gold.sql</span><br><span class="line">2010s|1050732</span><br><span class="line">2000s|494639</span><br><span class="line">1990s|211453</span><br><span class="line">1980s|119258</span><br><span class="line">1970s|99707</span><br><span class="line">1960s|75237</span><br><span class="line">1950s|39554</span><br><span class="line">1910s|26596</span><br><span class="line">1920s|13153</span><br><span class="line">1930s|11492</span><br><span class="line">1940s|10011</span><br><span class="line">1900s|9586</span><br><span class="line">2020s|2492</span><br><span class="line">1890s|2286</span><br><span class="line">1880s|22</span><br><span class="line">1870s|1</span><br></pre></td></tr></table></figure>
<h3 id="Q5-PERCENTAGE"><a href="#Q5-PERCENTAGE" class="headerlink" title="Q5 PERCENTAGE"></a>Q5 PERCENTAGE</h3><blockquote>
<p>List the decades and the percentage of titles which premiered in the corresponding decade. Display like : <code>2010s|45.7042</code></p>
</blockquote>
<p>在上一题的基础上把数量换成总电影的百分比（包括<code>NULL</code>的部分）。这一题一开始卡在怎么计算电影总量不被 <code>group</code> 影响，后来发现可以用 <code>select</code> 生成一个临时变量，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">period</span>(<span class="keyword">year</span>, movie) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="keyword">CAST</span>(premiered <span class="keyword">AS</span> <span class="built_in">TEXT</span>), <span class="number">1</span>, <span class="number">3</span>) ||  <span class="string">"0s"</span>,</span><br><span class="line">                primary_title <span class="keyword">FROM</span> titles</span><br><span class="line">        <span class="keyword">WHERE</span> premiered <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>)</span><br><span class="line">, year_num(<span class="keyword">year</span>, <span class="keyword">num</span> ) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">year</span>, </span><br><span class="line">        <span class="keyword">ROUND</span>(<span class="number">100.0</span> * <span class="keyword">COUNT</span>(*)/ (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> titles), <span class="number">4</span>) <span class="keyword">FROM</span> <span class="keyword">period</span></span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">year</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>, <span class="keyword">num</span> <span class="keyword">FROM</span> year_num <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 输出</span></span><br><span class="line">sqlite&gt; .read ./placeholder/q5_percentage.sql</span><br><span class="line">2010s|45.7891</span><br><span class="line">2000s|21.5555</span><br><span class="line">1990s|9.2148</span><br><span class="line">1980s|5.1971</span><br><span class="line">1970s|4.3451</span><br><span class="line">1960s|3.2787</span><br><span class="line">1950s|1.7237</span><br><span class="line">1910s|1.159</span><br><span class="line">1920s|0.5732</span><br><span class="line">1930s|0.5008</span><br><span class="line">1940s|0.4363</span><br><span class="line">1900s|0.4177</span><br><span class="line">2020s|0.1086</span><br><span class="line">1890s|0.0996</span><br><span class="line">1880s|0.001</span><br><span class="line">1870s|0.0</span><br></pre></td></tr></table></figure>
<h3 id="Q6-DUBBED-SMASH"><a href="#Q6-DUBBED-SMASH" class="headerlink" title="Q6 DUBBED_SMASH"></a>Q6 DUBBED_SMASH</h3><blockquote>
<p>List the top 10 dubbed titles with the number of dubs.</p>
</blockquote>
<p>按配音版本数量降序输出前十名配音版本最多的电影名和对应的数量，这道题先找到所有的配音版本电影数量，再用 <code>LIMIT</code> 来限制输出数量，代码如下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> dubbed(t_id, <span class="keyword">num</span>) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> title_id, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> akas</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> title_id</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> primary_title, <span class="keyword">num</span>  <span class="keyword">FROM</span> dubbed, titles</span><br><span class="line"><span class="keyword">WHERE</span> titles.title_id = dubbed.t_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 输出</span></span><br><span class="line">sqlite&gt; .read ./placeholder/q6_dubbed_smash.sql</span><br><span class="line">Mutant Virus: Vol. 1|126</span><br><span class="line">The Good, the Bad and the Ugly|73</span><br><span class="line">Star Wars: Episode V - The Empire Strikes Back|71</span><br><span class="line">Dr. Strangelove or: How I Learned to <span class="keyword">Stop</span> Worrying <span class="keyword">and</span> Love the Bomb|<span class="number">68</span></span><br><span class="line">Raiders <span class="keyword">of</span> the Lost Ark|<span class="number">62</span></span><br><span class="line">Star Wars: Episode VII - The <span class="keyword">Force</span> Awakens|<span class="number">62</span></span><br><span class="line">The Shawshank Redemption|<span class="number">61</span></span><br><span class="line">Once Upon a <span class="built_in">Time</span> <span class="keyword">in</span> the West|<span class="number">60</span></span><br><span class="line">Indiana Jones <span class="keyword">and</span> the Kingdom <span class="keyword">of</span> the Crystal Skull|<span class="number">60</span></span><br><span class="line">Airplane!|<span class="number">59</span></span><br></pre></td></tr></table></figure>
<h3 id="Q7-IMDB-250"><a href="#Q7-IMDB-250" class="headerlink" title="Q7 IMDB_250"></a>Q7 IMDB_250</h3><blockquote>
<p>List the IMDB Top 250 movies along with its weighted rating.</p>
</blockquote>
<p>按权重分数降序输出IMDB TOP250电影，计算规则如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Weighted rating (WR) = (v/(v+m)) * R + (m/(v+m)) * C</span><br><span class="line">R = 电影平均得分 i.e. ratings.rating</span><br><span class="line">v = 电影投票数, i.e. ratings.votes</span><br><span class="line">m = 要进top250的最少投票数 (current 25000)</span><br><span class="line">C = 所有投票的平均得分 （计算方式是所有投票乘相应得分再除以总票数）</span><br></pre></td></tr></table></figure>
<p>这道题主要就是注意以下各个变量的计算方法还有imbd要限定类型是电影，代码如下，结果太长就不打了，确认过和答案一样。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> wr( t_id, WR ) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> ratings.title_id,</span><br><span class="line">        (votes / (votes + <span class="number">25000.0</span>)) * rating +</span><br><span class="line">        (<span class="number">25000.0</span> / (votes + <span class="number">25000.0</span>)) * </span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="keyword">SUM</span>(rating * votes) / <span class="keyword">SUM</span>(votes) <span class="keyword">FROM</span> ratings, titles </span><br><span class="line">         <span class="keyword">WHERE</span> ratings.title_id = titles.title_id <span class="keyword">AND</span> titles.type = <span class="string">"movie"</span>)</span><br><span class="line">        <span class="keyword">FROM</span> ratings,titles</span><br><span class="line">        <span class="keyword">WHERE</span> ratings.title_id = titles.title_id <span class="keyword">AND</span> titles.type = <span class="string">"movie"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> primary_title, WR <span class="keyword">FROM</span> wr, titles</span><br><span class="line"><span class="keyword">WHERE</span> titles.title_id = t_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> WR <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">250</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Q8-NUMBER-OF-ACTORS"><a href="#Q8-NUMBER-OF-ACTORS" class="headerlink" title="Q8 NUMBER_OF_ACTORS"></a>Q8 NUMBER_OF_ACTORS</h3><blockquote>
<p>List the number of actors / actresses who have appeared in any title with Mark Hamill (born in 1951).</p>
</blockquote>
<p>输出所有和mark hamill有合作过的演员。这道题的思路是可以先找到所有mark hamill参演过的节目，然后再找到参演过那些节目的演员，主要去去重，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> title_with_hamill(title_id) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> title_id <span class="keyword">FROM</span> crew, people</span><br><span class="line">        <span class="keyword">WHERE</span> crew.person_id = people.person_id  </span><br><span class="line">        <span class="keyword">AND</span> people.name = <span class="string">"Mark Hamill"</span> </span><br><span class="line">        <span class="keyword">AND</span> people.born = <span class="number">1951</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> person_id) <span class="keyword">FROM</span> crew, title_with_hamill</span><br><span class="line"><span class="keyword">WHERE</span> crew.title_id = title_with_hamill.title_id</span><br><span class="line"><span class="keyword">AND</span> (crew.category = <span class="string">"actor"</span> <span class="keyword">OR</span> crew.category = <span class="string">"actress"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 输出</span></span><br><span class="line">sqlite&gt; .read ./placeholder/q8_number_of_actors.sql</span><br><span class="line">206</span><br></pre></td></tr></table></figure>
<h3 id="Q9-MOVIE-NAMES"><a href="#Q9-MOVIE-NAMES" class="headerlink" title="Q9 MOVIE_NAMES"></a>Q9 MOVIE_NAMES</h3><blockquote>
<p>List the movies in alphabetical order which cast both Mark Hamill (born in 1951) and George Lucas (born in 1944).</p>
</blockquote>
<p>输出所有Mark Hamill 和 George Lucas 共同参演的电影名，按字母顺序输出，思路跟上一题差不多，找到mark hamill 参演的电影在在里面找 Georage Lucas 参演的过输出名字就可以了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> title_with_hamill(title_id) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> title_id <span class="keyword">FROM</span> crew, people</span><br><span class="line">        <span class="keyword">WHERE</span> crew.person_id = people.person_id  </span><br><span class="line">        <span class="keyword">AND</span> people.name = <span class="string">"Mark Hamill"</span></span><br><span class="line">        <span class="keyword">AND</span> people.born = <span class="number">1951</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> primary_title <span class="keyword">FROM</span> crew, title_with_hamill, people, titles</span><br><span class="line"><span class="keyword">WHERE</span> crew.title_id = title_with_hamill.title_id</span><br><span class="line"><span class="keyword">AND</span> titles.type = <span class="string">"movie"</span></span><br><span class="line"><span class="keyword">AND</span> crew.title_id = titles.title_id</span><br><span class="line"><span class="keyword">AND</span> (crew.person_id = people.person_id </span><br><span class="line">        <span class="keyword">AND</span> people.name = <span class="string">"George Lucas"</span> </span><br><span class="line">        <span class="keyword">AND</span> people.born = <span class="number">1944</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> primary_title;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 输出</span></span><br><span class="line">sqlite&gt; .read ./placeholder/q9_movie_names.sql</span><br><span class="line">Star Wars: Episode V - The Empire Strikes Back</span><br></pre></td></tr></table></figure>
<h3 id="Q10-GENRE-COUNTS"><a href="#Q10-GENRE-COUNTS" class="headerlink" title="Q10 GENRE_COUNTS"></a>Q10 GENRE_COUNTS</h3><blockquote>
<p>List all distinct genres and the number of titles associated with them.</p>
</blockquote>
<p>从<code>title</code>里面的<code>genres</code>类别提取出所有不重复的类别，并类别输出相对应的节目数量，按降序排列，这里主要参考了<a href="https://stackoverflow.com/a/32051164" target="_blank" rel="noopener">这种做法</a>，将<code>genres</code>里的值取出来然后统一成<code>&#39;&#39;, &#39;...,...,...,&#39;</code>的格式，然后通过迭代和用<code>INSTR</code>找到逗号的位置，以及<code>SUBSTR</code>分割字符串来提取出所有类，最后按类别输出数量，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">split</span>(word, <span class="keyword">str</span>) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="string">''</span>, genres || <span class="string">','</span> <span class="keyword">FROM</span> titles</span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">SUBSTR</span>(<span class="keyword">str</span>, <span class="number">0</span>, <span class="keyword">INSTR</span>(<span class="keyword">str</span>, <span class="string">','</span>)),</span><br><span class="line">    <span class="keyword">SUBSTR</span>(<span class="keyword">str</span>, <span class="keyword">INSTR</span>(<span class="keyword">str</span>, <span class="string">','</span>)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">FROM</span> <span class="keyword">split</span> <span class="keyword">WHERE</span> <span class="keyword">str</span>!=<span class="string">''</span></span><br><span class="line">), </span><br><span class="line">genre_num(genre, <span class="keyword">num</span>) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> word, <span class="keyword">count</span>(word) </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">split</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> word</span><br><span class="line"><span class="keyword">HAVING</span> word != <span class="string">''</span> <span class="keyword">AND</span> word != <span class="string">'\N'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span>  * <span class="keyword">FROM</span> genre_num</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">sqlite&gt; .read ./placeholder/q10_genre_counts.sql</span><br><span class="line">Drama|620063</span><br><span class="line">Comedy|486163</span><br><span class="line">Short|310619</span><br><span class="line">Documentary|222187</span><br><span class="line">Talk-<span class="keyword">Show</span>|<span class="number">215144</span></span><br><span class="line">Romance|<span class="number">211462</span></span><br><span class="line">Family|<span class="number">159035</span></span><br><span class="line">News|<span class="number">148941</span></span><br><span class="line">Animation|<span class="number">115998</span></span><br><span class="line">Reality-TV|<span class="number">113180</span></span><br><span class="line">Music|<span class="number">105724</span></span><br><span class="line">Crime|<span class="number">99019</span></span><br><span class="line"><span class="keyword">Action</span>|<span class="number">97544</span></span><br><span class="line">Adventure|<span class="number">81686</span></span><br><span class="line">Game-<span class="keyword">Show</span>|<span class="number">75169</span></span><br><span class="line">Adult|<span class="number">65704</span></span><br><span class="line">Sport|<span class="number">48855</span></span><br><span class="line">Fantasy|<span class="number">48341</span></span><br><span class="line">Mystery|<span class="number">47155</span></span><br><span class="line">Horror|<span class="number">41552</span></span><br><span class="line">Thriller|<span class="number">40664</span></span><br><span class="line">History|<span class="number">31675</span></span><br><span class="line">Sci-Fi|<span class="number">31441</span></span><br><span class="line">Biography|<span class="number">27001</span></span><br><span class="line">Musical|<span class="number">17939</span></span><br><span class="line">Western|<span class="number">9811</span></span><br><span class="line">War|<span class="number">9309</span></span><br><span class="line">Film-Noir|<span class="number">322</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>激光雷达运动畸变去除</title>
    <url>/2020/04/21/lidarSLAM-3/</url>
    <content><![CDATA[<p>本文是我在学习深蓝学院的<a href="https://www.shenlanxueyuan.com/course/152" target="_blank" rel="noopener">激光slam课程</a>第三讲的学习笔记，在上一节课学习了轮式里程计的校正之后，这一课学习传感器数据预处理的另一部分：激光雷达运动畸变的校正，这一部分是对激光slam的效果和性能影响非常大的部分。这篇大部分的公式推导并不困难，主要在理解不同方法的要点和思想以及优缺点。</p>
<a id="more"></a>
<h2 id="激光雷达"><a href="#激光雷达" class="headerlink" title="激光雷达"></a>激光雷达</h2><h3 id="传感器介绍"><a href="#传感器介绍" class="headerlink" title="传感器介绍"></a>传感器介绍</h3><p>按照测距原理分激光雷达有两种</p>
<h4 id="三角测距"><a href="#三角测距" class="headerlink" title="三角测距"></a>三角测距</h4><p>三角测距的大致原理如下图所示，和双目类似通过两个点测出目标点和两点连线的距离，计算方法大概如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x + y &= L \\
\frac{x}{\sin{(\frac{\pi}{2}-\beta)}} &= \frac{d}{\sin{\beta}} \\
\frac{y}{\sin{(\frac{\pi}{2}-\alpha)}} &= \frac{d}{\sin{\alpha}}
\end{aligned}</script><p>三个方程三个未知数，联立可以解出，可以发现距离和基线和两个出射角都有关：</p>
<script type="math/tex; mode=display">d = L \frac{\sin{\alpha}\sin{\beta}}{\sin{(\alpha+\beta)}}</script><img src="/2020/04/21/lidarSLAM-3/%E4%B8%89%E8%A7%92%E6%B5%8B%E8%B7%9D.png" class="" title="lidarSLAM-3">
<p>三角测距有以下特点：</p>
<ul>
<li><em>受限于基线长度</em>，中近距离精度较高，远距离精度较差（所以一般在室内用）</li>
<li>结构简单，价格比较便宜</li>
<li>比较容易受干扰（强光等）</li>
</ul>
<h4 id="飞行时间测距（tof）"><a href="#飞行时间测距（tof）" class="headerlink" title="飞行时间测距（tof）"></a>飞行时间测距（tof）</h4><p>飞行时间的测距原理如下所示，原理偏光学一点所以不推导了。</p>
<img src="/2020/04/21/lidarSLAM-3/tof.png" class="" title="lidarSLAM-3">
<p>TOF的特点：</p>
<ul>
<li>测距范围广（只跟时间差/光相位差有关，距离影响不大）</li>
<li>测距精度高</li>
<li>抗干扰能力强</li>
<li>价格贵</li>
<li>室内/外都可以用</li>
</ul>
<h3 id="激光雷达数学模型介绍"><a href="#激光雷达数学模型介绍" class="headerlink" title="激光雷达数学模型介绍"></a>激光雷达数学模型介绍</h3><p>这里主要介绍如何通过激光束的观测结果以及地图来计算机器人位姿的数学模型。</p>
<h4 id="光束模型（beam-model）"><a href="#光束模型（beam-model）" class="headerlink" title="光束模型（beam model）"></a>光束模型（beam model）</h4><p>这个模型是概率学提出的比较传统的数学模型，具体来说可以参考以下四张图。假设机器人位姿是 $x_t$, 并且发射一束激光期望能够打到前方 $z_t^*$ (期望值)距离处的物体（根据地图 $m$ 获得期望值），但是由于各种原因（噪声），返回来的值 $z_t$ (观测值)不一定和实际值一致。而光束模型认为总共能有四种噪声和真实值耦合形成观测值，分别是：</p>
<ul>
<li>高斯噪声：高斯噪声使得观测值在真实值周围形成高斯分布 （大部分时候是符合这个分布）</li>
<li>物体被遮挡：因为物体被遮挡所以观测值会比真实值小很多，形成指数分布 （出现动态物体的时候会出现）</li>
<li>没扫到物体：因为物体没被扫到所以观测值无穷大（可以通过判断是否超出有效距离过滤掉）</li>
<li>均匀噪声：均匀噪声使得观测值在真实值周围形成均匀分布（正常传感器应该不太会出现这种噪声）</li>
</ul>
<img src="/2020/04/21/lidarSLAM-3/%E5%85%89%E6%9D%9F%E6%A8%A1%E5%9E%8B.png" class="" title="lidarSLAM-3">
<p>基于这四种模型，我们给每种模型分配不同的权重(对每一个激光点 $z_t^k$， 共k个)<em>计算出在当前位姿基于建好的地图出现观测值的概率就可以用来判断位姿的准确性</em>，计算过程如下：<br>先计算出每个激光点的得分（出现概率，越高所以越准确），第一项是四个模型的权重，一般高斯分布的权重会比较高（大部分），均匀分布的权重比较低（出现情况很少）。</p>
<script type="math/tex; mode=display">
p(z_t^k|x_t, m) = \begin{bmatrix}z_{hit}\\z_{short}\\z_{max}\\z_{rand}\end{bmatrix}^T\begin{bmatrix}p_{hit}(z_t^k|x_t,m)\\p_{short}(z_t^k|x_t,m)\\p_{max}(z_t^k|x_t,m)\\p_{rand}(z_t^k|x_t,m)\end{bmatrix}</script><p>然后我们再把该帧所有激光点的概率相乘就能得到这帧激光束的得分（概率），这个模型的要点就要搜索一个位姿 $x_t^*$ 使得该帧的得分（出现概率）最高。</p>
<script type="math/tex; mode=display">
p(z_t|x_t, m) = \prod_{k=1}^Kp(z_t^k|x_t, m)</script><p>这个模型需要将一个激光束中所有的点的概率都计算出来（一条线上的所有激光点）而且一帧有很多条激光束，<em>计算量大</em>。<br>并且这个模型有一个致命的缺点。假设我们考虑在一个比较结构化的场景（室内环境，大部分都是平面的结构等等）的时候，这个时候当我们在靠近真实值的过程中，我们可以发现计算出来的激光束的得分是逐渐上升的，而且变化大部分是一个连续的过程，这种场景下没有问题。但是如果在比较不规则的场景（室外环境，假设有一个电线杆在 $z_t^<em>$ 处），这个时候只要我们<em>*假设的位姿离真实位姿有一点点的变化都会导致激光束的得分急剧降低</em></em>（只要稍微旋转一下就扫不动电线杆，所以会出现无穷大 $z_{max}$ ，而实际激光束 $z_t$ 并不是），所以这会给搜索带来很大的困难以及误匹配，因为这两个原因，所以现在实际上比较少采用这种模型。</p>
<h4 id="似然场模型-likelyhood-model"><a href="#似然场模型-likelyhood-model" class="headerlink" title="似然场模型 (likelyhood model)"></a>似然场模型 (likelyhood model)</h4><p>似然场模型的原理如下图所示，左边是实际环境图 $m$ ，这个时候如果不考虑似然场的话我们可以认为如果在给定位姿 $x_t$ 的时候打中 实际障碍物的概率是 1，如果没打中就是 0，这样每条激光束出现概率非 0 即 1，过于绝对出现光束模型的病态问题，似然场模型的要点是将地图进行高斯平滑，激光束击中障碍物周围的环境形成以障碍物位姿为中心的高斯分布，这样就算我们估算的位姿不是很准确导致在那个位姿实际上打不到障碍物，如右图所示，该帧观测值的概率也不会是0，而是一个接近1的值，这样做的好处有：</p>
<ul>
<li>结果随环境影响变化不大，适合用于结构化和非结构化环境</li>
<li>不用对每束激光束的所有激光点都计算（只需要对每束光束的端点查表计算概率），计算比较简单</li>
</ul>
<img src="/2020/04/21/lidarSLAM-3/%E4%BC%BC%E7%84%B6%E5%9C%BA.png" class="" title="lidarSLAM-3">
<h3 id="运动畸变成因"><a href="#运动畸变成因" class="headerlink" title="运动畸变成因"></a>运动畸变成因</h3><p>运动畸变如下图所示，观测结果会和真实结果有一个偏差，主要产生的根本原因是<strong>我们假设激光雷达的扫描结果是在同一时刻（机器人位姿没有变化）产生，但是实际上激光雷达的扫描结果需要一定时间，在这个时间内机器人如果有运动的话实际的扫描的结果就会出现偏移</strong>。假设按照下图场景，激光雷达逆时针旋转，在一开始旋转的时候 $t_0$ 机器人还没有往前走，所以结果是准确的，但是在转过一半之后$(t+\delta t)$机器人已经往前走了一段距离，这个时候激光扫描结果会变小（因为靠近墙了），但是我们还是认为他在$t_0$时刻的位置，所以结果就会显示是墙离我们越来越近了，所以会出现歪掉的现象，原因是因为<strong>激光帧率比较低的时候，机器人的运动不能忽略</strong>，这个畸变现象是由于运动畸变带来的（根本原因是旋转速度太慢），所以叫做运动畸变。</p>
<img src="/2020/04/21/lidarSLAM-3/%E7%95%B8%E5%8F%98.png" class="" title="lidarSLAM-3">
<h2 id="运动畸变去除"><a href="#运动畸变去除" class="headerlink" title="运动畸变去除"></a>运动畸变去除</h2><p>接下来开始介绍怎么进行运动畸变的去除。</p>
<h3 id="纯估计方法"><a href="#纯估计方法" class="headerlink" title="纯估计方法"></a>纯估计方法</h3><p>首先讲纯估计的方法，这种方法是一种<em>类ICP</em>的方法。</p>
<h4 id="迭代最近点-ICP-方法"><a href="#迭代最近点-ICP-方法" class="headerlink" title="迭代最近点(ICP)方法"></a>迭代最近点(ICP)方法</h4><p>先介绍ICP的方法，ICP(Itrative Cloest Point)迭代最近点的方法的要点是，给定两个两个点云：</p>
<script type="math/tex; mode=display">
\begin{aligned}
X &= \{x_1, x_2, ..., x_N\}\\
P &= \{p_1, p_2, ..., p_N\}
\end{aligned}</script><p>我们需要找到一个变换关系 $(R, t)$ 使得下式最小，这个过程叫<em>点云配准</em>，或者匹配点云。式子里面有旋转矩阵 $R$ 所以会引入三角量，因此不能用线性最小二乘解来求：</p>
<script type="math/tex; mode=display">
E(R, t) = \frac{1}{N}\sum_{i=1}^{N}||x_i-Rp_i-t||^2</script><p>在<strong>给定两个点云的对应点</strong>的时候，虽然不能用线性最小二乘解，但是这个式子的最小值有解析解（在后面讲到帧间匹配的时候会推导，这里先直接说明，之后补充），计算过程是：</p>
<ul>
<li>先求出两个点云的几何中心</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
u_x &= \sum_{i=1}^{N}x_i\\
u_p &= \sum_{i=1}^{N}p_i
\end{aligned}</script><ul>
<li>对两个点云去中心化</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
X' = \{x_i-u_x\} = \{x_i'\}\\
P' = \{p_i-u_p\} = \{p_i'\}
\end{aligned}</script><ul>
<li>SVD 分解</li>
</ul>
<script type="math/tex; mode=display">
W = \sum_{i=1}^{N}x_i'p_i'^T = U\begin{bmatrix}\sigma_1 & 0 & 0 \\ 0 & \sigma_2 & 0 \\0 & 0 & \sigma_3\end{bmatrix}V^T</script><ul>
<li>ICP 的解是：</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
R &= UV^T\\
t &= u_x - Ru_p
\end{aligned}</script><p>实际过程中，我们大概率并<strong>不知道对应点关系</strong>，这个时候不可以一步计算出 $R$ 和 $t$ 的最佳结果，需要用到<strong>期望最大化</strong> (Expectation Maxmization, EM) 的思想，先给定一个初值（匹配关系），利用初值进行计算 R 和 t, 再根据 R 和 t 对点云进行转换，计算误差和新的匹配关系，根据新的匹配关系进项迭代计算，直至最后算出误差小于一个阈值，这个时候可以认为匹配关系和点云之间的转换关系都计算比较准确了，大概过程如下图所示：</p>
<img src="/2020/04/21/lidarSLAM-3/%E7%BA%AF%E4%BC%B0%E8%AE%A1%E6%B3%95.png" class="" title="lidarSLAM-3">
<h4 id="VICP方法"><a href="#VICP方法" class="headerlink" title="VICP方法"></a>VICP方法</h4><p>ICP在激光匹配中没有考虑两种情况：激光的运动畸变和部分激光数据可能是错误的（错误数据可能就是来自于运动畸变）。基于这种情况，VICP（Velocity-ICP）把速度的影响也考虑在内，它的要点是假设机器人在扫描过程中进行<strong>匀速运动</strong>，在匹配迭代的时候同时估计机器人的速度，本质上用匀速运动对一帧内的位姿进行线性插值（LOAM里面也有用到这个方法），具体计算过程如下：</p>
<ul>
<li>$X^i, X^{i-1}$ 表示第i帧和第i-1帧的激光扫描数据</li>
<li>$T^i, T^{i-1}$ 表示对应时刻的位姿</li>
<li>机器人的速度$V_i$可以通过两个时刻的位姿和时间差求出</li>
<li>我们把第i帧的时间划分为n段，分别是:</li>
</ul>
<script type="math/tex; mode=display">(t_i-n\Delta t, t_i - (n-1)\Delta t, ... ,t_i - \Delta t, t_i)</script><ul>
<li>则第i帧的第j个节点的位姿矩阵是：$T_{t_i - (n-j)\Delta t} = T_ie^{(n-j)\Delta t(-V_i)}$</li>
<li>所以校正过程是：$\bar X^i = \{e^{(n-j)\Delta t(-V_i)}x_j|j=0,…,n\}$</li>
</ul>
<p>算法流程和效果如下图所示：</p>
<img src="/2020/04/21/lidarSLAM-3/vicp.png" class="" title="lidarSLAM-3">
<h3 id="里程计辅助方法"><a href="#里程计辅助方法" class="headerlink" title="里程计辅助方法"></a>里程计辅助方法</h3><p>VICP有两个缺点：</p>
<ul>
<li>在用低帧率（5Hz， 200ms）的激光雷达，匀速运动假设不成立（每帧时间太长）</li>
<li>在数据预处理（去畸变）的过程中跟状态估计（速度和位姿估计）耦合在一起</li>
</ul>
<p>而里程计/IMU可以弥补这个缺点，因为它的位姿更新频率很快(200Hz，5ms, IMU能到1kHz)，所以能够更加准确的反应运动情况，同时可以跟状态估计完全解耦。因此在里程计短时间内(200ms)的准确度比较高的时候，我们可以借助里程计来去除畸变，IMU的更新频率也很快，但是它的线性加速度精度太差（控制成本的情况下），所以几乎不能用来估计位置信息。</p>
<p>在处理信息的时候也有两种思路：</p>
<ul>
<li>单片机读取激光雷达数据和位姿信息，进行运动畸变去除，然后上传到CPU，好处是不用考虑不同系统的时间同步问题，但是由于在单片机处理之后再上传所以数据需要压缩，否则会产生延时</li>
<li>用CPU读取激光雷达数据，然后单片机上传里程计积分数据，先对数据进行时间同步然后统一进行畸变去除，需要位姿插值，因为没有时延问题所以通常采用这种方法。</li>
</ul>
<p>接下来介绍具体方法，我们已知的数据有：</p>
<ul>
<li>当前帧激光起始时间：$t_s, t_e$</li>
<li>(同一帧内)两束激光的时间差$\Delta t$</li>
<li>一个包含里程计数据的队列，时间范围应该覆盖当前帧激光的时间范围</li>
</ul>
<p>接下来具体目标为：</p>
<ul>
<li>获得当前帧激光数据每一个激光束端点的机器人位姿</li>
<li>根据求解的位姿把所有激光束转换到统一坐标系下</li>
<li>重新封装成一帧激光数据并发布</li>
</ul>
<p>其中关键步骤就是计算当前帧激光数据的对应机器人位姿：</p>
<ul>
<li>假如里程计数据队列正好对到了激光数据的时间范围（时间同步好了），那么激光帧的起止时间的位姿就是里程计数据队列的队头和队尾数据的时间戳</li>
<li>如果开始时间没有对应里程计位姿数据，则用里程计相邻的两个位姿数据进行线性插值（因为里程计数据采集频率高，所以做匀速运动进行线性插值比较合理）</li>
<li>在一帧数据之间的任意一点<ul>
<li>认为机器人做匀加速运动进行二次插值（用起始点，结束点和中间点）</li>
<li>还可以进行分段线性插值（用激光帧时间范围内的所有里程计数据点进行分段线性插值）</li>
</ul>
</li>
</ul>
<p>获得每个激光点对应的机器人位姿 $p_i$ 之后，可以将激光点信息 $x_i$（在当前时间插值得到的位姿坐标系下）转换为统一的坐标系下（比如起始时间）：$x_i’=p_i^Tx_i$，接下来重新封装激光信息发布出去：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x_i' &= (p_x, p_y)\\
range &= \sqrt{p_x^2+p_y^2}\\
angle &= \arctan{(p_y, p_x)}
\end{aligned}</script><h3 id="融合方法"><a href="#融合方法" class="headerlink" title="融合方法"></a>融合方法</h3><p>融合方法主要就是考虑前两种的方法的融合。我们先用里程计方法插值得到位姿数据进行去畸变。假设我们认为里程计方法还是存在误差（采集频率还是不够快），我们可以认为误差是跟时间线性分布的，所以我们用ICP的方法进行一次匹配，并将匹配结果作为正确值，这个过程会产生一个误差作为里程计的误差值。基于误差线性分布的假设，我们可以把误差平均分配到每一个时间段内，进行激光点修正，然后再进行ICP迭代直到结果收敛。</p>
]]></content>
      <categories>
        <category>激光slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>lidar-slam</tag>
      </tags>
  </entry>
  <entry>
    <title>[CMU-15-445/645]-Advanced SQL</title>
    <url>/2020/04/20/CMU-DB-2-Advanced-SQL/</url>
    <content><![CDATA[<p>这是我在学习<a href="https://15445.courses.cs.cmu.edu/fall2019/" target="_blank" rel="noopener">Databases Systems CMU 15-445/645/ Fall 2019</a>过程记录的一些笔记，这节课介绍了SQL的各种语法和应用，主要包括聚合/窗口函数、对字符串和日期的操作、输出控制和重定向以及常用表达式，一部分代码可能逻辑上有点模糊，最好自己跑一下深化理解。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="关于-relational-language-的复习"><a href="#关于-relational-language-的复习" class="headerlink" title="关于 relational language 的复习"></a>关于 relational language 的复习</h3><p>在上一篇中主要介绍了Relational Language的一些基本概念以及相对应的Relational Algebra的一些基本用法。这里面有一个很重要的概念是在使用Relational language的时候只需要说明他们想要得到什么样的结果/答案，并不用去关心如何得到这个结果（包括怎么用relational algebra的基本操作去得到答案），这一部分应该由DBMS(数据库管理系统)去完成以及优化每一次查询操作（包括重新排列用户给的操作以及产生一个查找计划）。</p>
<h3 id="SQL的历史"><a href="#SQL的历史" class="headerlink" title="SQL的历史"></a>SQL的历史</h3><p>SQL最初是从IBM的 system R 中一个叫 “SEQUEL” 的语言演变而来，意思是 “Structred English Query Language”，并在19世纪79年代被 Oracle 采用。在1983年 IBM 发布了DB2，接下来在1986 年被ANSI 作为标准，ISO 在1987 年将他命名为 SQL (Structured Query Language)，目前最新的 SQL 标准到 2016 年，大部分 DBMS 至少支持 SQL-92。</p>
<p>SQL 实际上包括了三种语言，分别是：</p>
<ul>
<li>Data Manipulation Language (DML)：插入，更新，删除数据</li>
<li>Data Definition Language (DDL)：创建定义数据库</li>
<li>Data Conrtol Language (DCL)：权限控制</li>
</ul>
<p>除此之外还包括：查看定义（View Definition），添加控制条件保证数据完整性等等。另外，跟之前提到relational model不一样，SQL是基于 <strong>Bag(无序，但是允许重复数据)</strong> 的，而不是Set(无序且不允许重复)。</p>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="聚合（Aggregations）-分组-Group-By"><a href="#聚合（Aggregations）-分组-Group-By" class="headerlink" title="聚合（Aggregations） + 分组(Group By)"></a>聚合（Aggregations） + 分组(Group By)</h3><p>假设我们现在有一个数据库包括以下三个表格，主要表示了学生信息和课程信息以及他们之间关系：</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/example.png" class="" title="CMU-DB-2-Advanced-SQL">
<h4 id="Aggregates-（聚合）"><a href="#Aggregates-（聚合）" class="headerlink" title="Aggregates （聚合）"></a>Aggregates （聚合）</h4><p>聚合操作是一系列函数的总称，这些函数的特点是取一系列 tuples 然后返回一个单元素(single value)，具体包括以下这些：</p>
<ul>
<li><code>AVG(col)</code>: 返回该列的平均值，下面以此类推</li>
<li><code>MIN(col)</code></li>
<li><code>MAX(col)</code></li>
<li><code>SUM(col)</code></li>
<li><code>COUNT(col)</code>:返回该列元素个数</li>
</ul>
<p>下面看一下这些函数的具体使用场景。</p>
<p>假设我们想要获取用“@cs”邮箱登录的学生个数，我们可能会用以下SQL语句，我们会注意到聚合函数只会用在 SELECT 语句的输出列表中（很显然，因为聚合函数只会产生一个元素所以肯定是最终结果）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(login) <span class="keyword">AS</span> cnt</span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> login <span class="keyword">LIKE</span> <span class="string">'%@cs'</span></span><br></pre></td></tr></table></figure>
<p>我们还可以用以下两种语句来进一步简化：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// ver 2</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt</span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> login <span class="keyword">LIKE</span> <span class="string">'@cs'</span></span><br><span class="line"></span><br><span class="line">// ver <span class="number">3</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">AS</span> cnt</span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> login <span class="keyword">LIKE</span> <span class="string">'%@cs'</span></span><br></pre></td></tr></table></figure>
<p>我们还可以同时使用多个聚合函数，假设我们想获得<code>“@cs”</code>邮箱登录的学生个数和他们的平均GPA，可以用以下方式查找，最后会输出含一个tuple（平均GPA和学生个数）的表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(gpa), <span class="keyword">COUNT</span>(<span class="keyword">sid</span>)</span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> login <span class="keyword">LIKE</span> <span class="string">'%@cs'</span></span><br></pre></td></tr></table></figure>
<p>聚合函数中 <code>COUNT</code>, <code>SUM</code>, <code>AVG</code> 还支持对其输入参数用关键字 <code>DISTINCT</code> 来进行去重，用以下方式可以获得用”@cs”邮箱登录的不重复学生人数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> login) <span class="keyword">AS</span> cnt</span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> login <span class="keyword">LIKE</span> <span class="string">'%@cs'</span></span><br></pre></td></tr></table></figure>
<p>在使用聚合函数的过程要注意在聚合函数以外的列的输出是<em>未定义的(undefined)</em>，具体参考以下例子</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 获取每门课上注册学生的平均GPA</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(s.gpa), e.cid</span><br><span class="line">    <span class="keyword">FROM</span> enrolled <span class="keyword">as</span> e, student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> e.sid = s.sid</span><br></pre></td></tr></table></figure>
<p>程序在不同程序(pavlo，mysql, sqlite)的运行结果，可以发现对这种未定义的行为，不同程序的标准一样，可能会直接报错，也有可能随机挑选一个值输出，所以要尽可能避免出现这种情况：</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/output-result.png" class="" title="CMU-DB-2-Advanced-SQL">
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/result-mysql.png" class="" title="CMU-DB-2-Advanced-SQL">
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/sqlite.png" class="" title="CMU-DB-2-Advanced-SQL">
<h4 id="分组（group-by）"><a href="#分组（group-by）" class="headerlink" title="分组（group by）"></a>分组（group by）</h4><p>要实现上述提到的查找（获取每门课上注册学生的平均GPA），我们还需要加入分组操作来将输入的tuples分成不同部分并对每个部分进行聚合运算，代码和结果如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(s.gpa), e.cid</span><br><span class="line">    <span class="keyword">FROM</span> enrolled <span class="keyword">AS</span> e, student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> e.sid = s.sid</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> e.sid</span><br></pre></td></tr></table></figure>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/result2.png" class="" title="CMU-DB-2-Advanced-SQL">
<p>注意：所有出现在 <code>SELECT</code> 输出语句的非聚合值必须都要出现 <code>GROUP BY</code> 语句里，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// s.name 要出现在 GROUP BY 语句里</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(s.gpa), e.cid， s.name</span><br><span class="line">    <span class="keyword">FROM</span> enrolled <span class="keyword">AS</span> e, student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> e.sid = s.sid</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> e.sid</span><br></pre></td></tr></table></figure>
<p>如果我们想对输出的table进行筛选，比如选出平均gpg高于3.9的，我们可能会想到以下语句，但是聚合计算的结果不能出现<code>ADD</code>语句里面，我们可以用HAVGING语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// avg_gpa 不能出现在 AND 作为条件！</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(s.gpa) <span class="keyword">AS</span> avg_gpa, e.cid</span><br><span class="line">    <span class="keyword">FROM</span> enrolled <span class="keyword">AS</span> e, student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> e.sid = s.sid</span><br><span class="line">    <span class="keyword">AND</span> avg_gpa &gt; <span class="number">3.9</span></span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> e.sid</span><br><span class="line"></span><br><span class="line">// avg_gpa 可以出现在<span class="keyword">HAVING</span>语句里作为筛选条件</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(s.gpa) <span class="keyword">AS</span> avg_gpa, e.cid</span><br><span class="line">    <span class="keyword">FROM</span> enrolled <span class="keyword">AS</span> e, student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> e.sid = s.sid</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> e.sid</span><br><span class="line">    <span class="keyword">HAVING</span> avg_gpa &gt; <span class="number">3.0</span>;</span><br></pre></td></tr></table></figure>
<p>成果运行结果如下：</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/result-filter.png" class="" title="CMU-DB-2-Advanced-SQL">
<p>通过这种方式可以很方便筛选我们想要的结果，而且不用考虑实现过程。</p>
<h3 id="String-amp-Date-Time-Operation"><a href="#String-amp-Date-Time-Operation" class="headerlink" title="String &amp; Date/Time Operation"></a>String &amp; Date/Time Operation</h3><p>下面对SQL里面有关string, date 和 time 的操作进行介绍</p>
<h4 id="String-字符串操作"><a href="#String-字符串操作" class="headerlink" title="String 字符串操作"></a>String 字符串操作</h4><p>针对String的操作，不同DBMS的它的要求（单/双引号，区分/不区分大小写）不一样，具体参考下表</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/string-1.png" class="" title="CMU-DB-2-Advanced-SQL">
<p><strong>LIKE</strong> 关键字可以用来进行字符串匹配，匹配操作为：<code>&#39;%&#39;</code>匹配任何子串（包括空串），’_’ 匹配任何单个字符，具体例子如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 找到所有 e.cid 以 '15-' 开头的</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> enrolled <span class="keyword">AS</span> e</span><br><span class="line">    <span class="keyword">WHERE</span> e.cid <span class="keyword">LIKE</span> <span class="string">'15-%'</span></span><br><span class="line"></span><br><span class="line">// 找到所有登录名 以 <span class="string">'@c'</span> + 一个字符串结尾的</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> s.login <span class="keyword">LIKE</span> <span class="string">'%@c_'</span></span><br></pre></td></tr></table></figure>
<p>SQL 还定义了一些字符串操作的函数既可以用来输出结果也能用来作为条件，部分例子如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 取长度为5的子串</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTRING</span>(<span class="keyword">name</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="keyword">AS</span> abbrv_name</span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">sid</span> = <span class="number">53688</span></span><br><span class="line"></span><br><span class="line">// 转大写</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">UPPER</span>(s.name) <span class="keyword">LIKE</span> <span class="string">'KAN%'</span></span><br></pre></td></tr></table></figure>
<p>SQL标准里面规定可以用 <code>&#39;||&#39;</code> 来链接两个或多个字符串，其他不同DBMS也有不同的操作符/函数支持：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// SQL-92</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line">    <span class="keyword">WHERE</span> login = <span class="keyword">LOWER</span>(<span class="keyword">name</span>) || <span class="string">'@cs'</span></span><br><span class="line"></span><br><span class="line">// MSSQL</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line">    <span class="keyword">WHERE</span> login = <span class="keyword">LOWER</span>(<span class="keyword">name</span>) + <span class="string">'@cs'</span></span><br><span class="line"></span><br><span class="line">// mySQL</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line">    <span class="keyword">WHERE</span> login = <span class="keyword">CONCAT</span>(<span class="keyword">LOWER</span>(<span class="keyword">name</span>), <span class="string">'@cs'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="DATA-TIME-时间-日期操作"><a href="#DATA-TIME-时间-日期操作" class="headerlink" title="DATA/TIME 时间/日期操作"></a>DATA/TIME 时间/日期操作</h4><p>这一部分主要包括了SQL规定的一些关于操作和修改日期/时间的操作，可以作为输出或中间参数。同样，这些操作可能在不同DBMS上有不同的支持程度和具体语法，下面举一部分例子。</p>
<p>不同的DBMS有不同的方法获取获取当前日期，比如函数：<code>NOW()</code>、<code>CURRENT_TIMESTAMP()</code>，或者关键字<code>CURRENT_TIMESTAMP</code>;</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/time.png" class="" title="CMU-DB-2-Advanced-SQL">
<p>也可以可以通过 <code>EXTRACT</code> 或者 <code>&#39;-&#39;</code> 或者 <code>DATEDIFF</code> 等等各种方法来获取日期信息（同样根据不同DBMS有不同语法）</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/time_difference.png" class="" title="CMU-DB-2-Advanced-SQL">
<h3 id="Output-Control-Redirection"><a href="#Output-Control-Redirection" class="headerlink" title="Output Control + Redirection"></a>Output Control + Redirection</h3><h4 id="Output-redirection-输出重定向"><a href="#Output-redirection-输出重定向" class="headerlink" title="Output redirection 输出重定向"></a>Output redirection 输出重定向</h4><p>SQL 支持将输出保存到另一个表格里面，这个操作需要满足两个条件：</p>
<ul>
<li>输出表格不能已经被定义</li>
<li>输出表格需要和输入表格有相同类型并且列数相同</li>
</ul>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// SQL-02</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cid <span class="keyword">INTO</span> CourseIds</span><br><span class="line">    <span class="keyword">From</span> enrolled;</span><br><span class="line"></span><br><span class="line">// mySQL</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> CourseIDs (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cid <span class="keyword">FROM</span> enrolled</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>同时也支持通过 <code>INSECT</code> 关键字将 <code>SELECT</code> 输出的 tuple 插入到已经存在的表格里：</p>
<ul>
<li>内部的 <code>SELECT</code> 必须输出和目标表格相同列数的 tuple</li>
<li>不同 BDMS 对两者重复项有不同的处理选项和语法</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> CourseIds</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cid <span class="keyword">FROM</span> enrolled)</span><br></pre></td></tr></table></figure>
<h4 id="Output-Control"><a href="#Output-Control" class="headerlink" title="Output Control"></a>Output Control</h4><p>SQL 支持用 <code>ORDER</code> 关键字根据 tuple 中的一列或多列的值进行排序，语法是</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/SORT.png" class="" title="CMU-DB-2-Advanced-SQL">
<p>我们还可以用 <code>LIMIT</code> 来限制输出 tuples 的数量，并用 OFFSET 来规定一个输出范围</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// LIMIT &lt;count&gt; [OFFSET]</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line">    <span class="keyword">WHERE</span> login <span class="keyword">LIKE</span> <span class="string">'%@cs'</span></span><br><span class="line">    <span class="keyword">LIMIT</span> <span class="number">20</span> <span class="keyword">OFFSET</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="Nested-Queries-嵌套查找"><a href="#Nested-Queries-嵌套查找" class="headerlink" title="Nested Queries 嵌套查找"></a>Nested Queries 嵌套查找</h3><p>这里指的是查找指令中包括另一个查找指令，这种情况通常很难优化，但是会出现在各种地方，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 这里第一个出现的sid是关联在student上的，第二个是关联在enrolled上的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span></span><br><span class="line">    <span class="keyword">sid</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> enrolled)</span><br></pre></td></tr></table></figure>
<p>如果有多个查找命令时，可以用以下几种方式指定输出的结果</p>
<ul>
<li><code>ALL</code>：输出的 tuple 需要满足所有查找命令</li>
<li><code>ANY</code>：输出的 tuple 需要满足至少一个查找命令</li>
<li><code>IN</code>：和<code>ANY</code>等效</li>
<li><code>EXISTS</code>：至少返回一行</li>
</ul>
<p>例子</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 获得上这门课的学生的姓名</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">sid</span> = <span class="keyword">ANY</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> enrolled</span><br><span class="line">        <span class="keyword">WHERE</span> cid = <span class="string">'15-445'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">// ver2：查找命令也可以放在另一个查找命令的输出语句里</span><br><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> S.name <span class="keyword">FROM</span> student <span class="keyword">AS</span> S</span><br><span class="line">        <span class="keyword">WHERE</span> S.sid = E.SID) <span class="keyword">AS</span> sname</span><br><span class="line"><span class="keyword">FROM</span> enrolled <span class="keyword">AS</span> E</span><br><span class="line"><span class="keyword">WHERE</span> cid = <span class="string">'15-445'</span></span><br></pre></td></tr></table></figure>
<p>如果想要获得一个比较复杂的结果，比如找到一个学生，他至少注册了一门课，并且在这里面id是最高的，我们可能想到用以下方法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 不合标准！s.name 需要出现在HAVING里，否则结果未定义</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(e.sid), s.name</span><br><span class="line">    <span class="keyword">FROM</span> enrolled <span class="keyword">AS</span> e, student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> e.sid = s.sid</span><br></pre></td></tr></table></figure>
<p>这个时候我们可以用到<code>ALL</code>关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// sid 需要满足两个<span class="keyword">SELECT</span>里面所有的表达式</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span> =&gt; <span class="keyword">ALL</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> enrolled</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// ver2: 也可以用<span class="keyword">IN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">sid</span>) <span class="keyword">FROM</span> enrolled</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// ver3: 通过排序+规定范围输出</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> enrolled</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">sid</span> <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>假设我们需要找到所有没人注册的课程，可以用<code>NOT EXIST</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 内部的参数也可以用到外部查找命令的表格</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> course</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> enrolled</span><br><span class="line">    <span class="keyword">WHERE</span> course.cid = enrolled.cid</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Window-Functions-窗口函数"><a href="#Window-Functions-窗口函数" class="headerlink" title="Window Functions 窗口函数"></a>Window Functions 窗口函数</h3><p>窗口函数指的是对一系列 tuples 关于单行进行计算，和聚合函数类似，但是最后tuple不会集中在一个tuple上，语法是</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// FUNC-NAME 可以是聚合函数或者别的特殊函数</span><br><span class="line">// OVER 内部可以定义怎么切分数据或者对数据排序</span><br><span class="line"><span class="keyword">SELECT</span> ... FUNC-<span class="keyword">NAME</span>(...) <span class="keyword">OVER</span> (...)</span><br><span class="line">    <span class="keyword">FROM</span> tableNAME</span><br></pre></td></tr></table></figure>
<p>上述的聚合函数可以包括之前提到的所有函数，特殊函数则是指：</p>
<ul>
<li><code>ROW_NUMBER()</code>  当前行的行号</li>
<li><code>RANK()</code> 当前行的排序位置</li>
</ul>
<p><code>OVER()</code>的内部可以用<code>PARTITION BY</code>来指定特定的组，如：</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/over_partition.png" class="" title="CMU-DB-2-Advanced-SQL">
<p>假如我们想找到每门课上拿最高分的学生，可以：</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/rank.png" class="" title="CMU-DB-2-Advanced-SQL">
<h3 id="Common-Table-Expressions-常见的表格表达式"><a href="#Common-Table-Expressions-常见的表格表达式" class="headerlink" title="Common Table Expressions 常见的表格表达式"></a>Common Table Expressions 常见的表格表达式</h3><p>除了用嵌套查找以外还能用一些常见表达式来进行查找，可以看成一个临时的表格，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">with</span> 产生了一个tuple里面只有一个值<span class="number">1</span></span><br><span class="line"><span class="keyword">WITH</span> cteName <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> cteName</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WITH</span> cteName (col1, col2) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> col1 + col2 <span class="keyword">FROM</span> cteName</span><br><span class="line"></span><br><span class="line">// 之前提到的例子，找到一个学生，他至少注册了一门课，并且在这里面<span class="keyword">id</span>是最高的</span><br><span class="line"><span class="keyword">WITH</span> cteSource (maxId) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">sid</span>) <span class="keyword">FROM</span> enrolled</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student, cteSource</span><br><span class="line"><span class="keyword">WHERE</span> student.sid = cteSource.maxId</span><br><span class="line"></span><br><span class="line">// recursion，打印<span class="number">1</span>到<span class="number">10</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cteSource (counter) <span class="keyword">AS</span> (</span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    (<span class="keyword">SELECT</span> counter + <span class="number">1</span> <span class="keyword">FROM</span> cteSource</span><br><span class="line">    <span class="keyword">WHERE</span> counter &lt; <span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> cteSource</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>[CMU-15-445/645] - 介绍</title>
    <url>/2020/04/20/CMU-DB-1/</url>
    <content><![CDATA[<p>今天开始学习<a href="https://15445.courses.cs.cmu.edu/fall2019/" target="_blank" rel="noopener">Databases Systems CMU 15-445/645/ Fall 2019</a>，课程比较硬核，重点主要集中在怎么样设计一个数据库系统，希望能坚持学完。第一课主要是课程介绍以及介绍一些关于数据库管理系统的基础概念，包括关系模型，以及关于retional algebra 关系代数的一些基本操作。</p>
<a id="more"></a>
<h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><ol>
<li><p>课程主要集中在以下几个方面：</p>
<ul>
<li>Relational Databases</li>
<li>Storage</li>
<li>Execution</li>
<li>Concurrency Control</li>
<li>Recovery</li>
<li>Distributed Databases</li>
<li>Potpourri (集合)</li>
</ul>
</li>
<li><p>教材</p>
<p> 主要参考 <a href="https://www.db-book.com/db7/index.html" target="_blank" rel="noopener">Database System Concepts (第七版)</a> 以及课程笔记。</p>
</li>
<li><p>Project</p>
<p> 本课将会从零开始实现一个存储管理器，用的语言是C++17。项目将基于一个教学用数据库管理系统<a href="https://github.com/cmu-db/bustub" target="_blank" rel="noopener">BusTub</a>，该系统的大致架构为：</p>
<ul>
<li>Disk-Oriented Storage</li>
<li>Volcano-style Query Processing</li>
<li>Pluggable APIs</li>
<li><em>Currently does not support SQL</em></li>
</ul>
</li>
</ol>
<h2 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设我们现在需要一个音乐商店（类似iTunes）来管理所有的歌手和专辑，那么我们需要存储的信息包括：<strong>歌手信息</strong>和<strong>歌手发布的专辑信息</strong>。最简单的思路是将数据库以CSV文件的方式来存储，具体实现方式可以是这样：</p>
<ul>
<li>用一个单独的文件来存储每个我们需要的信息（在这个例子里面就是歌手信息和专辑信息）</li>
<li><p>每次应用想读取信息可以通过解析这些文件来获取</p>
  <img src="/2020/04/20/CMU-DB-1/%E9%9F%B3%E4%B9%90%E5%95%86%E5%BA%97%E4%BE%8B%E5%AD%90.png" class="" title="CMU-DB-1">
</li>
</ul>
<p>当我们想找Ice Cube的信息的时候，我们可以通过下面的Python来实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">    record = parse(line)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">"Ice Cube"</span> == record[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">print</span> int(record[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>但是这种简单的实现方式会遇到很多问题：</p>
<ul>
<li>怎么保证在每个专辑项的时候都保证歌手名字格式是一致的？</li>
<li>假如某个人不小心在输入年份的时候输入了一个不合法的string导致没办法转成整数怎么办？</li>
<li>当一个专辑有多个创作者是怎么办？</li>
</ul>
<p>除此之外还有很多实现上的细节需要注意：</p>
<ul>
<li>怎么找到一条特定记录？通过上面的for-loop方法在数据量很大的时候效率会变得很低</li>
<li>怎么保证这样的数据库系统可以兼容多平台（手机、平板、电脑）或者多种编程语言？</li>
<li>当两个线程想同时向一个文件写入时怎么保证不会互相覆盖？</li>
</ul>
<p>另外还考虑数据库的安全问题：</p>
<ul>
<li>当程序在往数据库写入记录的时候数据库突然崩溃了怎么办？</li>
<li>如果我们向复制数据库在多台机器以保证高可用性的时候需要注意什么？</li>
</ul>
<p>基于上面提到的问题，我们需要实现一个通用的数据库管理系统(Database Management System)来对数据库进行信息的<strong>存储</strong>和<strong>分析</strong>，这个系统需要能做到允许用户<em>自定义</em>，<em>创建</em>，<em>写入查找</em>，<em>更新</em>，<em>管理</em>一个数据库</p>
<h3 id="数据库系统模型介绍"><a href="#数据库系统模型介绍" class="headerlink" title="数据库系统模型介绍"></a>数据库系统模型介绍</h3><ol>
<li><p>Relational Model (关系模型)</p>
<p> 早期的数据库系统很难构建和维护，用户在构建系统之前需要清楚知道以后他会怎么使用，软件使用和硬件实现方式耦合度很高，直到1970 年 Ted Codd 提出了一个数据库的抽象概念来避免这种情况，这个模型主要包括以下三个要点：</p>
<ul>
<li>将数据库以关系 (relation) 的方式存在一个简单的数据结构里面</li>
<li>数据将会通过高级语言来进行访问</li>
<li>物理存储方式留给第三方具体实现（抽象本身不包括实现方式，用户不需要自己实现）</li>
</ul>
</li>
<li><p>Data models &amp; Schema</p>
<p> 这里提出了两个概念：</p>
<ul>
<li>data model：有关怎么描述数据在数据库里面里面的一系列描述方式</li>
<li><p>schema：针对一种特定数据模型给出的对该类型数据的描述方式（这一部分其实不太清楚，看看后续有没有具体的例子）</p>
<p>总的来说，数据模型抽象的概括了我们怎么样存储数据，schema则是说明了具体存了哪些内容</p>
</li>
</ul>
</li>
<li><p>一些常见的data model</p>
<ul>
<li>Relational：绝大部分的DBMS都是用这个模型，这门课也是学习这种模型</li>
<li>Key/Value：这个包括下面直到Column-family都是属于NoSql的模型</li>
<li>Graph</li>
<li>Document</li>
<li>Column-family</li>
<li>Array/Matrix：机器学习里面常用这种模型</li>
<li>Hierarchical：最后两种比较少见</li>
<li>Network</li>
</ul>
</li>
<li><p>Relational Model</p>
<p> Relational Model主要包括以下三个要素：</p>
<ul>
<li>Structure(结构)：有关关系和他们的具体内容的定义（描述）</li>
<li>Integrity（完整性）：保证数据库的内容符合相关约束条件（给定一个数据库怎么判断他是不是符合标准）</li>
<li>Manipulation（操作）：怎么访问和更改数据库的内容</li>
</ul>
</li>
</ol>
<h4 id="音乐商店例子：数据库描述"><a href="#音乐商店例子：数据库描述" class="headerlink" title="音乐商店例子：数据库描述"></a>音乐商店例子：数据库描述</h4><p>根据这三个要素，再回头看最初提到的音乐商店的例子：</p>
<img src="/2020/04/20/CMU-DB-1/%E4%BE%8B%E5%AD%90.png" class="" title="CMU-DB-1">
<p>在这个例子里面，<strong>relation(关系)</strong>指的就是所有描述一个记录的无序集合 (unordered set)，这里每一行表示了一个艺术家的记录，包括了姓名，年份和国家；其中一个特定的记录（record）被称为<strong>tuple（元组）</strong>，它包括了该记录所有的参数（value），一般来说每个参数都是不能再细分的（数、字符串等等，不能是数据，向量），null参数是任何tuple的成员之一。在这个例子里我们可以说<em>n-ary Relation = Table with n columns</em>，一个n维的relation可以用一个n列的表格来表示。</p>
<p>在一个relation中我们可以用<strong>primary key（主键）</strong>来特定的标识出某个tuple，某一些DBMS会在你没有定义定义primary key的时候自动创建一个内部primary key，例如SQL:2003会产生一个序列、MySQL会自动递增一个序号，这时表格可能会下图这样子的，需要注意的是，这个id不代表记录的任何属性，只是我们用来标识出他的一个记号，这个记号也有可能不会显式地显示出来</p>
<img src="/2020/04/20/CMU-DB-1/%E5%B8%A6%E4%B8%BB%E9%94%AE%E7%9A%84%E4%BE%8B%E5%AD%90.png" class="" title="CMU-DB-1">
<p>除此之外，我们还需要有个机制来联系两个relation，所以还引入了一个<strong>foreign key（外键）</strong>，这个键主要用来在一个tuple里面通过他来联系到另一个relation里面的另一个tuple，在这个例子指的就是艺术家和专辑之间的联系，如下图：</p>
<img src="/2020/04/20/CMU-DB-1/%E5%A4%96%E9%94%AE%E4%BE%8B%E5%AD%901.png" class="" title="CMU-DB-1">
<p>但是这里可以发现一个问题，但专辑不止有一个艺术家的时候怎么办？前面提到了每一个value必须是不可再分的，所以不能用一个数组来保存，这个时候我们可以用第三个relation来描述这两个relation之间的联系，这个relation里面每一个tuple只需要包含两个value：艺术家的id和专辑的id，如下图所示：</p>
<img src="/2020/04/20/CMU-DB-1/%E5%A4%96%E9%94%AE%E4%BE%8B%E5%AD%902.png" class="" title="CMU-DB-1">
<h4 id="音乐商店例子：数据库操作"><a href="#音乐商店例子：数据库操作" class="headerlink" title="音乐商店例子：数据库操作"></a>音乐商店例子：数据库操作</h4><p>在确认了怎么表示一个数据库之后我们需要来操作它，这里我们主要关心把一个信息存进数据库和把它提取出来，这里主要两种方式：</p>
<ul>
<li>Procedural：每次查询制定好一个策略（不是具体的实现）用来给DBMS来执行查找</li>
<li>Non-Procedural：查询操作不指定具体查找方法</li>
</ul>
<p>这两种方式的具体应用分别是<strong>Relational Algebra（关系代数）</strong>和<strong>Relational Calculus（关系演算）</strong>，这门课里面我们主要关注第一种查找方式。</p>
<p>Relational Algebra里面基于集合（没有重复元素）的运算法则规定了七种基本运算来获取和操作一个relation里面的tuple，其中每一个操作的输入是一个或多个relation，输出是一个新的reltaion：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\sigma$</td>
<td style="text-align:center">Select</td>
</tr>
<tr>
<td style="text-align:center">$\pi$</td>
<td style="text-align:center">Projection</td>
</tr>
<tr>
<td style="text-align:center">$\cup$</td>
<td style="text-align:center">Union</td>
</tr>
<tr>
<td style="text-align:center">$\cap$</td>
<td style="text-align:center">Intersection</td>
</tr>
<tr>
<td style="text-align:center">$-$</td>
<td style="text-align:center">Difference</td>
</tr>
<tr>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">Product</td>
</tr>
<tr>
<td style="text-align:center">$\Join$</td>
<td style="text-align:center">Join</td>
</tr>
</tbody>
</table>
</div>
<p>下面对每一个操作进行介绍：</p>
<h5 id="Select（选择）"><a href="#Select（选择）" class="headerlink" title="Select（选择）"></a>Select（选择）</h5><p>选择操作是从一个relation里面选出一个tuple的子集满足给定的选择条件，作用和一个filter类似，具体语法是$\sigma_{predicate}(R)$，可以看看下面的例子,对同一个relation用不同的条件可以输出不同的结果（也是一个relation），这个操作对应SQL里面WHERE语句：</p>
<img src="/2020/04/20/CMU-DB-1/select.png" class="" title="CMU-DB-1">
<h5 id="Projection（投影）"><a href="#Projection（投影）" class="headerlink" title="Projection（投影）"></a>Projection（投影）</h5><p>给定一个relation，投影操作可以输出一个只包括tuple里面的特定参数(attributes)新的relation，通过这个操作可以重新安排参数的顺序，也可以对所有tuple的某个参数进行统一的修改，效果和对应的SQL语句如下图所示，具体的语法是$\pi_{A1,A2,…,An}(R)$:</p>
<img src="/2020/04/20/CMU-DB-1/projection.png" class="" title="CMU-DB-1">
<h5 id="Union（并集）"><a href="#Union（并集）" class="headerlink" title="Union（并集）"></a>Union（并集）</h5><p>联合操作比较简单，就是把两个relation合成一个新的relation，语法是$R\cup S$，效果如下所示，值得注意的是这个操作的两个输入relation需要有完全一样顺序的参数，否则不会匹配（另外这个例子里面好像不会去重？？）</p>
<img src="/2020/04/20/CMU-DB-1/union.png" class="" title="CMU-DB-1">
<h5 id="Intersection（交集）"><a href="#Intersection（交集）" class="headerlink" title="Intersection（交集）"></a>Intersection（交集）</h5><p>对两个relation取共同部分，同样需要两个relation有完全一样的参数和顺序，语法是$R\cap S$：</p>
<img src="/2020/04/20/CMU-DB-1/Intersection.png" class="" title="CMU-DB-1">
<h5 id="Difference（差集）"><a href="#Difference（差集）" class="headerlink" title="Difference（差集）"></a>Difference（差集）</h5><p>差集的输入是两个relation，输出所有在第一个relation出现过但没有在第二个relation出现的tuple组成的relation，语法是$R-S$</p>
<img src="/2020/04/20/CMU-DB-1/difference.png" class="" title="CMU-DB-1">
<h5 id="Product-叉乘"><a href="#Product-叉乘" class="headerlink" title="Product (叉乘)"></a>Product (叉乘)</h5><p>叉乘取两个relation作为输入，输出两个relation中各自所有tuple的排列组合产生的tuple并组成新的relation，语法是$R\times S$，类似SQL的cross join，效果如下</p>
<img src="/2020/04/20/CMU-DB-1/product.png" class="" title="CMU-DB-1">
<h5 id="Join-（联合）"><a href="#Join-（联合）" class="headerlink" title="Join （联合）"></a>Join （联合）</h5><p>Join取两个relation并输出一个新的relation，其中的tuple是这两个relation都包含的一部分（可能有共同的一个或多个参数），语法是$R\Join S$，类似SQL的NATURAL JOIN</p>
<img src="/2020/04/20/CMU-DB-1/join.png" class="" title="CMU-DB-1">
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>除了七种基本操作以外，relational algebra还有一些额外的操作，例如：Rename - $\rho$, Assignment - $R\leftarrow S$, Duplicate Elimination - $\delta$, Aggregation $\gamma$, sorting - $\tau$, Division - $R \div S$</p>
<p>相对于最初提到具体的某个具体的实现（for-loop），用relational algebra来实现某个查找相对来说虽然抽象程度更高，但是同一个查找可能不同的algebra实现方式可能效率不同，比如$\sigma_{b_{id}=102(R\Join S)} vs. (R\Join(\sigma_{b_{id}=102}(S)))$。对用户而言他在执行某个查找的时候只需要提出这样一个要求，来避免具体的实现细节（针对不同的数据库可能不同的执行顺序效率不同）：</p>
<ul>
<li>Retrieve the joined tuples from R and S where b_id equals 102.</li>
</ul>
<p>值得注意的是，虽然现在SQL已经是事实上的标准，relational model独立于任何一种特定的查询语言，用这种模型的好处是不需要去了解特定的实现细节（比如要不要用for循环去查找等等），而其中关系代数定义了关系数据库里面最基本的操作。</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]分布式系统-distributed system</title>
    <url>/2020/04/19/distributed-system/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了分布式系统中最基础的一些概念的方法。</p>
<a id="more"></a>
<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ol>
<li><p>What is a distributed system?</p>
<p> <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/distributed_system.png" width="300"></p>
<ul>
<li>Cooperating processes in a computer network</li>
<li><p>Degree of integration</p>
<ul>
<li>Loose: Internet applications, email, web browsing</li>
<li>Medium: remote execution, remote file systems</li>
<li>Tight: process migration, distributed file systems</li>
</ul>
</li>
<li><p>Advantage</p>
<ul>
<li>Speed: parallelism, less contention</li>
<li>Reliability: redundancy, fault tolerance, “NSPF”</li>
<li>Scalability: incremental growth, economy of scale</li>
<li>Geographic distribution: low latency, reliability</li>
</ul>
</li>
<li><p>Disadvantages</p>
<ul>
<li><p><em>Fundamental problems</em> of decentralized control</p>
<ul>
<li>State uncertainty: no shared memory or clock</li>
<li>Action uncertainty: matually conflicting decisions</li>
</ul>
</li>
<li><p>Distributed algorithms are complex</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Is distribution better? <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/distributed_system2.png" width="180" style="float: right;"></p>
<ul>
<li>Single fast server with single queue</li>
<li><p>Multiple slower servers with separate queues</p>
<ul>
<li>Typically better than the first one</li>
</ul>
</li>
<li><p>Multiple slower servers, single queue</p>
<ul>
<li>Better than the first two</li>
</ul>
</li>
<li><p>Little’s Law: $N = \lambda W$</p>
<ul>
<li>Use to calculate processing time (assuming stable)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Models-used-in-cooperating-system"><a href="#Models-used-in-cooperating-system" class="headerlink" title="Models used in cooperating system"></a>Models used in cooperating system</h2><ol>
<li><p>The Client/Server Model</p>
<ul>
<li><p>Client</p>
<ul>
<li>Short-lived process that makes requests</li>
<li>“User-side” of application</li>
</ul>
</li>
<li><p>Server</p>
<ul>
<li>Exports well-defined requests/response interface</li>
<li>Long-lived process that waits for requests</li>
<li>Upon receiving request, carries it out (may spawn)</li>
</ul>
</li>
</ul>
</li>
<li><p>Peer-to-Peer</p>
<ul>
<li><p>A peer talks directly with another peer</p>
<ul>
<li>No intermediary (e.g., central servel) involved</li>
<li>Symmetric (unlike asymmetric client/server)</li>
</ul>
</li>
<li><p><em>In actuality, may be dynamic client/server</em></p>
<ul>
<li>A requests file from B; A acts as client, B as server</li>
<li>C can now request file from A; A acts as server</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Distributed-Algorithms"><a href="#Distributed-Algorithms" class="headerlink" title="Distributed Algorithms"></a>Distributed Algorithms</h3><ol>
<li><p>Event ordering</p>
<ul>
<li>Order events given no shared clock/memory</li>
<li><p>Happened-before relations: $\rightarrow$</p>
<ul>
<li>A, B events in same process and A before B: $A\rightarrow B$</li>
<li>A is a send event, B is a receive event: $A\rightarrow B$</li>
<li>If $A\rightarrow B$ and $B\rightarrow C$, then $A\rightarrow C$</li>
</ul>
</li>
<li><p>Implementation</p>
<ul>
<li>Timestamp all events based on local clock</li>
<li>Upon receiving a message, advance local clock</li>
<li>Resolve ties by ordering machines</li>
</ul>
</li>
<li><p>Example</p>
<ul>
<li><p>Example 1 (When timing conflicting, follow rules above):</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/event_ordering_example3.png" width="300"></p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/event_ordering_example1.png" width="300"></p>
</li>
<li><p>Example 2:</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/event_ordering_example4.png" width="300"></p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/event_ordering_example5.png" width="300"></p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/event_ordering_example2.png" width="300"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Leader election</p>
<ul>
<li>Many distributed algorithms rely on leader</li>
<li>Need to determine if leader exists; if not elect</li>
<li><p>Bully algorithm (elect leader L)</p>
<ul>
<li>Every process is numbered (priority): P1, P2, …</li>
<li>$P_j$ sends request to L, no reply; tries to elect itself</li>
<li>$P_j$ sends “Can I be leader?” to all $P_{k&gt;j}$</li>
<li>No replies, $P_j$ sends to all $P_{i&lt;j}$, “I am leader”, done</li>
<li>If some $P_{k&gt;j}$ replies, $P_j$ let $P_k$ try to elect itself</li>
<li>If no message from $P_k$, $P_j$ tries to elect itself again</li>
</ul>
</li>
</ul>
</li>
<li><p>Mutual exclusion</p>
<ul>
<li><p>Centralized approach</p>
<ul>
<li>Single process acts as coordinator server</li>
<li>Request, reply (to allow entrance), release</li>
</ul>
</li>
<li><p>Distributed approach</p>
<ul>
<li>Process sends time-stamped request to all others</li>
<li>Waits until it receives replies from all (ok to other)</li>
<li>Enter critical section (may get requests, defers)</li>
<li>Upon exiting, responds (to release) to all deferred</li>
<li>Use timestamps to order “simultaneous” requests</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]网络-networks</title>
    <url>/2020/04/19/networks/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了网络的概念，包括网络的类型和协议的概念。并且简单介绍了一下OSI7层模型，包括addressing和routing的过程。</p>
<a id="more"></a>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><ol>
<li><p>What is a Network?</p>
<ul>
<li><p>Network</p>
<ul>
<li>Set of computing nodes</li>
<li>Connected by communication links</li>
<li>Allow data transfer by a sender to a receiver</li>
</ul>
</li>
<li><p>Internetwork: a network of networks</p>
<ul>
<li>The “Internet” is a global internetwork</li>
<li>Nodes communicate using IP (Internet Protocol)</li>
</ul>
</li>
</ul>
</li>
<li><p>Types of Networks</p>
<ul>
<li><p>By topology: ring, star, bus, graph</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/type_of_network.png" width="280"></p>
</li>
<li><p>By geographic coverage</p>
<ul>
<li>LAN: local area network (spanning floor, building)</li>
<li>WAN: wide area network (spanning state, country)</li>
</ul>
</li>
</ul>
</li>
<li><p>Circuit-switch vs. Packet switching</p>
<ul>
<li><p>Circuit switching: establish path, send data</p>
<ul>
<li>Reserve resources provide performance control</li>
<li><p>Example: telephone system</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/circuit_switching.png" width="280"></p>
</li>
</ul>
</li>
<li><p>Packet switching: forward packets hop to hop</p>
<ul>
<li>Fair sharing despite burst, statistical multiplexing</li>
<li><p>Example: postal system</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/packet_switching.png" width="280"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><ol>
<li><p>What is protocol?</p>
<ul>
<li>Goal: get message from sender to receiver</li>
<li><p>Protocol</p>
<ul>
<li>agreed message format and transfer procedure</li>
</ul>
</li>
<li><p>Multiparty, so no central thread of control</p>
<ul>
<li>Sender and reciver are separate processes</li>
</ul>
</li>
<li><p>Expectations of operation</p>
<ul>
<li>first you do x, then I do y, then you do z,…</li>
<li>If you do q, I’ll do p</li>
</ul>
</li>
</ul>
</li>
<li><p>Message</p>
<ul>
<li><p>Message: contains header and data</p>
<ul>
<li>Similar terms: packet, datagram, frame</li>
</ul>
</li>
<li><p>Data: what sender wants to receiver to know</p>
</li>
<li><p>Header: information to support protocol</p>
<ul>
<li>Source and destination addresses</li>
<li>State of protocol operation</li>
<li>Error control (to check intergity of received data)</li>
</ul>
</li>
<li><p>Example:</p>
<ul>
<li><p>Assume: Ann sends message to Bob locally (same city)</p>
<ul>
<li>Message format: (from, to), message contents</li>
<li><p>Transfer procedure: post on refrigerator</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/message1.png" width="280"></p>
</li>
</ul>
</li>
<li><p>What if Ann sends message to Bob in different cities</p>
<ul>
<li>Message format: address(es) on envelope, letter</li>
<li><p>Transfer procedure: postal system</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/message2.png" width="280"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Summary (<em>Layering: Separation of Functions</em>)</p>
<ul>
<li><p>Ann and Bob</p>
<ul>
<li>Don’t have to know about delivery</li>
<li>However, aid postal system by providing addresses</li>
</ul>
</li>
<li><p>Postal System</p>
<ul>
<li>Only has to know addresses and how to deliver</li>
<li>Doesn’t care about “data”: Ann, Bob, letter</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="7-Layers-of-OSI-Open-Systems-Interconnection-Refernce-Model"><a href="#7-Layers-of-OSI-Open-Systems-Interconnection-Refernce-Model" class="headerlink" title="7 Layers of OSI (Open Systems Interconnection) Refernce Model"></a>7 Layers of OSI (Open Systems Interconnection) Refernce Model</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">layer</th>
<th style="text-align:left">name</th>
<th style="text-align:left">function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">Application</td>
<td style="text-align:left">application protocol, e.g., HTTP</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">Presentation</td>
<td style="text-align:left">syntax, network format</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">Session</td>
<td style="text-align:left">start/stop/manage connections</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">Transport</td>
<td style="text-align:left">segment, reliability, flow control</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">Network</td>
<td style="text-align:left">logical addressing, routing</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">Link</td>
<td style="text-align:left">physical addressing, framing</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Physical</td>
<td style="text-align:left">0’s and 1’s over a wire</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>Internet Protocol Stack</p>
<ul>
<li>“Hourglass” design</li>
<li>Application: Email, Web</li>
<li>Session: sockets</li>
<li>Transport: TCP, UDP, …</li>
<li>Network: IP (Only one kind of protocol in this layer, which makes Internet Internet!)</li>
<li>Link: Ethernet, ATM, …</li>
<li>Physical</li>
</ul>
</li>
<li><p>Encapsulation</p>
<ul>
<li>Higher level n with lower level n - 1</li>
<li>Can also have level within a level: tunneling</li>
<li>Multiplexing and de-multiplexing</li>
</ul>
</li>
<li><p>Addresses</p>
<ul>
<li><p>Generally, three levels of addresses</p>
<ul>
<li>Domain names: cs.ucsd.edu</li>
<li>Logical addresses (IP): 128.53.27.92</li>
<li>Physical addresses (Ethernet): 0x27A5BB17019D</li>
</ul>
</li>
<li><p>Address resolution</p>
<ul>
<li>Mapping higher level name to lower level name</li>
<li>Techniques: table lookup, formula, protocol</li>
</ul>
</li>
<li><p>Sizes of address spaces</p>
<ul>
<li><p>IPv4 (version 4, current/past)</p>
<ul>
<li>32 bit addresses</li>
<li>$2^{32}$ = 4 billion addresses</li>
</ul>
</li>
<li><p>IPv6 (version 6, future/current)</p>
<ul>
<li>128 bit addresses</li>
<li>$2^{128} = 2^8\times (2^{10})^{12} = 256 \times (10^3)^{12} = 2.56 \times 10^{38}$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Routing</p>
<ul>
<li><p>Routing: how to get packet from A to B</p>
<ul>
<li><p>A forwards to X; X to Y; Y to Z; Z to B</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/routing_example.png" width="300"></p>
</li>
</ul>
</li>
<li><p>Each intermediate node can be a decision point</p>
<ul>
<li>Static: always make the same decision</li>
<li>Dynamic: decision can change (e.g., based on state)</li>
</ul>
</li>
</ul>
</li>
<li><p>Scalability</p>
<ul>
<li><p>How well does system grow</p>
<ul>
<li>in terms of performance, reliability, etc</li>
</ul>
</li>
<li><p>Ramifications of adding node or link</p>
<ul>
<li>Local effects vs. global effects</li>
</ul>
</li>
<li><p>Information growth: import to reduce</p>
<ul>
<li>Amount stored at nodes</li>
<li>Amount exchanged between nodes</li>
</ul>
</li>
</ul>
</li>
<li><p>Error Control</p>
<ul>
<li>Parity: even, odd, two-dimesional</li>
<li>CRC (cyclic redundance code)</li>
<li>Checksum</li>
<li>Automatic repeat request (ARQ)</li>
</ul>
</li>
<li><p><a href="https://www.wikiwand.com/en/Two_Generals%27_Problem" target="_blank" rel="noopener">The two general’s problem</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]安全机制-security</title>
    <url>/2020/04/19/security/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面的不同环境以及系统之间的威胁，包括病毒等，除此之外还介绍了一些安全机制，包括公钥和私钥的方法。</p>
<a id="more"></a>
<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ol>
<li><p>What is Computer Security?</p>
<ul>
<li><p>How to protect computer systems</p>
<ul>
<li>System contents: data, software, hardware</li>
<li>System operation: performance, reliability</li>
<li>System service: what the user sees and expects</li>
</ul>
</li>
<li><p>From various threats</p>
<ul>
<li>Theft</li>
<li>Damage</li>
<li>Disruption</li>
</ul>
</li>
</ul>
</li>
<li><p>Aspects of Security</p>
<ul>
<li><p>Confidentiality</p>
<ul>
<li>keeping a secret secret; for authorized eyes only</li>
</ul>
</li>
<li><p>Integrity</p>
<ul>
<li>maintaining accuracy; only authorized changes</li>
</ul>
</li>
<li><p>Authenticity</p>
<ul>
<li>Is it really who/what it claims to be?</li>
</ul>
</li>
<li><p>Availablity</p>
<ul>
<li>access to info/resources you need, when needed</li>
</ul>
</li>
</ul>
</li>
<li><p>Security Threats</p>
<ul>
<li><p>Interception</p>
<ul>
<li>eavesdropping</li>
</ul>
</li>
<li><p>Interruption</p>
<ul>
<li>destroying, denial of service</li>
</ul>
</li>
<li><p>Modification</p>
<ul>
<li>tampering with data or programs</li>
</ul>
</li>
<li><p>Fabrication</p>
<ul>
<li>new data/programs, replaying message</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="User-Authentication"><a href="#User-Authentication" class="headerlink" title="User Authentication"></a>User Authentication</h2><ol>
<li><p>Password</p>
<ul>
<li><p>Passwords are most common method</p>
<ul>
<li>User and computer know secret</li>
<li>User proves knowledge of secret</li>
<li>Computer checks</li>
</ul>
</li>
<li><p>Encrypted passwords</p>
<ul>
<li>Computer stores only encrypted passwords</li>
<li>User provides password</li>
<li>Computer encrypts, checks</li>
</ul>
</li>
<li><p>Problem with passwords</p>
<ul>
<li><p>Assume 100 possible characters for passwords</p>
<p>  | # chars| # passwords | 100G/s machine | 100T/s machine |<br>  | :—-: | :—-: | :—-: | :—-: |<br>  | 6 | $100^6$ | 10 sec | 10 msec |<br>  | 7 | $100^7$ | 17 min | 10 msec |<br>  | 8 | $100^8$ | 1.2 days | 1.7min |<br>  | 9 | $100^9$ | 116 days | 2.8 hr|</p>
</li>
<li><p>But most characters are uncommon, hard to remember</p>
</li>
<li>Using dictionary words (~250,000): only 2.5 usec!</li>
</ul>
</li>
</ul>
</li>
<li><p>Challenge/Response Protocol</p>
<ul>
<li><p>Challenge/response, algorithm passwords</p>
<ul>
<li>User and system know secret algorithm</li>
<li>System challenge user’s knowledge, user responds</li>
</ul>
</li>
<li><p>Example: say secret algorithm is $f(x) = x^2$</p>
<ul>
<li>System challenges user: sends system 9</li>
<li>User computes $f(x) = 9$, sends system 9</li>
<li>System concludes user must know secret algorithm</li>
<li>Next time, system can provide different challenge</li>
</ul>
</li>
<li><p>Secret is never sent, only challenge/response</p>
</li>
</ul>
</li>
</ol>
<h2 id="Threats"><a href="#Threats" class="headerlink" title="Threats"></a>Threats</h2><ol>
<li><p>Trojan Horse</p>
<ul>
<li>Greeks invaded Troy in hollow wooden horse</li>
<li><p>Program that contains hidden malicious code</p>
<ul>
<li>User thinks program does something useful</li>
<li>In actuality, it (also) does something harmful</li>
</ul>
</li>
<li><p>Program runs as process in user’s domain</p>
<ul>
<li>Can do harm to user’s environment</li>
<li>Can do harm under that user’s name</li>
</ul>
</li>
</ul>
</li>
<li><p>Trap Door</p>
<ul>
<li>Secret access point in program</li>
<li>Designer develops program for someone else</li>
<li>Once loaded in system, designer can access</li>
<li><p>Consider if trap door is added by compiler</p>
<ul>
<li>Compiler adds trap doors to programs</li>
<li>Designer of compiler can then access</li>
<li>Can’t tell from program source code</li>
<li>Even if new compiler written, must be compiled!</li>
</ul>
</li>
</ul>
</li>
<li><p>Virus</p>
<ul>
<li>Code attached to legitimate program</li>
<li><p>When program runs, the virus runs</p>
<ul>
<li>causes damage</li>
<li>spreads, attaching itself to other programs</li>
</ul>
</li>
<li><p>Disinfectants</p>
<ul>
<li>Check that programs look normal (modified)</li>
<li>Check for known virus patterns in programs</li>
</ul>
</li>
</ul>
</li>
<li><p>Internet Worm</p>
<ul>
<li>Worm: program that copies itself over network by email, finger, rsh attack</li>
</ul>
</li>
<li><p>Denial of Service</p>
<ul>
<li><p>Preventing others from using system</p>
<ul>
<li>by using lots of resources</li>
<li>by bombarding with network requests or traffic</li>
</ul>
</li>
<li><p>Example</p>
<ul>
<li>Repeatly request TCP connection</li>
<li>Don’t answer responses; system times them out</li>
<li>Eventually, no TCP ports left available</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Approach-to-clear-prevent-threats"><a href="#Approach-to-clear-prevent-threats" class="headerlink" title="Approach to clear (prevent) threats"></a>Approach to clear (prevent) threats</h2><h3 id="Intrusion-Detection"><a href="#Intrusion-Detection" class="headerlink" title="Intrusion Detection"></a>Intrusion Detection</h3><ol>
<li><p>Intrusion Detection</p>
<ul>
<li>Detecting if there is an intruder, or an attack</li>
<li><p>Signature-based</p>
<ul>
<li>Look for specific patterns of attack behavior</li>
<li>Example: repeated login attempts</li>
</ul>
</li>
<li><p>Anomaly-based</p>
<ul>
<li>Look for unusual behavior</li>
<li>Example: unusual command/system call patterns</li>
</ul>
</li>
<li><p>Solution: create audit trail (log), then analyze it</p>
</li>
</ul>
</li>
</ol>
<h3 id="Crytography"><a href="#Crytography" class="headerlink" title="Crytography"></a>Crytography</h3><ol>
<li><p>Basics</p>
<ul>
<li><p>Encoding messages to</p>
<ul>
<li>limit who can view the original message</li>
<li><p>determine who sent a message</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/crytography.png" width="350"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Secret Key Encryption</p>
<ul>
<li><p>Secret key (symmetric)</p>
<ul>
<li>Same key K is used to encrypt and decrypt</li>
<li>Sender encrypts $E_k(P)$, Receiver decrypts $D_k(E_k(P))$</li>
</ul>
</li>
<li><p>DES: Data Encryption Standard (1997)</p>
<ul>
<li>Weak due to 56-bit keys</li>
</ul>
</li>
<li><p>AES: Advanced Encryption Standard (2001)</p>
<ul>
<li>128, 192, 256-bit keys</li>
</ul>
</li>
</ul>
</li>
<li><p>Public Key Encryption</p>
<ul>
<li><p>Public key (asymetric)</p>
<ul>
<li>Different keys to encrpyt and decrypt</li>
<li>Each user has two keys: one public, one private</li>
</ul>
</li>
<li><p>If A wants to send to B</p>
<ul>
<li>A encrypts using B’s public key</li>
<li>B decrypts using its private key</li>
</ul>
</li>
<li><p>RSA (Rivest, Shamir and Adelman)</p>
</li>
</ul>
</li>
<li><p>Public key vs. Secret key</p>
<ul>
<li><p>Secret key</p>
<ul>
<li>Operates fast</li>
<li>Difficult to distribute keys</li>
</ul>
</li>
<li><p>Public key</p>
<ul>
<li>Time-consuming operation (generating random/prime number, see example below)</li>
<li>Conveninet for key distribution</li>
</ul>
</li>
<li><p>Example: Alice chats with Bob</p>
</li>
<li><p>Bob authenticates Alice</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/b2a.png" width="350"></p>
</li>
<li><p>Alice authenticates Bob</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/a2b.png" width="350"></p>
</li>
<li><p>Authentication using public key</p>
<ul>
<li>Alice: sends $K_{B,pub}(A, R_A)$ to Bob (uses Bob’s public key)</li>
<li><p>Bob:</p>
<ul>
<li>Decrypts: $K_{B,priv}(K_{B,pub}(A, R_A))\rightarrow (A, R_A)$</li>
<li>Encrypts and sends $K_{A,pub}(R_A, R_B, K)$ to Alice</li>
</ul>
</li>
<li><p>Alice:</p>
<ul>
<li>Decrypts: $K_{A,priv}(K_{A,pub}(R_A, R_B, K))\rightarrow$ “It’s Bob”</li>
<li>Encrypts and sends $K(R_B)$ to Bob</li>
</ul>
</li>
<li><p>Bob: Decrypts $K(K(R_B)) = R_B \rightarrow$ “it’s Alice”</p>
</li>
<li><p>whole process:</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/b2a2b.png" width="350"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Digitial Signatures</p>
<ul>
<li><p>If Alice wants to digitially sign message to Bob</p>
<ul>
<li><p>Encrypt M using $K_{A,priv}$ and send $K_{A,priv}(M)$ to Bob</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/digital_signature_1.png" width="350"></p>
</li>
</ul>
</li>
<li><p>When Bob receives, decrypts using $K_{A, pub}$</p>
<ul>
<li>can decrypt only if from Alice</li>
</ul>
</li>
<li><p>To sign and keep private</p>
<ul>
<li>Alice sends $K_{B,pub}(M, K_{A, pirv}(M))$ to Bob</li>
<li>Only Bob can decryptL $K_{B,priv}(K_{B,pub}(M, K_{A,priv}(M))$</li>
<li><p>Decrypts using $K_{A,pub}$ proving Alice signed it</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/digital_signature_2.png" width="350"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]保护-protection</title>
    <url>/2020/04/19/protection/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面对文件和进程资源的保护方法，包括用户权限和用户组管理。</p>
<a id="more"></a>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><ol>
<li><p>Introduction</p>
<ul>
<li>Process access resources</li>
<li><p>Resources are shared, need to be protected</p>
<ul>
<li>from process without permission</li>
<li>from improper access by a process</li>
</ul>
</li>
<li><p>What is the right protection model?</p>
</li>
<li>What are the mechanism?</li>
</ul>
</li>
<li><p>The kernel enforces protection</p>
<ul>
<li>To pretect resources, have kernel “own” them, then kernel can allow access temporairily</li>
<li>To access a resource, a process must ask for it, then kernel can test whether access should be given</li>
<li><p>One a process is given access</p>
<ul>
<li>kernel can prevent others for gaining access</li>
<li>kernel may/may not be able to take away access</li>
</ul>
</li>
<li><p>This assumes kernel operates correctly</p>
</li>
</ul>
</li>
<li><p>Protecting the kernel</p>
<ul>
<li>The kernel itself must be protected</li>
<li><p>Mechanism</p>
<ul>
<li>Memory protecion</li>
<li>Protected mode of operation: kernel vs. user</li>
<li>Clock interrupt, so kernel eventually gets control</li>
</ul>
</li>
<li><p>Notice, mechanisms are hardware supported</p>
</li>
<li>Protected kernel can protect other resources</li>
</ul>
</li>
<li><p>Goals supported by kernel</p>
<ul>
<li>Allow range of permissions</li>
<li>Allow user to set/get them</li>
<li>Be fast/simple for common use</li>
<li>Support user expressing complex permissions</li>
</ul>
</li>
</ol>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><h3 id="Simple-model"><a href="#Simple-model" class="headerlink" title="Simple model"></a>Simple model</h3><ol>
<li><p>A formal model of protection</p>
<ul>
<li>Protection: how to limit access to a resource</li>
<li>Resource: object that requires protection</li>
<li>Domain: set of (resource, permission) pairs</li>
<li>Process: accesses resources within domain</li>
</ul>
</li>
<li><p>Protection Matrix</p>
<ul>
<li><p>Example: (X, Y: Resources A,B: Domains)</p>
<p>  |   |  X  |  Y  | A | B |<br>  |—-|—-  | —- |—-|—-|<br>  | A | r,w | r,w |   |   |<br>  | B | w   | r   |   |   |</p>
</li>
<li><p>Can describe all domains as a matrix</p>
<ul>
<li>Rows are domains</li>
<li>Columns are resources</li>
<li>Matrix entry [d, r] contains permissions/rights</li>
</ul>
</li>
<li><p>Access Control Lists (For resource)</p>
<ul>
<li>For each resource, list (domain, permissions) pairs</li>
<li>ACL is associated with resource</li>
<li>Like a registry: if name is on list, ok to access</li>
<li>Can be inefficient: must lookup on each access</li>
<li>Revocation is easy; just remove from list</li>
</ul>
</li>
<li><p>Capability Lists (For domain)</p>
<ul>
<li>For each domain, list (resource, permissions pairs)</li>
<li>Capability list associated with each domain</li>
<li>Like key/ticker: if you have it, you get access</li>
<li>Efficient: on access, just produce capability</li>
<li>Hard to revoke</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="UNIX-Protecion"><a href="#UNIX-Protecion" class="headerlink" title="UNIX Protecion"></a>UNIX Protecion</h3><ol>
<li><p>Basic</p>
<ul>
<li><p>Associated with each file is set of permissions</p>
<ul>
<li>Permission bits r/w/x for owner, group, world</li>
<li>Limited form of access control list</li>
</ul>
</li>
<li><p>Protection domain: UID (user account ID) + …</p>
<ul>
<li>A process is always in some domain</li>
</ul>
</li>
<li><p>When process opens file, check permission</p>
</li>
<li><p>If ok, provide process with a capability</p>
<ul>
<li>Future operations then carried out efficiently</li>
</ul>
</li>
</ul>
</li>
<li><p>More</p>
<ul>
<li>For common case, r/w/x for o/g/w adequate</li>
<li>For special cases, can extend via user program</li>
<li>SETUID mechanism: causes domain switch</li>
<li><p>If executable file has SETUID bit set</p>
<ul>
<li>Process runs in domain of owner (of executable)</li>
<li>Therefor, it runs with all the rights of the owner</li>
</ul>
</li>
</ul>
</li>
<li><p>Example</p>
<ul>
<li>Pat has a file “Bil” of bibliography references</li>
<li>Chris wants to read and add entries</li>
<li>But, Chris lacks permissions (only Pat can r/w)</li>
<li>Pat wisher to allow append access (only add entris to the back), but how?</li>
<li><p>Solution:</p>
<ul>
<li>Pat can provide program (e.g., EditBib): only reads/appends</li>
<li><p>Set permissions</p>
<ul>
<li>of program: execute (for Chris), and SETUID on</li>
<li>of Bib file: read/write only for Pat, not Chris</li>
</ul>
</li>
<li><p>When Chris executes EditBib, runs as Pat (since SETUID on, domain switch to Pat’s domain)</p>
</li>
<li>Program only does read/append.</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]输入/输出系统-I/O system</title>
    <url>/2020/04/19/IO-system/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面输入系统系统的概念，包括硬件上的组成以及软件的结构。</p>
<a id="more"></a>
<h2 id="I-O-basic"><a href="#I-O-basic" class="headerlink" title="I/O basic"></a>I/O basic</h2><ol>
<li><p>Intro</p>
<ul>
<li><p>I/O = Input/Output</p>
<ul>
<li>Input from attached device to CPU/memory</li>
<li>Output from CPU/memory to device</li>
</ul>
</li>
<li><p>Synchronization and transferring data</p>
</li>
</ul>
</li>
<li><p>Issues</p>
<ul>
<li><p>Problems:</p>
<ul>
<li>So many different types of I/O devices</li>
<li>Wide range: speed, operation, data transfer units</li>
</ul>
</li>
<li><p>Questions:</p>
<ul>
<li>How does a process initiate I/O?</li>
<li>How is synchronization achieved?</li>
<li>How is data transferred?</li>
</ul>
</li>
</ul>
</li>
<li><p>Background: I/O Hardware</p>
<ul>
<li><p>CPU and device (controller) communicate via</p>
<ul>
<li>I/O instructions</li>
<li>Memory instructuions (memory-mapped)</li>
</ul>
</li>
<li><p>Data transfer: progammed I/O vs. DMA (direct memory access)</p>
</li>
<li><p>Synchronization: polling vs. interrupts</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/hardware_io.png" width="500"></p>
</li>
</ul>
</li>
<li><p>Buffered/Unbuffered I/O</p>
<ul>
<li><p>Pros:</p>
<ul>
<li>What if pages containing buffer are paged out?</li>
<li>What if entire process is swapped out?</li>
<li>Can pin pages, but if too many processes do this?</li>
</ul>
</li>
<li><p>Cons:</p>
<ul>
<li>Memory copying is expensive</li>
<li>Consider effect on caches</li>
</ul>
</li>
</ul>
</li>
<li><p>Dealing with Complexity of Devices</p>
<ul>
<li><p>Many different types of devices</p>
<ul>
<li>Classify by shared characteristics</li>
<li>Imposes structure: shared code, lower complexity</li>
</ul>
</li>
<li><p>Dimensions</p>
<ul>
<li>Varaible vs. fixed size units</li>
<li>Sequential vs. random-access</li>
<li>Synchronous vs. asynchronous</li>
<li>Speed of operation</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="I-O-system"><a href="#I-O-system" class="headerlink" title="I/O system"></a>I/O system</h2><ol>
<li><p>I/O system Intro</p>
<ul>
<li><p>Software that deals with I/O</p>
<ul>
<li>Mostly in the kernel</li>
<li>Also in processes (in form of library, e.g., stdio)</li>
</ul>
</li>
<li><p>Separated into two portions</p>
<ul>
<li>Device-dependent</li>
<li>Device- independent</li>
</ul>
</li>
<li><p>Structure: Layered</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/IO_system_structure.png" width="500"></p>
</li>
</ul>
</li>
<li><p>Device Dependent: Device Drivers</p>
<ul>
<li><p>Encapsulates device-dependent code</p>
<ul>
<li>Contains device-specific register reads/write</li>
</ul>
</li>
<li><p>Implements a standard interface</p>
<ul>
<li>open(), close(), read(), write()</li>
</ul>
</li>
<li><p>Interrupt handlers</p>
<ul>
<li>Executes when I/O completes</li>
<li>Updates data structure</li>
<li>Wakes up waiting process</li>
</ul>
</li>
</ul>
</li>
<li><p>Device-Independent I/O</p>
<ul>
<li>Uniform interfacing for device drivers</li>
<li>Naming, protection</li>
<li>Uniform block size</li>
<li>Buffering, caching</li>
<li>Storage allocation</li>
<li>Locking</li>
<li>Error handling</li>
</ul>
</li>
<li><p>User-space I/O <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/user_space_io.png" width="180" style="float: right;"></p>
<ul>
<li><p>Convenient interface</p>
<ul>
<li>printf() vs. write()</li>
</ul>
</li>
<li><p>User-level buffering</p>
<ul>
<li>Unix: stdio library</li>
</ul>
</li>
<li><p>Spooling daemons</p>
<ul>
<li>Printer</li>
</ul>
</li>
</ul>
</li>
<li><p>Overall Operation</p>
<p> <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/io_operation.png" width="350"></p>
</li>
</ol>
<h3 id="Example-UNIX"><a href="#Example-UNIX" class="headerlink" title="Example: UNIX"></a>Example: UNIX</h3><ol>
<li><p>I/O Model <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/unix_io.png" width="180" style="float: right;"></p>
<ul>
<li>Uses file system interface</li>
<li>stdio.h: C standard I/O library</li>
<li><p>Block devices (disks, USB cameras, …)</p>
<ul>
<li>Fixed-size blocks</li>
<li>Randomly addressable</li>
<li>Uses buffer cache</li>
</ul>
</li>
<li><p>Character devices (serial ports, parallel ports, sound cards,…)</p>
<ul>
<li>Variable sequence of bytes</li>
<li>For non-block devices</li>
</ul>
</li>
</ul>
</li>
<li><p>I/O System Call Interface</p>
<ul>
<li>fd = open(“/dev/devname”, …)</li>
<li>close(fd)</li>
<li>nr = read(fd, buf, n)</li>
<li>nw = write(fd, buf, n)</li>
<li>ioctl(fd, cmd, buf) //(input/output control)</li>
</ul>
</li>
<li><p>Standard I/O Library</p>
<ul>
<li>fopen, fread, fwrite, fprintf, fscanf, fclose, …</li>
<li>Private buffer kept in user space</li>
<li>Minimizes the number of I/O system calls</li>
</ul>
</li>
<li><p>Software Block Cache Design</p>
<ul>
<li>Has copies of blocks that are also on disk</li>
<li><p>Upon read or write</p>
<ul>
<li>Check if a buffer contains the block</li>
<li>If not, get from disk</li>
<li>To make room, remove LRU block</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]文件系统-filesystem</title>
    <url>/2020/04/19/file-system/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面文件系统以及文件的概念，包括文件系统的组成以及访问具体文件/文件夹的方法。</p>
<a id="more"></a>
<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ol>
<li><p>Preview</p>
<ul>
<li><p>File: logical unit of storage, container of data</p>
<ul>
<li>Accessed by (name, region within file)</li>
</ul>
</li>
<li><p>File System: a structured collection of files</p>
<ul>
<li>Access control, name space, persistent storage</li>
</ul>
</li>
</ul>
</li>
<li><p>File System Abstraction</p>
<ul>
<li><p>Repository of objects</p>
<ul>
<li>Objects are data, programs for system and users</li>
<li>Objects referenced by name, to be read/written</li>
</ul>
</li>
<li><p>More than a repository</p>
<ul>
<li>Objects can be r/w, protected, shared, locked</li>
<li>Contains I/O devices: disk, keyboard, display</li>
<li>Processes: memory</li>
</ul>
</li>
<li><p>Pesistent: remains “forever”</p>
</li>
<li>Large: “unlimited” size</li>
<li>Sharing: controlled access</li>
<li>Security: protecting information</li>
</ul>
</li>
<li><p>Hierarchical File Name Space</p>
<ul>
<li><p>Name space is organized as a tree</p>
<ul>
<li>Name has components, branches start from root</li>
<li>No size restrictions</li>
<li>Intuitive for users</li>
</ul>
</li>
<li><p>Example: UNIX “Pathnames”</p>
<ul>
<li>Absolute: /a/b/c</li>
<li>Relative: b/c relative to /a</li>
<li>Not strictly a tree: links</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><ol>
<li><p>Attributes</p>
<ul>
<li>Type (recognized by system or users)</li>
<li>Times: creation, accessed, modified</li>
<li>Sizes: current size, (maximum size)</li>
<li>Access control (permissions)</li>
</ul>
</li>
<li><p>Operations</p>
<ul>
<li>Creation: create, delete</li>
<li>Prepare for access: open, close, mmap</li>
<li>Access: read, write</li>
<li>Search: move to location</li>
<li>Attributes: get, set(e.g., permissions)</li>
<li>Mutual exclusion: lock, unlock</li>
<li>Name management: rename</li>
</ul>
</li>
<li><p>Read/Write model</p>
<ul>
<li>(file descriptor)fd = open(fname, usage)</li>
<li>nr = read(fd, buf, size)</li>
<li>nw = write(fd, buf, size)</li>
<li><p>close</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/read_write.png" width="300"></p>
</li>
</ul>
</li>
<li><p>Memory-mapped model</p>
<ul>
<li><p>Map file into address space</p>
<ul>
<li>mmap(addr, n, …, fd, …)</li>
<li>addr = mmap(NULL, n, …, fd, …)</li>
</ul>
</li>
<li><p>Use memory ops</p>
<ul>
<li>x = addr[5]</li>
<li>strcpy(addr, “hello”)</li>
</ul>
</li>
<li><p>Issues</p>
<ul>
<li>Efficient for multiple process sharing memory</li>
<li>If memory is written, how is file actually updated?</li>
</ul>
</li>
</ul>
</li>
<li><p>Access Control</p>
<ul>
<li>Who can access file</li>
<li>What operations are allowed</li>
<li>User interface must be simple and intuitive</li>
<li><p>Example: Unix</p>
<ul>
<li>r/w/x permissions for owner, group and everyone</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="File-System-Implementation"><a href="#File-System-Implementation" class="headerlink" title="File System Implementation"></a>File System Implementation</h2><ol>
<li><p>Goals</p>
<ul>
<li><p>Archival storage</p>
<ul>
<li>Keep forever, including previous versions</li>
</ul>
</li>
<li><p>Support various storage technologies</p>
<ul>
<li>Disks (different types), remote disks, …</li>
</ul>
</li>
<li><p>How to best achieve and balance:</p>
<ul>
<li>Performance</li>
<li>Reliability</li>
<li>Security</li>
</ul>
</li>
</ul>
</li>
<li><p>Storage Abstraction</p>
<ul>
<li><p>Hide complexity of device</p>
<ul>
<li>Model as array of blocks of data</li>
<li>Randomly addressable by block number</li>
<li><p>Typical block size: 1KB (also 4KB ~ 64KB)</p>
<ul>
<li>Generally multiple of disk sector size: 512B</li>
</ul>
</li>
</ul>
</li>
<li><p>Simple interface</p>
<ul>
<li>read(block_num, mem_addr)</li>
<li>write(block_num, mem_addr)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Typical Implementation Structure</strong></p>
<ul>
<li>Three major regions: Sequence of blocks for each one</li>
<li><p>Region 1: File System Metadata</p>
<ul>
<li>Information about file system</li>
<li><p>Sizes</p>
<ul>
<li>Files in use, free entries</li>
<li>Data blocks in use, free entries</li>
</ul>
</li>
<li><p>Free lists (or bitmaps)</p>
<ul>
<li>File control blocks</li>
<li>Data blocks</li>
</ul>
</li>
</ul>
</li>
<li><p>Region 2: File Metadata (File Control Blocks)</p>
<ul>
<li>Information about a file</li>
<li>Referenced by number/index</li>
<li><p>Contains</p>
<ul>
<li>Attributes: type, size, permissions,…</li>
<li>References to data blocks: disk block map</li>
</ul>
</li>
<li><p>Note: many file control blocks may fit in single storage block</p>
</li>
<li><p>Example:</p>
<ul>
<li>Number: 88 (index in file control block array)</li>
<li>Size: 4096 bytes</li>
<li>Permissions: rw-r—r—</li>
<li>Data blocks: set of indexes into storage array, may not be contiguous (such as 567, 7076, 9201)</li>
</ul>
</li>
</ul>
</li>
<li><p>Region 3: Data Blocks</p>
<ul>
<li>File contents</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="File-control-blocks"><a href="#File-control-blocks" class="headerlink" title="File control blocks"></a>File control blocks</h3><ol>
<li><p>Keeping track of allocated blocks</p>
<ul>
<li><p>Contiguous blocks</p>
<ul>
<li>Single sequence of blocks</li>
</ul>
</li>
<li><p>Extents</p>
<ul>
<li>Groups of contiguous blocks</li>
</ul>
</li>
<li><p>Non-contiguous blocks</p>
<ul>
<li>Blocks individually named</li>
</ul>
</li>
</ul>
</li>
<li><p>Keeping track of free blocks</p>
<ul>
<li><p>Free Block Map</p>
<ul>
<li>Compact if lots of free regions of space</li>
</ul>
</li>
<li><p>Doubly Linked List</p>
<ul>
<li>Easy to keep ordered due to fast inserts and deletes</li>
</ul>
</li>
<li><p>Bit Map</p>
<ul>
<li>Fixed size regardless of fragmentation</li>
</ul>
</li>
</ul>
</li>
<li><p>File Name to File Control Block</p>
<ul>
<li>Users access files using file names</li>
<li><p>Problem: how to translate</p>
<ul>
<li>from file name: “/sports/baseball/Padres”</li>
<li>to file control block number: 88</li>
</ul>
</li>
<li><p>Must parse file name</p>
</li>
<li>Each branch corresponds to a directory/folder</li>
<li>Each directory/folder may itself be a file</li>
</ul>
</li>
</ol>
<h3 id="Example-UNIX-v-7-Block-Map"><a href="#Example-UNIX-v-7-Block-Map" class="headerlink" title="Example: UNIX v.7 Block Map"></a>Example: UNIX v.7 Block Map</h3><ol>
<li><p>Block Map UNIX v.7</p>
<ul>
<li>Array of pointers to data blocks</li>
<li><p>13 Pointers</p>
<ul>
<li>10 direct: references 10 data blocks</li>
<li>1 singly-indirect: references $n$ data blocks</li>
<li>1 doubly-indirect: reference $n^2$ data blocks</li>
<li>1 triply-indirect: reference $n^3$ data blocks</li>
</ul>
</li>
<li><p>$n$ depends on how many pointers fit in a block</p>
<ul>
<li><p>Example: 256 4-byte pointers will fit in 1KB block</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/unix.v7.png" width="400"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Implementing UNIX Directories</p>
<ul>
<li><p>Table where each entry contains</p>
<ul>
<li>name and attributes</li>
<li>name and pointer to file control structure</li>
</ul>
</li>
<li><p>Unix (name and pointer) - pre-BSD</p>
<ul>
<li>Each entry: branch name (14), i-node number (2)</li>
<li>Berkeley Unix uses a more complex scheme to support long names</li>
</ul>
</li>
</ul>
</li>
<li><p>Example of parsing names in UNIX</p>
<ul>
<li><p>Given pathname: /sports/baseball/Padres</p>
<ul>
<li>Inode 0 block map points to data block(s) of root directory</li>
<li>Look up “sports” in root directory to get inode 22</li>
<li>Inode 22 blocks map points to data block(s) of sports directory</li>
<li>Look up “baseball” in sports directory to get inode 15</li>
<li><p>…</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/unix_exp.png" width="400"></p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/unix_exp2.png" width="500"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><ol>
<li><p>File Systems use disks for storage</p>
<p> <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/disk.png" width="500"></p>
<ul>
<li>pros: persistent, random access, cheap</li>
<li>cons: slow (mechanical)</li>
<li><p>Performance</p>
<ul>
<li><p>Accesses are time expensive: 5 ~ 20 msec</p>
<ul>
<li>Rotational latency: 2 ~ 6 msec (5200 ~ 15000 RPM)</li>
<li>Seek time: 3 ~ 13 msec</li>
<li>Transfer rate: 100+ MB/sec</li>
</ul>
</li>
<li><p>Reduced accesses by</p>
<ul>
<li>reading multiple blocks in one access (read ahead)</li>
<li>maintaining a block cache</li>
</ul>
</li>
<li><p>Cluster related blocks to reduce seek time</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Solid State Drives (SSD)</p>
</li>
</ol>
<ul>
<li>NAND-based flash memory, non-volatile</li>
<li>Unaffected by shock, magnetic fields; no noise</li>
<li>Limited number of writes, wears out with age</li>
</ul>
<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><ol>
<li><p>Caching</p>
<ul>
<li>Data blocks of files</li>
<li>File system metadata (keep in memory)</li>
<li><p>File metadata</p>
<ul>
<li>Currently active file</li>
<li>Recently used</li>
</ul>
</li>
<li><p>Block maps</p>
</li>
<li><p>File names</p>
<ul>
<li>Name to file metadata translations</li>
</ul>
</li>
</ul>
</li>
<li><p>Clustering</p>
<ul>
<li><p>Blocks that exhibit locality of reference</p>
<ul>
<li>Directory, and files within that directory</li>
<li>The inodes of the directory and files</li>
</ul>
</li>
<li><p>Strategy</p>
<ul>
<li>Place related blocks close to each other: clustering</li>
<li>Reduces disk head movement and seek time</li>
</ul>
</li>
</ul>
</li>
<li><p>Block size</p>
<ul>
<li><p>trade off</p>
<ul>
<li>the larger the block, the better the throughput</li>
<li>The smaller the block, the less wasted space</li>
</ul>
</li>
<li><p>technology trend</p>
<ul>
<li>Disk density is increasing faster than disk speed</li>
<li>Make disk blocks larger: 1KB $\rightarrow$ 8KB, 64KB, 1MB</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Reliability"><a href="#Reliability" class="headerlink" title="Reliability"></a>Reliability</h3><ol>
<li><p>Consistency</p>
<ul>
<li>Buffer cache reduces disk access</li>
<li>If system crashes, block modifications lost</li>
<li><p>To improve file system consistency</p>
<ul>
<li>write out modified blocks periodically</li>
<li>write out critical blocks</li>
</ul>
</li>
<li><p>Critical blocks: file system meta-data</p>
<ul>
<li>Directories, i-nodes, free block lists</li>
</ul>
</li>
</ul>
</li>
<li><p>Journaling</p>
<ul>
<li>Journal: log of file (or file system) updates</li>
<li>For every update, create log entry</li>
<li>Write log entry out to disk (part of journal)</li>
<li><p>If crash occurs:</p>
<ul>
<li>Look at journal entries</li>
<li>Check if mods properly reflected in file system</li>
<li>Update appropriately</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]虚拟内存-virtual memory</title>
    <url>/2020/04/19/virtual_memory/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面虚拟内存的概念，主要是对上一节课的逻辑内存的一部分补充，关于segment和page的概念可以参考上一篇笔记。</p>
<a id="more"></a>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><ol>
<li><p>Segments and Pages</p>
<ul>
<li><p>Structuring memory as segements/pages allows:</p>
<ul>
<li>partitioning memory for convenient allocation</li>
<li>reorganizing memory for convenient usage</li>
</ul>
</li>
<li><p>Approaches</p>
<ul>
<li>Relocation via address translation</li>
<li>Protection via matching operations with objects</li>
</ul>
</li>
<li><p>Result: a logically organized memory</p>
</li>
</ul>
</li>
<li><p>Optimization</p>
<ul>
<li><p>Not all pieces need to be in memory</p>
<ul>
<li>Need only piece being referenced</li>
<li>Other pieces can be on disk</li>
<li>Bring pieces in only when needed</li>
</ul>
</li>
<li><p>Illusion: there is much more memory</p>
</li>
<li><p>Needed:</p>
<ul>
<li>A way to identify whether a piece is in memory</li>
<li>A way to bring in a piece (from where to where?)</li>
<li>Relocation (address translation)</li>
</ul>
</li>
</ul>
</li>
<li><p>From logical to virtual memory</p>
<ul>
<li><p>Logical memory becomes virtual memory</p>
<ul>
<li>Still logical (seperate organization from physical)</li>
<li>Virtual: memory seems to exist, regardless of how (memory or disk)</li>
</ul>
</li>
<li><p>Virtual memory: illusion of large memory</p>
<ul>
<li>Keep only portion of logical memory in physical</li>
<li>Rest is kept on disk (larger, slower, cheaper)</li>
<li>Unit of memory is segment or page (or both)</li>
</ul>
</li>
<li><p>Logical address space $\rightarrow$ virtual address space</p>
</li>
</ul>
</li>
</ol>
<h2 id="Virtual-memory-based-on-paging"><a href="#Virtual-memory-based-on-paging" class="headerlink" title="Virtual memory based on paging"></a>Virtual memory based on paging</h2><ol>
<li><p>Paged virtual memory</p>
<ul>
<li>All of pages reside on disk</li>
<li>Some also reside in physical memory (which ones?)</li>
</ul>
</li>
<li><p>Contents of page table entry</p>
<ul>
<li>Valid: is entry valid (page in physical memory or not)</li>
<li>Ref: has this page been referenced yet?</li>
<li>Mod: has this page been modified?</li>
<li>Frame: what frame is this page in?</li>
<li>Prot: what are the allowable operations?</li>
</ul>
</li>
<li><p>Address Translation</p>
<ul>
<li><p>Process:</p>
<ul>
<li>Get entry: index page table with page number</li>
<li><p>If valid bit is off, which cause a page fualt, then trap into kernel</p>
<ul>
<li>Find page on disk</li>
<li><p>Read it into a free frame</p>
<ul>
<li>may need to make room if there is no available frame: page replacement</li>
</ul>
</li>
<li><p>Record frame number in page table entry</p>
</li>
<li>Set valid bit and other fields</li>
</ul>
</li>
<li><p>Retry instruction (return from page-fault trap)</p>
</li>
</ul>
</li>
<li><p>Possible faults under segmentation/paging</p>
<ul>
<li><p>two kinds of address:</p>
<ul>
<li>Virtual address: (segment s, page p, offset i)</li>
<li>Physical address: (frame f, offset i)</li>
</ul>
</li>
<li><p>[ ] Use s to index segment table (to get page table)</p>
<ul>
<li>may get a segment fualt</li>
</ul>
</li>
<li><p>[ ] Check bound (Is p &lt; bound?)</p>
<ul>
<li>may get a segmentation violation</li>
</ul>
</li>
<li><p>[ ] Use p to index page table (to get frame f)</p>
<ul>
<li>may get a page fault</li>
</ul>
</li>
<li><p>[ ] Physical address: concatenate f and i</p>
</li>
</ul>
</li>
<li><p>Cost of page faults is high</p>
<ul>
<li>Disk: 5 ~ 6 orders magnitude slower than RAM</li>
<li><p>Example:</p>
<ul>
<li>RAM access time: 100 nsec</li>
<li>Disk access time: 10 msec</li>
<li>p = page fault probability</li>
<li>Effective access time: 100 + p * 10,000,000 nsec</li>
<li>if p = 0.1%, effective access time = 10,100 nsec (100 times slower!)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Possible-implementation"><a href="#Possible-implementation" class="headerlink" title="Possible implementation"></a>Possible implementation</h2><ol>
<li><p>Principle of Locality</p>
<ul>
<li><p>Not all pieces referenced uniformly over time</p>
<ul>
<li>Make sure most referenced pieces in memory</li>
<li>If not, thrashing: constant fetching of pieces</li>
</ul>
</li>
<li><p>References cluster in time/space</p>
<ul>
<li>Will be same or neighboring areas</li>
<li>Allows prediction based on past</li>
</ul>
</li>
</ul>
</li>
<li><p>Page replacement policy</p>
<ul>
<li>Goal: remove page not in locality of reference</li>
<li><p>Page replacement is about:</p>
<ul>
<li>which page(s) to remove</li>
<li>when to remove them</li>
</ul>
</li>
<li><p>How to do it in cheapest way possible, with:</p>
<ul>
<li>least amount of additional hardware</li>
<li>least amount of software overhead</li>
</ul>
</li>
</ul>
</li>
<li><p><em>Basic Page Replacement Algorithms</em></p>
<ul>
<li><p>FIFO: select page that is oldest</p>
<ul>
<li>Simple: keep pointer to next frame after last loaded</li>
<li>Doesn’t perform well (oldest may be popular)</li>
</ul>
</li>
<li><p>OPT: Optimal Page Replacement</p>
<ul>
<li>Optimal: replace page that will be accessed furthest in future</li>
<li><p>Not realistic:</p>
<ul>
<li>Requires predicting the future</li>
<li>Useful as a benchmark</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>LRU: Least Recently Used</strong></p>
<ul>
<li><p>Replace page that was least recently used</p>
<ul>
<li>LRU means used furthest in the past</li>
</ul>
</li>
<li><p>Takes advantage of locality of reference</p>
</li>
<li>Must have some way of tracking frame with LRU page : requires hardware support</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><ol>
<li><p><strong>Approximating LRU: Clock Algorithm</strong></p>
<ul>
<li><p>Select page that is old and not recently used</p>
<ul>
<li>Clock (second chance) is approximation of LRU</li>
</ul>
</li>
<li><p>Hardware support: reference bit</p>
<ul>
<li>Associated with each frame is a reference bit</li>
<li>Reference bit is in page table entry</li>
</ul>
</li>
<li><p>How reference bit is used</p>
<ul>
<li>When frame filled with page, set bit to 0 (by OS)</li>
<li>If frame is accessed, set bit to 1 (by hardware)</li>
</ul>
</li>
<li><p><em>Working process</em></p>
<ul>
<li>Arrange all frames in circle (clock)</li>
<li>Clock hand: next frame to consider</li>
<li><p>Page fault: find frame</p>
<ul>
<li>If ref bit 0, select frame</li>
<li>Else, set ref bit to 0</li>
<li>Advance clock hand</li>
<li>If frame found, break out of loop, else repeat</li>
</ul>
</li>
<li><p>If frame had modified page, must write it to disk</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Resident Set Management</p>
<ul>
<li><p>Resident set: process’s pages in physical memory</p>
<ul>
<li>One set per process</li>
<li>How big should resident set be? Which pages?</li>
<li>Who provides frame (same process or another)?</li>
</ul>
</li>
<li><p>Local: limit frame selection to request process</p>
<ul>
<li>Isolates effects of page behavior on processes</li>
<li>Inefficient: some processes have unused frames</li>
</ul>
</li>
<li><p>Global: select any frame (from any process)</p>
<ul>
<li>Efficient: resident sets grow/shrink accordingly</li>
<li>No isolation: process can negatively affect another (by replacing other process’s important pages)</li>
</ul>
</li>
</ul>
</li>
<li><p>Multiprogramming Level</p>
<ul>
<li>Multiprogramming level: number of processes in physical memory (non-empty resident sets)</li>
<li>Goal: increase multiprogramming level - how?</li>
<li>However, beyond certain point: thrashing (make processor utilization pretty low since many processes may not be working)</li>
<li>Resident set should contain the working set</li>
</ul>
</li>
<li><p>Denning’s Working Set Model</p>
<ul>
<li><p>Introduction</p>
<ul>
<li><p>Working set: $W(t, \Delta)$</p>
<ul>
<li>Pages referenced during last delta (process time)</li>
</ul>
</li>
<li><p>Process given frames to hold working set</p>
</li>
<li>Add/remove pages according to $W(t, \Delta)$</li>
<li>If working set doesn’t fit, swap process out</li>
</ul>
</li>
<li><p>Working set is a local replacement policy</p>
<ul>
<li>Process’s page fault behavior doesn’t affect others</li>
</ul>
</li>
<li><p>Problem: difficult to implement</p>
<ul>
<li>Must timestamp pages in working set</li>
<li>Must determine if timestamp older than $t - \Delta$</li>
<li>How should $\Delta$ be determined?</li>
</ul>
</li>
<li><p>Contrast to Clock</p>
<ul>
<li>Clock: simple, easy to implement, global policy</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]逻辑内存-logicalmemory</title>
    <url>/2020/04/19/logical_memory/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面逻辑内存的概念，包括页(page)和段(segment)的概念和实现。</p>
<a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol>
<li><p>Definition</p>
<ul>
<li>Logical memory = a process’s memory</li>
<li>As viewed (referenced) by a process</li>
<li>Allocated without regard to physical memory</li>
</ul>
</li>
<li><p>Problems with sharing memory</p>
<ul>
<li><p>The addressing problem</p>
<ul>
<li>Compiler generates memory reference</li>
<li>Unknown where process will be located</li>
</ul>
</li>
<li><p>The protection problem</p>
<ul>
<li>Modifying another process’s memory</li>
</ul>
</li>
<li><p>The space problem</p>
<ul>
<li>The more processes there are, the less memory each individually can have</li>
</ul>
</li>
</ul>
</li>
<li><p>Logical vs. Physical Addressing <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/logical_physical.png" width="150" style="float: right;"></p>
<ul>
<li><p>Logical addresses</p>
<ul>
<li>Assumes seperate memory starting at 0</li>
<li>Compiler generated</li>
<li>Independent of location in physical memory</li>
</ul>
</li>
<li><p>Convert logical to physical</p>
<ul>
<li>Via software: at load time</li>
<li>Via hardware: at access time</li>
</ul>
</li>
<li><p>Hardware for Logical addressing <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/memory_protection.png" width="180" style="float: right;"></p>
<ul>
<li>Base register filled with start address</li>
<li>To translate logical address, add base</li>
<li>Achieves relocation</li>
<li>To more process: change base</li>
</ul>
</li>
<li><p>Protection</p>
<ul>
<li>Bound register works with base register</li>
<li><p>Is address &lt; bound</p>
<ul>
<li>Yes: add to base</li>
<li>No: invalid address, TRAP</li>
</ul>
</li>
<li><p>Achieves protection</p>
</li>
</ul>
</li>
<li><p>Memory Registers are part of context</p>
<ul>
<li><p>On every context switch</p>
<ul>
<li>Load base/bound register for selected process</li>
<li>Only kernel does loading of these register</li>
<li>Kernel must be proetced from all processes</li>
</ul>
</li>
<li><p>Benefit</p>
<ul>
<li>Allows each proces to be seperated located</li>
<li>Protecs each process from all others</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Process mempory allocation</p>
<ul>
<li><p>Process address space</p>
<ul>
<li><p>Text: program instruction</p>
<ul>
<li>excute-only, fixed size</li>
</ul>
</li>
<li><p>Data: varaible (static, heap)</p>
<ul>
<li>read/write, variable size</li>
<li>dynamic allocation by request</li>
</ul>
</li>
<li><p>Stack: activation records, local variable</p>
<ul>
<li>read/write, varibale size</li>
<li>Automatic growth/shrinkage</li>
</ul>
</li>
</ul>
</li>
<li><p>Fitting process into memory</p>
<ul>
<li>Must find large enough hole</li>
<li>May not succeed even if enought fragment space</li>
<li>Even successul, it’s inefficient since space must be allocated for potential growth area</li>
</ul>
</li>
<li><p>Solution: break process into pieces</p>
<ul>
<li>Distribute into available holes</li>
<li>Two approaches: Segment and Page</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Segementation"><a href="#Segementation" class="headerlink" title="Segementation"></a>Segementation</h2><ol>
<li><p>Segemented Address Space</p>
<ul>
<li>Address space is a set of segments</li>
<li><p>Segment: a linearly addressed memory</p>
<ul>
<li>Typically contains logically-related information</li>
<li>Examples: program code, data, stack</li>
</ul>
</li>
<li><p>Each segment has an identifier s, and a size N</p>
<ul>
<li>s between 0 and S-1, S = max number of segments</li>
</ul>
</li>
<li><p><em>Logical addresses are of the form (s, i)</em></p>
<ul>
<li>offset i within segment s, i must be less than N</li>
</ul>
</li>
<li><p>Example</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/segment_example.png" width="400"></p>
</li>
</ul>
</li>
<li><p>Segment-based address translation</p>
<ul>
<li>Problem: how to translate a logical address (s, i) into physical address a?</li>
<li><p>Solution: use a segment (translate) table (ST)</p>
<ul>
<li>to segment s into base physical address b = ST(s)</li>
<li>then add b and i</li>
</ul>
</li>
<li><p>physical address a = ST(s) + i</p>
</li>
</ul>
</li>
<li><p><em>Segment Table</em> <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/ST.png" width="180" style="float: right;"></p>
<ul>
<li>One table per process (typically)</li>
<li><p>Table entry elements</p>
<ul>
<li>V: valid bit</li>
<li>Base: segment location</li>
<li>Bound: segment size</li>
<li>Perm: permissions</li>
</ul>
</li>
<li><p>Location in memory given by</p>
<ul>
<li>Segment table base register(hardware)</li>
<li>Segment table size register(hardware)</li>
</ul>
</li>
<li><p>Address translation</p>
<ul>
<li>physical address a = base of s + i</li>
<li><p>do a series of checks</p>
<ul>
<li>s &lt; STSR? -&gt; is segment identifier valid or not?</li>
<li>V == 1? -&gt; the corresponding entry is valid?</li>
<li>i &lt; Bound? -&gt; logical address is out of bound?</li>
<li>Perm(op) -&gt; that block has required operation(r/w/x)?</li>
<li><p>Then access that physical address</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/physical_address_check.png" width="300"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Sizing the segment table</strong></p>
<ul>
<li><p>Given 32 bit logical, 1 GB physical memory (max)</p>
<ul>
<li>5 bit segment number, 27 bit offset</li>
</ul>
</li>
<li><p>Logical address</p>
<ul>
<li><p>Segement s: number of bits n specifies maxsize of table, where number of entries = $2^n$</p>
<ul>
<li>if 32 entries, n = 5</li>
</ul>
</li>
<li><p>Offset i: number of bits n specifies maxsize of segment</p>
<ul>
<li>27 bits needed to size up to 128MB</li>
</ul>
</li>
</ul>
</li>
<li><p>segment table</p>
<ul>
<li>V: 1 bit</li>
<li><p>Base: number of bits needed to address physical memory</p>
<ul>
<li>30 bits needed to address 1GB</li>
</ul>
</li>
<li><p>Bound: number of bits needed to specify max segment size</p>
<ul>
<li>27 bits needed to size up to 128MB</li>
</ul>
</li>
<li><p>Perm: assume 3 bit (r/w/x)</p>
</li>
<li><p>one entry: $1 + 30 + 27 + 3 + … = 61$+ bits $\approx$ 8 bytes</p>
</li>
<li>whole table: 32 * 8 = 256 bytes</li>
</ul>
</li>
</ul>
</li>
<li><p>Pros and Cons</p>
<ul>
<li><p>Pros: Each segment can be</p>
<ul>
<li>located independently</li>
<li>seperately protected</li>
<li>grown/shrunk independently</li>
<li>Segments can be shared by processes (via segment table)</li>
</ul>
</li>
<li><p>Cons: Variable-size allocation</p>
<ul>
<li>Difficult to find holes in physical memory</li>
<li>External fragmentation</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><ol>
<li><p>Paged Address Space <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/Paging.png" width="180" style="float: right;"></p>
<ul>
<li><p>Logical (process) memory</p>
<ul>
<li>Linear sequence of pages</li>
</ul>
</li>
<li><p>Physical memory</p>
<ul>
<li>Linear sequence of frames</li>
</ul>
</li>
<li><p>Pages and frames</p>
<ul>
<li>Frame: a physical unit of information</li>
<li>A page fits exactly into a frame</li>
<li>Fixed size, all pages/frames same size</li>
</ul>
</li>
</ul>
</li>
<li><p>Page-based Logical Addressing</p>
<ul>
<li><p>Form of logical address: (p, i)</p>
<ul>
<li>p is page number, 0 to N - 1</li>
<li>i is offset within page, since page size is fixed, i is guaranteed to be less than page size, no need to check</li>
</ul>
</li>
<li><p>Size of logical address space</p>
<ul>
<li>$N_L$ = max number of pages</li>
<li>$N_L \times$ page size = size of logical address space</li>
</ul>
</li>
</ul>
</li>
<li><p>Frame-based Physical Addressing</p>
<ul>
<li><p>Form of physical address: (f, i)</p>
<ul>
<li>f is frame number, 0 to N - 1</li>
<li>i is offset within frame, less than frame size</li>
</ul>
</li>
<li><p>Size of physical address space</p>
<ul>
<li>$N_p$ = max number of frames</li>
<li>$N_p \times$ frame size = size of physical address space</li>
</ul>
</li>
</ul>
</li>
<li><p>Page-based address translation</p>
<ul>
<li>Problem: how to translate logical address (p, i) into physical address (f, i)</li>
<li><p>Solution: use a page (translation) table PT</p>
<ul>
<li>translate page p into frame f = PT(p)</li>
<li>then concatenate f and i</li>
</ul>
</li>
<li><p>Physical address (f, i) = PT(p) || i = (PT(p), i)</p>
</li>
</ul>
</li>
<li><p><strong>Page table</strong></p>
<ul>
<li>Each page of logical memory correspondings to entry in page table</li>
<li>Page table maps logical page into frame of physical memory</li>
<li>One table per process (typically)</li>
<li><p>Table entry elements</p>
<ul>
<li>V: valid bit</li>
<li>DPB: demand paging bits</li>
<li>Frame: page location</li>
</ul>
</li>
<li><p>Location in memory given by</p>
<ul>
<li>Page table base register(PTBR) (hardware)</li>
<li>Page table size register(PTSR) (hardware)</li>
</ul>
</li>
<li><p>Address translation</p>
<ul>
<li>Physical address = frame of p || offset i</li>
<li><p>Do a series of checks (similar to segmenatation)</p>
<ul>
<li>p &lt; PTSR?</li>
<li>V == 1?</li>
<li>Perm(op)?</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Sizing the page table</strong></p>
<ul>
<li><p>Given 32 bit logical, 1 GB physical memory (max)</p>
<ul>
<li>20 bit page number, 12 bit offset</li>
</ul>
</li>
<li><p>Logical address</p>
<ul>
<li>page p: 20 bits to address $2^{20} =$ 1M entries</li>
<li>offset i: 12 bits, page size = frame size = $2^{12} =$ 4096 bytes.</li>
</ul>
</li>
<li><p>Page table</p>
<ul>
<li>V: 1 bit</li>
<li>DPB: 3 bits</li>
<li>Frame: 18 bits to address $2^{30}/2^{12}$ frames</li>
<li>Perm: 3bits</li>
<li>One entry: $1+3+18+3+…= 25$+ bits $\approx$ 4 bytes</li>
<li>Whole table size = 1M * 4 = 4 MB</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Address-translation"><a href="#Address-translation" class="headerlink" title="Address translation"></a>Address translation</h2><ol>
<li><p>Segments vs. Pages</p>
<ul>
<li><p>Segment is good “logical” unit of information</p>
<ul>
<li>Can be sized to fit any contents</li>
<li>Makes sense to share (e.g., code, data)</li>
<li>Can be protected according to contents</li>
</ul>
</li>
<li><p>Page is good “physical” unit of information</p>
<ul>
<li>Simple memory management</li>
</ul>
</li>
</ul>
</li>
<li><p>Combining segments and pages <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/segment_page.png" width="250" style="float: right;"></p>
<ul>
<li><p>Logical memory</p>
<ul>
<li>composed of segments</li>
</ul>
</li>
<li><p>Each segment</p>
<ul>
<li>composed of pages</li>
</ul>
</li>
<li><p>Segment table</p>
<ul>
<li>Maps each segment to a page table</li>
</ul>
</li>
<li><p>Page tables</p>
<ul>
<li>Maps each page to physical page frames</li>
</ul>
</li>
</ul>
</li>
<li><p>Address Translation</p>
<ul>
<li>Logical address: [segment s, page p, offset i]</li>
<li><p>Do various checks</p>
<ul>
<li>s &lt; STSR, V == 1, p &lt; bound, perm(op)</li>
<li>May get a segmentation violation</li>
</ul>
</li>
<li><p>Use s to index segment table to get page table</p>
</li>
<li>Use p to index page table to get frame f</li>
<li><p>Physical address = concatenate (f, i)</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/Segment_Page_Address.png" width="300"></p>
</li>
</ul>
</li>
</ol>
<h2 id="More-on-addressing"><a href="#More-on-addressing" class="headerlink" title="More on addressing"></a>More on addressing</h2><ol>
<li><p>Cost of translation</p>
<ul>
<li><p>Each lookup costs another memory reference</p>
<ul>
<li>For each reference, additional references required</li>
<li>Slows machine down by factor of 2 or more</li>
</ul>
</li>
<li><p>Take advantage of locality of reference</p>
<ul>
<li>Most references are to a small number of pages</li>
<li>Keep translation of these in high-speed memory</li>
</ul>
</li>
<li><p>Problem: don’t know which pages till accessed</p>
</li>
</ul>
</li>
<li><p><strong>Translation Look-aside Buffer (TLB)</strong></p>
<ul>
<li>Fast memory keeps most recent translations</li>
<li>If key matches, get frame number</li>
<li><p>else wait for normal translation (in parallel)</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/TLB.png" width="400"></p>
</li>
</ul>
</li>
<li><p>Translation Cost with TLB</p>
<ul>
<li><p>Cost is determined by</p>
<ul>
<li>Speed of memory: ~100 nsec</li>
<li>Speed of TLB: ~5 nsec</li>
<li>Hit ratio: fraction of refs satisfied by TLB, ~99%</li>
</ul>
</li>
<li><p>Speed with no address translation: 100 nsec</p>
</li>
<li><p>Speed with address translation</p>
<ul>
<li>TLB miss: 200 nsec (100% slowdown)</li>
<li>TLB hit: 105 nsec (5% slowdown)</li>
<li>Average: 105 x 0.99 + 200 x 0.01 ~ 106 nsec</li>
</ul>
</li>
</ul>
</li>
<li><p>TLB Design Issues</p>
<ul>
<li><p>The larger the TLB</p>
<ul>
<li>the higher the hit rate</li>
<li>the slower the reponse</li>
<li>the greater the expense</li>
</ul>
</li>
<li><p>TLB has a major effect on performance!</p>
<ul>
<li>Must be flushed on context switched</li>
<li>Alternative: tagging entries with PIDs</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]内存管理-memory_management</title>
    <url>/2020/04/19/memory_management/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面对内存的分配以及管理方式</p>
<a id="more"></a>
<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ol>
<li><p>Allocation of memory occurs when</p>
<ul>
<li>new process is created</li>
<li>process requests more memory</li>
</ul>
</li>
<li><p>Freeing of memory occurs when</p>
<ul>
<li>process exits</li>
<li>process no longer needs memory it requested</li>
</ul>
</li>
<li><p>Memory overview</p>
<ul>
<li><p>Porcess memory store:</p>
<ul>
<li>Text: code of program</li>
<li>Data: static varibales, heap</li>
<li>Stack: automatic variables, activation records</li>
<li>Other: shared memory regions</li>
</ul>
</li>
<li><p>Process memory address space <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/process_mem.png" width="120" style="float: right;"></p>
<ul>
<li><p>Address space</p>
<ul>
<li>set of addresses to access memory</li>
<li>Typically, linear and sequential</li>
<li>0 to N-1</li>
</ul>
</li>
<li><p>Example (right):</p>
<ul>
<li>Text of size X at 0 ~ X-1</li>
<li>Data of size Y at X ~ X+Y-1</li>
<li>Stack of size Z at N-Z ~ N-1(grow reversely)</li>
</ul>
</li>
</ul>
</li>
<li><p>Compiler’s model of memory</p>
<ul>
<li><p>Compiler generates memory address</p>
<ul>
<li>Address ranges of text, data, stack</li>
<li>allow data and stack to grow</li>
</ul>
</li>
<li><p>What is not known in compiler</p>
<ul>
<li>Physical memory size</li>
<li>Allocated region of physical memory</li>
</ul>
</li>
</ul>
</li>
<li><p>Memory characteristics</p>
<ul>
<li>Size, fixed or variable (max size)</li>
<li>Permission: r, w, x</li>
</ul>
</li>
</ul>
</li>
<li><p>Goal: support multiple processes</p>
<ul>
<li><p>Support programs running “simultaneously”</p>
<ul>
<li>implement process abstraction</li>
<li>Multiplex CPU time over all runnable processes</li>
<li>Disk r/w speed is low: must keep multiple processes in memory</li>
</ul>
</li>
<li><p>Process requires more than CPU time: memory</p>
</li>
</ul>
</li>
<li><p>Memory issues and topics</p>
<ul>
<li>Where should process memories be placed? -&gt; Memory Management</li>
<li>How does the compiler model memory? -&gt; Logical memory model, segmentation</li>
<li>How to deal with limited physical memory? -&gt; Virtual memory, paging</li>
<li>Machanism and Policies</li>
</ul>
</li>
</ol>
<h2 id="Memory-Managemeng-Implementation"><a href="#Memory-Managemeng-Implementation" class="headerlink" title="Memory Managemeng Implementation"></a>Memory Managemeng Implementation</h2><ol>
<li><p>example process <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/memory_allocate.png" width="150" style="float: right;"></p>
<ul>
<li>Phsical memory starts as one empty “hole”</li>
<li>When processes are created, areas get allocated</li>
<li><p>To allocate memory</p>
<ul>
<li>find large enough hole</li>
<li>allocate region within hole</li>
<li>mostly leaves smaller hole (when the hole size does not exactly match the size of process memory)</li>
<li>when process exit (or memeory no longer needed), release that area, which create a new hole, coaleasce with adjacent</li>
</ul>
</li>
<li><p>problem: if there are multiple holes, which to select?</p>
<ul>
<li><p><em>First fit: simple, fast</em></p>
<ul>
<li>consider tradeoff: fit vs. search time</li>
<li>memory is cheap, time is expensive</li>
</ul>
</li>
<li><p>Best fit: optimal, must check every hole, leaves very small fragments</p>
</li>
<li>Worst fit: leaves large fragments, must check every hole</li>
</ul>
</li>
<li><p>complication: is region fixed or variable size?</p>
</li>
</ul>
</li>
<li><p>Fragmentation</p>
<ul>
<li>Over time, memory becomes fragmented, there may be signficant unused space (fragmented)</li>
<li><p>Internal fragmentation</p>
<ul>
<li>Unused space within (allocated) block</li>
<li>Cannot be allocated to others</li>
<li>Can come in handy for growth (for stack or heap)</li>
</ul>
</li>
<li><p>External fragmentation</p>
<ul>
<li>Unused space outside any blocks (holes)</li>
<li>Can be allocated (too small/not useful)</li>
</ul>
</li>
<li><p>Approaches</p>
<ul>
<li><p>Compaction</p>
<ul>
<li>Simple idea</li>
<li>Very time consuming</li>
</ul>
</li>
<li><p>Break block (to be allocated) into sub-blocks</p>
<ul>
<li>Easier to fit</li>
<li>But complex</li>
</ul>
</li>
<li><p>Use pre-sized holes</p>
<ul>
<li><p>Same-sized holes:</p>
<ul>
<li>all holes same, easy allocation</li>
<li>may be too small which is inflexible</li>
</ul>
</li>
<li><p>Varaiety of sizes (small, medium, large)</p>
<ul>
<li>more flexible</li>
<li>complex</li>
<li>what should sizes be? how to determine</li>
</ul>
</li>
<li><p>Not adaptable, cause internel fragmentation</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Some rules</p>
<ul>
<li><p>50% Rule: m = n / 2</p>
<ul>
<li>Block: an allocated block</li>
<li>Hole: free space between blocks</li>
<li>m = number of holes</li>
<li>n = number of blocks</li>
</ul>
</li>
<li><p><strong>Unused Memory Rule: f = k / (k + 2)</strong></p>
<ul>
<li>Given average size of blocks and holes are known</li>
<li>b = average size of blocks</li>
<li>h = average size of holes</li>
<li>k = h / b, ratio of average hole-to-block size</li>
<li>f = k / (k + 2) is fraction space lost to holes</li>
</ul>
</li>
<li><p>Usage:</p>
<ul>
<li>k = 1, f = 1/3 -&gt; avg hole size = avg block size, 33% waste</li>
<li>k = 2, f = 1/2 -&gt; avg hole size = 2 * avg block size, 50% waste</li>
<li>k = 8, f = 4/5 -&gt; avg hole size = 8 * avg block size, 80% waste</li>
</ul>
</li>
<li><p>Limits</p>
<ul>
<li><p>In general, f increases with increasing k</p>
<ul>
<li>as $k \rightarrow \infty, f \rightarrow 1$</li>
</ul>
</li>
<li><p>Alternatively, f decreases with decreasing k</p>
<ul>
<li>as $k \rightarrow 0, f \rightarrow 0$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>The Buddy System</strong></p>
<ul>
<li>Partition into power-of-2 size chunks</li>
<li><p>Allocation: given request for size r</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find chunk larger than r (else return failure)</span><br><span class="line">while (r &lt; sizeof(chunk) &#x2F; 2)</span><br><span class="line">    divide chunk into buddies (each 1&#x2F;2 size)</span><br><span class="line">allocate the chunk</span><br></pre></td></tr></table></figure>
</li>
<li><p>Free: free the chunk and coalesce with buddy</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free the chunk</span><br><span class="line">while (buddy is also free)</span><br><span class="line">    coalesce</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/Buddy.html" target="_blank" rel="noopener">visualization</a></p>
</li>
<li><p>Data structure for buddy-system -&gt; binary tree</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]死锁-deadlock</title>
    <url>/2020/04/19/deadlock/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面死锁概念包括出现的原因，以及避免（防止出现）以及解决办法（出现死锁时最好的方法是重启大法！！）</p>
<a id="more"></a>
<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ol>
<li><p>Definition</p>
<ul>
<li>Set of processes are permanently blocked<ul>
<li>Unblocking of one relies on progress of another, but none can make progress</li>
</ul>
</li>
<li><p>Example</p>
<ul>
<li>Process A holding resource X, waiting for resource Y</li>
<li>Process B holding Y, waiting for X</li>
<li><p>these two process will not be able to make any progress</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/deadlock.png" width="200"></p>
</li>
</ul>
</li>
<li><p>Another example: memory</p>
<ul>
<li>Total memory = 200MB</li>
<li>P1 holds 80MB, requests 60MB</li>
<li>P2 holds 70MB, requests 80MB</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><strong>Four conditions for Deadlock</strong></strong></p>
<ul>
<li>Mutual Exclusion<ul>
<li>Only one process may use a resouce at a time</li>
</ul>
</li>
<li>Hold-and-Wait<ul>
<li>Process holds resouce while waiting for another</li>
</ul>
</li>
<li>No Preemption<ul>
<li>Can’t take a resource away from a process</li>
</ul>
</li>
<li>Circular Wait<ul>
<li>The waiting process form a cycle</li>
</ul>
</li>
</ul>
</li>
<li><p>Attack the Deadlock Problem</p>
<ul>
<li>Deadlock prevention<ul>
<li>Make deadlock impossible by removing one (or more)condition</li>
</ul>
</li>
<li>Deadlock Avoidance<ul>
<li>Avoid getting into situations that lead to deadlock</li>
</ul>
</li>
<li>Deadlock Detection<ul>
<li>Don’t try to stop deadlocks</li>
<li>If they happen, detect and resolve</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Attck-the-deadlock"><a href="#Attck-the-deadlock" class="headerlink" title="Attck the deadlock"></a>Attck the deadlock</h2><ol>
<li><p>Deadlock prevention</p>
<ul>
<li>Mutual exclusion -&gt; relax where sharing is possible</li>
<li>Hold-and-Wait -&gt; Get all resources simultaneously (wait until all free)</li>
<li>No preemption -&gt; allow resources to be taken away</li>
<li>Circular wait -&gt; order all the resources, force ordered acquisition</li>
</ul>
</li>
<li><p>Deadlock Avoidance</p>
<ul>
<li>Avoid getting into situations that lead to deadlock<ul>
<li>Selective prevention</li>
<li>Remove condition only when deadlock is possible</li>
</ul>
</li>
<li>Works with incremental resource requests<ul>
<li>Resources are asked for in increments</li>
<li>Do not grant request than can lead to a deadlock</li>
</ul>
</li>
<li>Need maximum resource requirements</li>
<li><p><strong>Banker’s Algorithm</strong></p>
<ul>
<li>Fixed number of processes and resources</li>
<li>System state: either safe or unsafe<ul>
<li>Depends on allocation of resources to processes</li>
</ul>
</li>
<li>Safe: deadlock is absolutely avoidable<ul>
<li>Can avoid deadlock by certain order of execution</li>
</ul>
</li>
<li>Unsafe: deadlock is possible(but not certain)<ul>
<li>May not be able to avoid deadlock</li>
</ul>
</li>
<li><p>Diagram</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/banker_algorithm.png" width="200"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Deadlock Detection (<em>mostly used!</em>)</p>
<ul>
<li><p>Method</p>
<ul>
<li>Periodically try to detect if a deadlock occurred</li>
<li>Do something (or nothing) about it</li>
</ul>
</li>
<li><p>Resoning</p>
<ul>
<li>Deadlocks rarely happen</li>
<li>Cost of prevention or avoidance not worth it</li>
<li>Deal with them in special way (may costly)</li>
</ul>
</li>
<li><p>Recovery from deadlock</p>
<ul>
<li>Terminate all deadlocked process (reboot)</li>
</ul>
</li>
<li>Terminate deadlocked processed one at a time<ul>
<li>need to detect</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]进程间通信-inter process communication(IPC)</title>
    <url>/2020/04/19/inter_process_communication/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面不同进程之间通信的算法和实现。</p>
<a id="more"></a>
<ol>
<li><p>Cooperating Processes and IPC</p>
<ul>
<li><p>Advantage of Cooperating Processes</p>
<ul>
<li>performance: speed<ul>
<li>Exploit inherent parallelism of computation</li>
<li>Allow some parts to proceed why other do I/O</li>
</ul>
</li>
<li>Modularity: resuable self-contained programs<ul>
<li>Each may do a useful task on its own</li>
<li>May also be useful as a sub-task for others</li>
</ul>
</li>
<li><p>Examples:</p>
<p> <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/cooperating_processes_example.png" width="350"></p>
</li>
</ul>
</li>
<li><p>IPC: communication between processes</p>
</li>
<li><strong>IPC requires</strong>:<ul>
<li>data transfer</li>
<li>synchronization</li>
</ul>
</li>
<li><strong>Three abstraction for IPC</strong><ul>
<li>shared memory + semaphores</li>
<li>monitors</li>
<li>message passing</li>
</ul>
</li>
</ul>
</li>
<li><p>The producer/consumer problem</p>
<ul>
<li>Producer produces data, inserts in shared buffer</li>
<li>Consumer removes data from buffer, consumes it</li>
<li>Cooperation: Producer feeds Consumer<ul>
<li>How does data get from producer to consumer?</li>
<li>How does consumer wait for producer?</li>
</ul>
</li>
<li><p>Example:</p>
<p><img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/producer_consumer.png" width="350"></p>
</li>
</ul>
</li>
<li><p>Shared memory + semaphore</p>
<ul>
<li><p>implementation:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shared <span class="keyword">int</span> buf[N], in = <span class="number">0</span>, out = <span class="number">0</span>;</span><br><span class="line">sem filledslots = <span class="number">0</span>, emptyslots = N, mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer1, 2, ...</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  wait (emptyslots); <span class="comment">// wait for available empty slots</span></span><br><span class="line">  wait (mutex); <span class="comment">// avoid racondition</span></span><br><span class="line">  buf[in] = Produce();</span><br><span class="line">  in = (in + <span class="number">1</span>) % N;</span><br><span class="line">  signal(mutex);</span><br><span class="line">  signal(filledslots); <span class="comment">// increment the number of filled slots</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer1, 2, ...</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  wait(filledslot);</span><br><span class="line">  wait(mutex);</span><br><span class="line">  Consume(buf[out]);</span><br><span class="line">  out = (out + <span class="number">1</span>) % N;</span><br><span class="line">  signal(mutex);</span><br><span class="line">  signal(emptyslots);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>work for multiple producers and consumer</p>
</li>
<li>Not easy to understand(many wait/signal statements), easily leads to bugs</li>
</ul>
</li>
<li><p>monitors</p>
<ul>
<li><p>Programming language contruct for IPC</p>
<ul>
<li>monitors are variables requiring controlled access</li>
<li>accessd via procedures</li>
<li>condition variables<ul>
<li>wait(cond)</li>
<li>signal(cond)</li>
</ul>
</li>
</ul>
</li>
<li><p>Only one process can be active inside monitor</p>
</li>
<li><p>Usage</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a possible monitor implementation (provided by programming language)</span></span><br><span class="line">monitor ProducerConsumer &#123;</span><br><span class="line">  <span class="keyword">int</span> buf[N], in = <span class="number">0</span>, out = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">  cond slotavail, itemavail;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PutItem</span> <span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == N) wait(slotavail);</span><br><span class="line">    buf[in] = item;</span><br><span class="line">    in = (in + <span class="number">1</span>) % N;</span><br><span class="line">    count++;</span><br><span class="line">    signal(itemavail);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">GetItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) wait(itemavail);</span><br><span class="line">    item = buf[out];</span><br><span class="line">    out = (out + <span class="number">1</span>) % N;</span><br><span class="line">    count--;</span><br><span class="line">    signal(slotavail);</span><br><span class="line">    <span class="keyword">return</span> (item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  PutItem(Produce());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  Consume(GetItem());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mechanism</p>
<p> <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/monitors.png" width="400"></p>
</li>
<li><p>more on Monitors</p>
<ul>
<li>If one process A siganl condition c while another process B is waiting on c, at that time two process are able to run at the same time, which breaks mutual exclusion. <strong>So each process only signal condition just before returning.</strong></li>
<li><em>Contition variable have no memory</em><ul>
<li>It has no value and only indicate whether an event occurs or not</li>
<li>Signal without someone waiting does nothing</li>
<li>Signal is “lost”</li>
</ul>
</li>
<li>Monitors bring structure to IPC<ul>
<li>localizes critical sections and synchronization</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Message Passing</p>
<ul>
<li><p>Model:</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/Message_Passing.png" width="400"></p>
</li>
<li><p>methods:</p>
<ul>
<li>send(destination, &amp;message)</li>
<li>receive(source, &amp;message)</li>
</ul>
</li>
<li><p>Data transfer: in to and out of kernel message buffer</p>
</li>
<li><p>Synchronization: receive blocks to wait for message</p>
</li>
<li><p>Usage</p>
<ul>
<li><p>basic</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* NO SHARED MEMORY */</span></span><br><span class="line"><span class="comment">// Producer</span></span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">item = Produce();</span><br><span class="line">send(Consumer, &amp;item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer</span></span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">receive(Producer, &amp;item);</span><br><span class="line">Consume(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>with Flow Control</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Producer</span></span><br><span class="line"><span class="keyword">int</span> item, empty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    item = Produce();</span><br><span class="line">    receive (Consumer,&amp;empty);</span><br><span class="line">    send(Consumer, &amp;item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer</span></span><br><span class="line"><span class="keyword">int</span> item, empty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> N times &#123;</span><br><span class="line">    send(Producer, &amp;empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    receive(Producer, &amp;item);</span><br><span class="line">    send(Producer, &amp;empty);</span><br><span class="line">    Consume(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>more on Message Passing</p>
<ul>
<li><p>who should message be addressed to?</p>
<ul>
<li>ports(“mailbox”) rather than specific process</li>
</ul>
</li>
<li><p>how to make process recieve from anyone?</p>
<ul>
<li>pid = receive(*, &amp;message)?</li>
</ul>
</li>
<li>kernel buffering: outstanding message<ul>
<li>message sent that haven’t been received yet</li>
</ul>
</li>
<li>Good praradigm for IPC over networks</li>
<li>Safer than shard memory paradigms</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]同步-synchronization</title>
    <url>/2020/04/19/synchronization/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面进程同步的算法，主要是信号量 (Semaphores) 的使用。</p>
<a id="more"></a>
<h2 id="Problem-introduction"><a href="#Problem-introduction" class="headerlink" title="Problem introduction"></a>Problem introduction</h2><ol>
<li><p>Introduction</p>
<ul>
<li>synchronization: events happen at the same time</li>
<li>Process synchronization<ul>
<li>Events in process that occur “at the same time”</li>
<li>one process have to wait for another</li>
</ul>
</li>
<li>Usage<ul>
<li>prevent race conditions</li>
<li>wait for resources to become available</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>race condition</strong></p>
<ul>
<li>race condition: two process which should run sequently accidentally run at the same time (which cause a bug)</li>
<li>To avoid race conditions:<ul>
<li>identify related <em>critical sections</em><ul>
<li>Section of code excuted by different processes</li>
<li>critical sections must run <em>atomically</em> w.r.t each other</li>
</ul>
</li>
<li>Enforce <em>mutual exclusion</em><ul>
<li>only one process is allowed to be active in critical section</li>
</ul>
</li>
</ul>
</li>
<li><em>Atomic</em><ul>
<li>atomic means “indivisible”</li>
<li>effective atomicity<ul>
<li>interrupt may occur, but it shouldn’t has effect on that section caused by other processes</li>
</ul>
</li>
<li>How to determine wether a critical section is atomic<ul>
<li>Consider effect of critical section in isolation</li>
<li>Consider interruptions: if the result is same, then it is OK.</li>
</ul>
</li>
</ul>
</li>
<li><em>Mutual exclusion</em><ul>
<li>Surrond critical section with entry/exit code</li>
<li>entry code act as a barrier<ul>
<li>if another process is critical section, block current process till it exit</li>
<li>Otherwise, allow process to proceed</li>
</ul>
</li>
<li>Exit code should release other entry barriers</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><strong>Requirements for good solution</strong></strong></p>
<ul>
<li>Given<ul>
<li>multiple cooperating process</li>
<li>each with related critical sections</li>
</ul>
</li>
<li>At most one process in a critical section</li>
<li>Can’t prevent entry if no others in critical section</li>
<li>Should eventually be able to enter critical section</li>
<li>No assumptions about CPU speed or number.</li>
</ul>
</li>
</ol>
<h2 id="Different-approaches-for-mutual-exclusion-workable"><a href="#Different-approaches-for-mutual-exclusion-workable" class="headerlink" title="Different approaches for mutual exclusion (workable)"></a>Different approaches for mutual exclusion (workable)</h2><ol>
<li><p>Peterson’s solution</p>
<ul>
<li><p>implementation</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shared <span class="keyword">int</span> <span class="built_in">turn</span>;</span><br><span class="line">shared <span class="keyword">bool</span> intent[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P0</span></span><br><span class="line">intent[<span class="number">0</span>] = TRUE;</span><br><span class="line"><span class="built_in">turn</span> = <span class="number">1</span>; <span class="built_in">turn</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (intent[<span class="number">1</span>] &amp;&amp; <span class="built_in">turn</span>==<span class="number">1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; critical section &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">intent[<span class="number">0</span>] = FALSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1</span></span><br><span class="line">intent[<span class="number">1</span>] = TRUE;</span><br><span class="line"><span class="keyword">while</span> (intent[<span class="number">0</span>] &amp;&amp; <span class="built_in">turn</span>==<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; critical section &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">intent[<span class="number">1</span>] = FALSE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>if competition occur, take turns, otherwise enter</p>
</li>
<li>for competing process number larger than 2, the solution will become more complex</li>
</ul>
</li>
<li><p>Test-and-Set Lock Instruction: TSL</p>
<ul>
<li><p>requirement: TSL mem</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span> <span class="title">atomically</span> <span class="params">(i.e., locking the memory bus)</span></span></span><br><span class="line">    [test if mem == 0 AND set mem = 1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>a possible C function implementation for TSL (it should be guaranteed atomic)</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TSL(<span class="keyword">int</span> *lockptr) &#123;</span><br><span class="line">    <span class="keyword">int</span> oldval;</span><br><span class="line">    oldval = *lockptr</span><br><span class="line">    *lockptr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((oldval == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mutual exclusion  using TSL</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shared <span class="keyword">int</span> lock = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// P0</span></span><br><span class="line"><span class="keyword">while</span> (! TSL(&amp;lock));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; critical section &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">lock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1</span></span><br><span class="line"><span class="keyword">while</span> (! TSL(&amp;lock));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; critical section &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">lock = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>shared variable solution using TSL(int *)</p>
<ul>
<li>test if lock == 0 (if so, will return 1; else 0)</li>
<li>before returning, sets lock to 1</li>
</ul>
</li>
<li>simple, works for any number of threads</li>
<li>still suffering from busy waiting</li>
</ul>
</li>
<li><p><em>Semaphores</em></p>
<ul>
<li>Synchronization varaible<ul>
<li>takes on integer values (non-negative)</li>
<li>can cause a process to block/unblock</li>
</ul>
</li>
<li>wait and signal operations (<strong>must be atomic, use a lower-level mechanism</strong>)<ul>
<li>wait(s) block if zero, else decrement</li>
<li>signal(s) unblock a process if any, else increment</li>
</ul>
</li>
<li><p>no other operations allowed (<strong>cannot change/test value of semaphore</strong>)</p>
</li>
<li><p>simple, works for n processes</p>
</li>
<li>busy-waiting still exist, but it lies inside semephore, which last shorter</li>
<li><p>Implementation</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait(sem s) &#123;</span><br><span class="line">    s.n = s.n – <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        addProc (me, s.L); <span class="comment">// add process to waiting list</span></span><br><span class="line">        block (me);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(sem s) &#123;</span><br><span class="line">    s.n = s.n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!empty (s.L)) &#123;</span><br><span class="line">        p = removeProc (s.L); <span class="comment">// select a process from waiting list to release</span></span><br><span class="line">        unblock (p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Only synchronization, no information transfer</p>
<ul>
<li>no way for a process to tell it blocked</li>
</ul>
</li>
</ul>
</li>
<li><p>Usage of semaphore</p>
<ul>
<li><p>basic usage example</p>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sem mutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//P0</span></span><br><span class="line">wait(mutex);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; critical section &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">signal(mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1</span></span><br><span class="line">wait(mutex);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; critical section &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">signal(mutex)</span><br></pre></td></tr></table></figure>
</li>
<li><p>order how processes execute</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sem cond = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; to be done before P1 &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">signal(cond);</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1</span></span><br><span class="line">wait(cond);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; to be done after P0 &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]进程调度-scheduling</title>
    <url>/2020/04/19/scheduling/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，第三课主要介绍了操作系统里面进程调度的一些基本算法以及相关的一些分类。</p>
<a id="more"></a>
<h2 id="Basic-problem-and-goal"><a href="#Basic-problem-and-goal" class="headerlink" title="Basic problem and goal"></a>Basic problem and goal</h2><ol>
<li><p>Problem introduction</p>
<ul>
<li>Given multiple processes and one CPU, which process gets CPU and when?</li>
<li>How much CPU time does each process get?</li>
<li>Possible approaches:<ul>
<li>Let one process keep CPU till done then switch to another</li>
<li>Each process uses CPU a bit and passed it on</li>
<li>Ech process gets proportinal to what they pay (demand)</li>
</ul>
</li>
<li>Which policy(ies) is the best?<ul>
<li>Depends on the goals of the system<ul>
<li>Personal computer</li>
<li>Large time-shared computer</li>
<li>computer controlling a nuclear power plant…</li>
</ul>
</li>
<li>Even one system might have multiple(and somtimes conflicting) goals</li>
</ul>
</li>
</ul>
</li>
<li><p>Some parameters needed in scheduling</p>
<ul>
<li>Arrival time: time that process is created</li>
<li>Service time: CPU time needed to complete (most time unknown to the kernel)</li>
<li>Turnaround time: from arrival to departure (actually time needed to finish the process, including running time and waiting time)</li>
<li>Try to minimizes average turnaround time</li>
</ul>
</li>
</ol>
<h2 id="Different-scheduling-policies"><a href="#Different-scheduling-policies" class="headerlink" title="Different scheduling policies"></a>Different scheduling policies</h2><h3 id="Let-one-process-run-till-done-non-preemptive"><a href="#Let-one-process-run-till-done-non-preemptive" class="headerlink" title="Let one process run till done (non-preemptive)"></a>Let one process run till done (non-preemptive)</h3><ol>
<li><p>Consider the service time for each process (suppose each process arrived at the same time)</p>
<ul>
<li><em>Longest first vs shortest first</em>: Let the longest/shortest processes among all the process created and not yet exit to run till done and then decide the next</li>
<li><strong>Proven: Shortest first is optimal</strong></li>
<li>However, the service time is unknown to the kernel in most of the time</li>
</ul>
</li>
<li><p>Consider the arrival time</p>
<ul>
<li><em>First come first serve(FCFS) vs Last come first serve(LCFS)</em>: Allocate the CPU to process arrived earliest or latest.</li>
<li>First come first serve(FCFS)<ul>
<li>non-preemptive, simple, no stavation</li>
<li>poor for short process arrived late</li>
</ul>
</li>
<li>Last come first serve(LCFS)<ul>
<li>simple</li>
<li>starvation, poor for short process arrived early</li>
</ul>
</li>
</ul>
</li>
<li><p>Shortest process next (SPN)</p>
<ul>
<li>when one process finish, select the process with shortest service time</li>
<li><strong>Proven: optimal for non-preemptive policies</strong></li>
<li>may cause starvation (when short process keep arriving, long process get no chance to run)</li>
<li>However, the service time is unknown to the kernel in most of the time</li>
</ul>
</li>
</ol>
<h3 id="Select-process-when-each-quantum-end-preemptive"><a href="#Select-process-when-each-quantum-end-preemptive" class="headerlink" title="Select process when each quantum end (preemptive)"></a>Select process when each quantum end (preemptive)</h3><ol>
<li><p>Round Robin (RR)</p>
<ul>
<li>Time-slice: each process gets quantum in turn</li>
<li>Preemptive, simple, no starvation</li>
<li>Each process waits at most (n - 1) x quantum (supposed n is fixed)</li>
</ul>
</li>
<li><p>Shortest remaing time (SRT)</p>
<ul>
<li>At the end of each quantum, select process with shortest remaining time</li>
<li><strong>Proven: optimal for preemptive policies</strong></li>
<li>may cause starvation (same case as SPN)</li>
<li>Assumes service times are known (which is difficult)</li>
</ul>
</li>
<li><p>Multi-level feedback queues <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/MLFQ.png" width="120" style="float: right;"></p>
<ul>
<li>Priority queues 0 to N (from high to low)</li>
<li>new processes enter queue 0 (highest priority)</li>
<li>Each quantum select from highest priority queue (FIFO within the queue)</li>
<li>For each process selected, run it for $T = 2^k$ quantums<ul>
<li>if the process used T quantums, move it next loewer queue</li>
<li>if the process used less than T quantums, back to same queue<ul>
<li>due to yield or higher priority arrival</li>
</ul>
</li>
</ul>
</li>
<li>Periodically boost (all to the queue 0)</li>
<li>Features:<ul>
<li>Complex, adaptive, highly responsive</li>
<li>Favors shorter over longer, possible starvation (higher priority queue run shorter time)</li>
</ul>
</li>
<li><p>Example</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/MLFQ_example.png" width="320"></p>
</li>
</ul>
</li>
<li><p>Priority scheduling</p>
<ul>
<li>Select process with highest priority</li>
<li>Calculate priority based some external criteria<ul>
<li>E.g., priority = $\frac{1}{CPU_{time used}}$</li>
</ul>
</li>
</ul>
</li>
<li><p>Fair share (Proportional share)</p>
<ul>
<li>Assumed ach process requests ome CPU utilization</li>
<li>Goal: utilization over long run, actual $\approx$ request</li>
<li>Select process with minimum actual/request ratio, when some processes have same minumum ratio, randomly choose one.</li>
<li>involving float number calculation in each quantum, maybe over head.</li>
</ul>
</li>
<li><p>Stride shceduling (practical implementation for Fair share)</p>
<ul>
<li>For each process x with certain CPU utilization requested, calculate strides: $S_x = \frac{1}{R_x}$</li>
<li>For each process x maintain pass value $P_x$ (initialized 0)</li>
<li>In each quantum:<ul>
<li>Select process x with minimum pass value P to run</li>
<li>Increment pass value with selected process by its stride value: $P_x = P_x + S_x$</li>
</ul>
</li>
<li>Optimization: use only intergers for $R_x, S_x, P_x$<ul>
<li>Calucalte $S_x = \frac{L}{R_x}$, where L is very large like 1000000.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Real-Time-Scheduling"><a href="#Real-Time-Scheduling" class="headerlink" title="Real Time Scheduling"></a>Real Time Scheduling</h3><h4 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h4><ul>
<li><p>Reason (correctness) for real-time scheduling</p>
<ul>
<li>depends on logical result of computations</li>
<li>timeing for these result</li>
</ul>
</li>
<li><p>Type of real-time systems</p>
<ul>
<li>hard vs. soft real-time</li>
<li>Periodic vs. aperiodic</li>
</ul>
</li>
</ul>
<h4 id="Type-of-processes"><a href="#Type-of-processes" class="headerlink" title="Type of processes"></a>Type of processes</h4><ul>
<li><p>Periodic Process (Tasks)</p>
<ul>
<li>A periodic process has a fixed frequency at which it needs to run.</li>
<li>Before each deadline it must run for a certain CPU time</li>
<li>For each process with a period, we have C (CPU burst needed), T (period), U (C/T, utilization)</li>
<li><p>Example</p>
<p><img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/PP_exp.png" width="320"></p>
</li>
</ul>
</li>
<li><p>Aperiodic Process</p>
<ul>
<li>Aperiodic processes have no fixed, cyclical, frequency between events.</li>
<li>For this type of process, real-time scheduling is not necessary</li>
</ul>
</li>
</ul>
<h4 id="Different-real-time-Scheduling"><a href="#Different-real-time-Scheduling" class="headerlink" title="Different real-time Scheduling"></a>Different real-time Scheduling</h4><ol>
<li><p>Earliest Deadline First (EDF)</p>
<ul>
<li>schedule process with earliest deadline</li>
<li><em>if a earlier deadline process appears, preempt</em></li>
<li>Pros:<ul>
<li>works for periodic and aperiodic processes</li>
<li>Achieve 100% utilization (igoniring overhead)</li>
</ul>
</li>
<li>Cons:<ul>
<li>Expensive: requires ordering by deadline frequently</li>
</ul>
</li>
<li><p>Example:</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/EDF.png" width="320"></p>
</li>
</ul>
</li>
<li><p>Rate Monotonoic Scheduling (RMS)</p>
<ul>
<li>If periodic processes exist, priorityize based on rates</li>
<li>At start of period, select highest priority</li>
<li>Preempty if necessary</li>
<li>When burst done, wait till next period</li>
<li>Deadline met require:  <strong>$U_1 + … + U_n \leq n (2 ^ {1/n} - 1)$</strong></li>
<li><p>Example:</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/RMS.png" width="320"></p>
</li>
</ul>
</li>
<li><p>More on RMS</p>
<ul>
<li>RMS is simple and efficient (static priority)</li>
<li>RMS is <strong>optimal for static priority algorithms</strong><ul>
<li>if RMS can’t schedule, no other static priority can</li>
</ul>
</li>
<li>RMS is limited in what it guarantees<ul>
<li><strong>Utilization bounded by $n(2^{1/n}-1) &gt; \ln{2}$ ~ 69%</strong></li>
<li>if bounded exceeded, no guarantess (but may not fail)</li>
</ul>
</li>
<li>RMS is limited to periodic processes</li>
</ul>
</li>
</ol>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">scheduling policy</th>
<th style="text-align:left">feature</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FCFS</td>
<td style="text-align:left">very simple, non-preemptive</td>
</tr>
<tr>
<td style="text-align:left">RR</td>
<td style="text-align:left">simple, preemptive</td>
</tr>
<tr>
<td style="text-align:left">SPN</td>
<td style="text-align:left">threoretical, non-preemptive</td>
</tr>
<tr>
<td style="text-align:left">SRT</td>
<td style="text-align:left">threoretical, preemptive</td>
</tr>
<tr>
<td style="text-align:left">MLFQ</td>
<td style="text-align:left">adaptive, reponsive, complex</td>
</tr>
<tr>
<td style="text-align:left">Priority</td>
<td style="text-align:left">external criteria</td>
</tr>
<tr>
<td style="text-align:left">FS</td>
<td style="text-align:left">proportional allocation</td>
</tr>
<tr>
<td style="text-align:left">EDF</td>
<td style="text-align:left">100% utilization, high overhead</td>
</tr>
<tr>
<td style="text-align:left">RMS</td>
<td style="text-align:left">&lt; 100%, low overhead</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]分时系统-timesharing</title>
    <url>/2020/04/19/timesharing/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，第二课主要介绍了分时系统里时间分配的概念，以及内核 (kernel) 和用户 (user) 层面上实现thread的区别以及优缺点。</p>
<a id="more"></a>
<ol>
<li><p>Definition</p>
<ul>
<li>Multiple processes share single CPU resources</li>
<li>Conceptually, each process makes progress over time</li>
<li>Practically, each perioadcally get quantum of CPU time<ul>
<li><em>quantum</em> : a basic time unit for CPU to allocate for a cycle</li>
</ul>
</li>
<li>Illusion of parallel progress by rapidly switching CPU</li>
</ul>
</li>
<li><p>Implementation</p>
<ul>
<li>Kernel keeps track of progress of each process</li>
<li>Divided the states (progress) of each process:<ul>
<li>Running: actually running (making progress), using CPU</li>
<li>Ready: able to make progress, but not using CPU</li>
<li>Blocked: unable to make progress (waiting other resources like memory, I/O etc), cannot use CPU</li>
</ul>
</li>
<li>Kernel selects a ready process and let it use CPU</li>
</ul>
</li>
<li><p>Process State Diagram<img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/process_state_diagram.png" width="220" style="float: right;"></p>
<ul>
<li>Dispatch: allocated the CPU to a process</li>
<li>Preempt: take away CPU from process</li>
<li>Sleep: process gives up CPU to wait for event</li>
<li>Wakeup: event occurred, make process ready</li>
</ul>
</li>
<li><p>Kernel</p>
<ul>
<li>A seperate memory space that store kernel code that support user processes to run<ul>
<li>systems calls: fork(), exit(), read(), write(), yield(),…</li>
<li>management: context switching, scheduling,…</li>
</ul>
</li>
<li>Keep track of state of each process<ul>
<li>each process has a unique ID</li>
</ul>
</li>
<li>Store other info needed<ul>
<li>areas of memory being used</li>
<li>contents of CPU contexts</li>
<li>other…</li>
</ul>
</li>
<li>runs as an extension of current process<ul>
<li>when system call (process give up control to kernel voluntarily)</li>
<li>hardware interrupt (preemption)<ul>
<li>timer</li>
</ul>
</li>
</ul>
</li>
<li><p>Has text, data and multiple stack (each for each process/thread)</p>
<ul>
<li><p>even if two process share the same code, use seperate memory(text, data, stack) to store state of each process</p>
<p><img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/multi_process_kernel.png" width="450"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Threads</p>
<ul>
<li>It’s a single sequential path of execution</li>
<li>Abstraction: independent of memory(may have different implementation like user-level and kernel-level)</li>
<li>A thread is a part of a process<ul>
<li>Lives in the memory of a process (share global variable)</li>
<li>Multiple threads may exist in a process</li>
</ul>
</li>
<li>To the user: unit of parallelism</li>
<li>To the kernel: unit of schedulability</li>
</ul>
</li>
<li><p>User-level threads vs Kernel-level threads</p>
<ul>
<li><p>user-level thread:</p>
<ul>
<li>Implement stacks for different threads in user space (actually share the stack in kernel)</li>
<li>Pros:<ul>
<li>Threads call and management in user level</li>
<li>Efficient: no need to trapped into kernel (which is heavy)</li>
<li>No need for kenerl support of threads</li>
</ul>
</li>
<li><p>Cons:</p>
<ul>
<li>no true parallelism (kernel see no threads but process)</li>
<li><p>mulitple CPU cannot let multiple threads in one process run at the same time</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/user_threads.png" width="450"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>kernel-level thread:</p>
<ul>
<li>Implement stacks for different threads in kernel space</li>
<li>Pros:<ul>
<li>can achieve true prallelism</li>
</ul>
</li>
<li><p>Cons:</p>
<ul>
<li><p>overhead: thread switch requires kernel call</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/kernel_thread.png" width="450"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Distinguish:</p>
<ul>
<li>Where is the thread abstraction supported: kernel code or user code</li>
<li>Where is the thread running: user space or kernel space</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]进程-process</title>
    <url>/2020/04/19/process/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，第一课主要介绍了操作系统以及进程的一些基本概念。</p>
<a id="more"></a>
<ol>
<li><p>Definition</p>
<ul>
<li>Abstraction of a running program (<em>dynamic</em>)</li>
<li>While program is just static code</li>
</ul>
</li>
<li><p>Resources</p>
<ul>
<li>CPU<ul>
<li>Processing cycles (CPU time)</li>
<li>Execute intstructions</li>
</ul>
</li>
<li>Memory<ul>
<li>Bytes or words</li>
<li>maintain state</li>
</ul>
</li>
<li>Other resources (I/O)</li>
</ul>
</li>
<li><p><strong>Context of a Process (machine and kernel-related state)</strong></p>
<ul>
<li>CPU context<ul>
<li>PC (program counter)</li>
<li>SP (stack pointer)</li>
<li>FP (frame pointer)</li>
<li>GP (general pointer)</li>
</ul>
</li>
<li>Memory context<ul>
<li>program code</li>
<li>static variables(init, uninit)</li>
<li>heap</li>
<li>shared memory</li>
<li>stack of activation records</li>
</ul>
</li>
<li>Other (kernel-related state, …)</li>
</ul>
</li>
<li><p>Process memory structure <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/process%20memory.png" width="120" style="float: right;"></p>
<ul>
<li>Text area: code (program instruction)</li>
<li>Data<ul>
<li>Global variable</li>
<li>Static variable (local and global)</li>
<li>Heap</li>
</ul>
</li>
<li>Stack<ul>
<li>Activation records</li>
<li>Automatic growth/shrinkage</li>
</ul>
</li>
</ul>
</li>
<li><p>Process stack <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/process%20stack.png" width="180" style="float: right;"></p>
<ul>
<li>Stack of activation records</li>
<li>An activation records stores:<ul>
<li>return address</li>
<li>link to previous record</li>
<li>local varibale</li>
<li>other</li>
</ul>
</li>
<li>Stack pointer points to top</li>
</ul>
</li>
<li><p>Multi-Processes</p>
<ul>
<li>Goal: support several processes running “simultaneously” or let one process intentionally yield to another process</li>
<li>Method: Context switching<ul>
<li>Switch process A (running) to process B (waiting) while store context (state) of process A (since it’s not finished)</li>
<li>process<ul>
<li>save context of current process<ul>
<li>save GP</li>
<li>save SP</li>
<li>save PC</li>
</ul>
</li>
<li>load context of next process<ul>
<li>load GP</li>
<li>load SP</li>
<li><strong>load PC (must be last, once PC is loaded, the process B begins to run (PC indicates instruction execution))</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>常用资源工具整理</title>
    <url>/2020/04/19/%E5%B8%B8%E7%94%A8%E8%B5%84%E6%BA%90%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="博客-amp-主题配置-（Hexo）"><a href="#博客-amp-主题配置-（Hexo）" class="headerlink" title="博客 &amp; 主题配置 （Hexo）"></a>博客 &amp; 主题配置 （Hexo）</h2><ul>
<li><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty" target="_blank" rel="noopener">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a><br> 视频讲解建立hexo博客以及部署到github pages上，需要注意下建立博客的过程最好不用root模式，只需要用chown改变npm的权限就可以了，不然后续写博客可能比较麻烦</p>
</li>
<li><p><a href="https://www.zyjdn.com/2020/02/05/Hexo-NexT%E4%B8%BB%E9%A2%98/" target="_blank" rel="noopener">Hexo-NexT主题</a><br> 这篇文章和博主的后续几篇主要包括hexo-next主题（目前更新到next版本7.0+）里面的基础配置</p>
</li>
<li><p><a href="https://blog.csdn.net/maosidiaoxian/article/details/85220394" target="_blank" rel="noopener">如何在Hexo中对文章md文件分类</a><br> 利用 post 的 permalink 属性和 hexo 的 new_post_name 实现按日期文件夹（按年或者按月）归类文章</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/111614119" target="_blank" rel="noopener">Github + Hexo 搭建个人博客超详细教程</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/111796666" target="_blank" rel="noopener">Hexo 双线部署到 Coding 和 GitHub 提升访问速度</a><br> 这两篇主要参考github和coding双线部署以及域名绑定</p>
</li>
<li><p><a href="https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">hexo - Next 主题添加评论功能</a><br> 添加评论功能</p>
</li>
<li><p><a href="https://www.yanlongwang.net/website/statistics-visitor-traffic/" target="_blank" rel="noopener">How to configure visitor traffic for a Hexo website / 如何统计 Hexo 网站的访问地区和IP</a><br> 配置clustrmaps.com查看访问者分布</p>
</li>
<li><p><a href="https://github.com/DesertsP/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a><br> 结合Valine进行评论管理和通知</p>
</li>
</ul>
<h2 id="zsh相关"><a href="#zsh相关" class="headerlink" title="zsh相关"></a>zsh相关</h2><ul>
<li><p><a href="https://www.zhihu.com/question/21418449" target="_blank" rel="noopener">zsh基本配置</a><br> zshrc基本配置，主要用了antigen管理插件和prezto管理prompt</p>
</li>
<li><p><a href="https://mikebuss.com/2014/04/07/customizing-prezto/" target="_blank" rel="noopener">Customizing Your Prezto Prompt</a><br> 选择prezto主题</p>
</li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>轮式里程计运动模型及标定</title>
    <url>/2020/04/18/%E8%BD%AE%E5%BC%8F%E9%87%8C%E7%A8%8B%E8%AE%A1%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%A0%87%E5%AE%9A/</url>
    <content><![CDATA[<p>本文是我在学习深蓝学院的激光slam第二课的学习笔记，这一课主要介绍了两轮差分底盘的运动模型以及怎么对里程计数据进行校正。</p>
<a id="more"></a>
<h2 id="轮式里程计模型"><a href="#轮式里程计模型" class="headerlink" title="轮式里程计模型"></a>轮式里程计模型</h2><h3 id="两轮差分底盘的运动学模型"><a href="#两轮差分底盘的运动学模型" class="headerlink" title="两轮差分底盘的运动学模型"></a>两轮差分底盘的运动学模型</h3><ol>
<li><p>优点</p>
<ul>
<li>结构简单</li>
<li>便宜，只需要两个电机（驱动器）</li>
<li>模型简单，并且可以实现任何轨迹跟踪</li>
</ul>
</li>
<li><p>差分模型及运动解算</p>
 <img src="/2020/04/18/%E8%BD%AE%E5%BC%8F%E9%87%8C%E7%A8%8B%E8%AE%A1%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%A0%87%E5%AE%9A/diffence_model.png" class="" title="2-wheel-odometry-model-calibration&#x2F;diffence_model.png">
<ul>
<li>考虑两轮在做半径为r的圆周运动，v和w是底盘中心的线速度和角速度，$v_{L/R}$ 和 $\omega_{L/R}$ 分别对应左/右轮子的线速度和角速度，d为底盘中心离两侧轮子的距离，b为两轮之间的距离（b = 2d）</li>
<li>目标：根据两轮的角速度（编码器测出的数据）以及其他参数求出底盘中心（机器人）运动的线速度v和角速度w</li>
<li><p>求解：</p>
<ul>
<li><p>根据两轮绕圆周中心的角速度相等：</p>
<script type="math/tex; mode=display">\frac{v_L}{r - d} = \frac{v_R}{r + d}</script><script type="math/tex; mode=display">\rightarrow v_L(r + d) = v_R(r - d)</script><script type="math/tex; mode=display">\rightarrow (v_L - v_R)r = (v_R + v_L)d</script><script type="math/tex; mode=display">\rightarrow r = \frac{v_R + v_L}{v_R - v_L}d</script></li>
<li><p>因此，</p>
<script type="math/tex; mode=display">r + d = \frac{v_R + v_L}{v_R - v_L}d + d = 2\frac{v_R}{v_R - v_L}d</script></li>
<li><p>根据底盘中心和两轮角速度相等：</p>
<script type="math/tex; mode=display">\omega = \frac{v_R}{r + d} = \frac{v_R - v_L}{2d}</script></li>
<li><p>根据$v = \omega r$</p>
<script type="math/tex; mode=display">\omega = \frac{\omega_Rr_R - \omega_Lr_L}{2d}</script><script type="math/tex; mode=display">v = \omega r = \frac{v_R - v_L}{2d}\frac{v_R + v_L}{v_R - v_L}d = \frac{v_R + v_L}{2} = \frac{\omega_Rr_R + \omega_Lr_L}{2}</script></li>
<li><p>整理得</p>
<script type="math/tex; mode=display">\begin{bmatrix}v \\ \omega\end{bmatrix} = \begin{bmatrix} \frac{r_L}{2} & \frac{r_R}{2} \\ -\frac{r_L}{b} & \frac{r_R}{b}\end{bmatrix}\begin{bmatrix}\omega_L \\ \omega_R\end{bmatrix} = J\begin{bmatrix}\omega_L \\ \omega_R\end{bmatrix}</script></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="轨迹推算（Dead-Reckoning）"><a href="#轨迹推算（Dead-Reckoning）" class="headerlink" title="轨迹推算（Dead Reckoning）"></a>轨迹推算（Dead Reckoning）</h3><ol>
<li><p>示意图</p>
 <img src="/2020/04/18/%E8%BD%AE%E5%BC%8F%E9%87%8C%E7%A8%8B%E8%AE%A1%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%A0%87%E5%AE%9A/dead_reckoning.png.png" class="" title="2-wheel-odometry-model-calibration&#x2F;dead_reckoning.png.png">
</li>
<li><p>递推公式</p>
<ul>
<li><p>假设</p>
<ul>
<li>当前位姿（世界坐标系下）为$(x, y, \theta)$</li>
<li>运动增量（车体坐标系下）为$(dx, dy, d\theta)$</li>
</ul>
</li>
<li><p>求解更新后的位姿</p>
<script type="math/tex; mode=display">\begin{bmatrix}x \\ y \\ \theta\end{bmatrix}=\begin{bmatrix}x \\ y \\ \theta\end{bmatrix} + \begin{bmatrix}\cos{\theta} & -\sin{\theta} & 0 \\ \sin{\theta} & \cos{\theta} & 0 \\ 0 & 0 & 1\end{bmatrix}\begin{bmatrix}dx \\ dy \\ d\theta\end{bmatrix}</script></li>
<li><p><em>加入噪声后</em></p>
<script type="math/tex; mode=display">\begin{bmatrix}x \\ y \\ \theta\end{bmatrix}=\begin{bmatrix}x \\ y \\ \theta\end{bmatrix} + \begin{bmatrix}\cos{\theta} & -\sin{\theta} & 0 \\ \sin{\theta} & \cos{\theta} & 0 \\ 0 & 0 & 1\end{bmatrix}\begin{bmatrix}dx + \epsilon_x \\ dy + \epsilon_y \\ d\theta + \epsilon_\theta\end{bmatrix}</script></li>
<li><p>噪声会随时间积累，所以dead reckoning精度会越来越低</p>
</li>
</ul>
</li>
</ol>
<h2 id="轮式里程计标定"><a href="#轮式里程计标定" class="headerlink" title="轮式里程计标定"></a>轮式里程计标定</h2><h3 id="线性最小二乘的基本概念"><a href="#线性最小二乘的基本概念" class="headerlink" title="线性最小二乘的基本概念"></a>线性最小二乘的基本概念</h3><ul>
<li><p>求解线性方程组 $Ax = b$，其中</p>
<ul>
<li>$A$ 为 $m\times n$ 的矩阵</li>
<li>$x$ 为 $n\times 1$ 的向量</li>
<li>当 $m &gt; n$ 时为超定方程组，方程组无解。实际情况中进行slam时移动机器人约束条件远远多于状态维度，通常为此种情况，此时需要求解最小二乘解</li>
</ul>
</li>
<li><p>最小二乘解</p>
<p>  $x^*=(A^TA)^{-1}A^Tb$</p>
</li>
</ul>
<h3 id="线性最小二乘在里程计标定中的应用"><a href="#线性最小二乘在里程计标定中的应用" class="headerlink" title="线性最小二乘在里程计标定中的应用"></a>线性最小二乘在里程计标定中的应用</h3><ol>
<li><p>主要方法包括：</p>
<ul>
<li>直接线性方法：通用性强，实现简单，精度不高（因此实际中比较少直接使用）</li>
<li>基于模型的方法：精度高，实现复杂，特异性强（实际中较多使用）</li>
</ul>
</li>
<li><p>直接线性方法</p>
<ul>
<li>用激光雷达的scan-match数据作为真值$u_i^*$</li>
<li>里程计测量数据为$u_i$</li>
<li><p>假设两者成线性关系$u_i^* = Xu_i$，其中：</p>
<p>  $X = \begin{bmatrix}x_{11} &amp; x_{12} &amp; x_{13} \\x_{21} &amp; x_{22} &amp; x_{23} \\x_{31} &amp; x_{32} &amp; x_{33}\end{bmatrix}$</p>
</li>
<li>标定过程就是求解$X$的过程（如何矫正里程计测量数据）</li>
<li><p>对于每一组数据，有以下关系：</p>
<script type="math/tex; mode=display">\begin{aligned}u_{ix}x_{11} + u_{iy}x_{12} + u_{i\theta}x_{13} = u_{ix}^* \\ u_{ix}x_{21} + u_{iy}x_{22} + u_{i\theta}x_{23} = u_{iy}^* \\ u_{ix}x_{31} + u_{iy}x_{32} + u_{i\theta}x_{33} = u_{i\theta}^*\end{aligned}</script></li>
<li><p>写成矩阵形式有：</p>
<script type="math/tex; mode=display">\begin{bmatrix}u_{i_x} & u_{iy} & u_{i\theta} & 0 & 0 & 0& 0 & 0 & 0\\ 0 & 0 & 0 &u_{i_x} & u_{iy} & u_{i\theta}& 0 & 0 & 0\\0 & 0 & 0& 0 & 0 & 0 &u_{i_x} & u_{iy} & u_{i\theta}\end{bmatrix}\begin{bmatrix}x_{11}\\x_{12}\\ ... \\ x_{33}\end{bmatrix} = \begin{bmatrix}u^*_{ix} \\ u^*_{iy} \\ u^*_{i\theta}\end{bmatrix}</script><script type="math/tex; mode=display">\rightarrow A_i\vec{X} = b_i</script></li>
<li><p>对于所有n个数据点有：</p>
<script type="math/tex; mode=display">A = \begin{aligned}A_1 \\ ...\\ A_n\end{aligned}</script><script type="math/tex; mode=display">b = \begin{aligned}
      b_1 \\ ... \\ b_n
  \end{aligned}</script></li>
<li><p>此时可以用最小二乘求解</p>
</li>
</ul>
</li>
<li><p>基于模型方法</p>
<ul>
<li><p>运动学模型</p>
<script type="math/tex; mode=display">\begin{bmatrix}v \\ \omega\end{bmatrix} = \begin{bmatrix} \frac{r_L}{2} & \frac{r_R}{2} \\ -\frac{r_L}{b} & \frac{r_R}{b}\end{bmatrix}\begin{bmatrix}\omega_L \\ \omega_R\end{bmatrix} = J\begin{bmatrix}\omega_L \\ \omega_R\end{bmatrix} = \begin{bmatrix}J_{11} & J_{12} \\ J_{21} & J_{22}\end{bmatrix}</script><ul>
<li><p>知道 $v$ 和 $\omega$ 之后，可以根据采样时间积分求得机器人状态 $(x(t), y(t), \theta(t))$：</p>
<script type="math/tex; mode=display">\begin{aligned}
  \theta(t) &= \int\omega(t)dt \\
  x(t) &= \int v(t)\cos{(\theta(t))}dt \\
  y(t) &= \int v(t)\sin{(\theta(t))}dt
  \end{aligned}</script></li>
</ul>
</li>
<li><p>根据匀速运动假设（采样时间内机器人保持匀速运动），及运动学模型有：</p>
<script type="math/tex; mode=display">\begin{aligned}
  \omega(t) = \omega = J_{21}\omega_{L} + J_{22}\omega_{R} \\
  v(t) = v = J_{11}\omega_{L} + J_{12}\omega_{R}
  \end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}
  J_{11} &= -\frac{b}{2}J_{21} \\
  J_{12} &= \frac{b}{2}J_{22}
  \end{aligned}</script><script type="math/tex; mode=display">\rightarrow v(t) = v = \frac{b}{2}(-J_{21}\omega_{L} + J_{22}\omega_{R})</script></li>
<li><p><em>已知两轮的角速度 $\omega_L$ 和 $\omega_R$，需要求解两轮半径（$r_L$ 和 $r_R$）和两轮之间的距离 $b$</em></p>
</li>
<li><p>基本过程：</p>
<ul>
<li>假设激光雷达位于车体的正中心</li>
<li>激光雷达的匹配值作为观测值</li>
<li>里程计的积分值作为预测值</li>
<li>_通过最小化预测值和观测值的差即可得到里程计的参数_</li>
<li>里程计的积分值用$r_x$ , $r_y$ , $r_θ$ 表示，激光雷达的匹配值用 $s_x$ , $s_y$ , $s_θ$ 表示</li>
</ul>
</li>
</ul>
</li>
<li><p>具体求解过程</p>
<ul>
<li><p>角度积分表达式(单一时间数据点)</p>
<script type="math/tex; mode=display">\begin{aligned} r_\theta(t) &=
   \int \omega(t)dt = \int J_{21}\omega_{L} + J_{22}\omega_Rdt \\
    r_\theta(t) &= (\omega_L\Delta T \:\:\: \omega_R\Delta T)(\begin{aligned}J_{21} \\J_{22}\end{aligned}) = s_\theta
   \end{aligned}</script><script type="math/tex; mode=display">\rightarrow A_0 J_2 = s_{\theta 0}</script></li>
<li><p>结合所有时间数据点可以求解 $Ax = b$，可以求得 $J_{21}$ 和 $J_{22}$</p>
</li>
<li><p>在已知 $J_{21}$ 和 $J_{22}$ 的情况下，对里程计的位置积分可以表示成与参数b成线性关系（$\cos\theta_t$ 的积分可求）：</p>
<script type="math/tex; mode=display">\begin{aligned}
  r_x(t) &= \int v(t) \cos{(\theta(t))} dt \\
  &= \frac{b}{2}(-J_{21}\omega_{L} + J_{22}\omega_{R})\int \cos{(\theta(t))} dt \\
  &= c_x b  = s_x\\
  r_y(t) &= \int v(t) \sin{(\theta(t))} dt \\
  &= \frac{b}{2}(-J_{21}\omega_{L} + J_{22}\omega_{R})\int \sin{(\theta(t))} dt \\
  &= c_y b = s_y
  \end{aligned}</script></li>
<li><p>通过罗列所有时间点的约束方程，可以通过最小二乘求解两轮距离 $b$</p>
</li>
<li><p>已知 $b, J_{21}, J_{22}$ 可以求得:</p>
<script type="math/tex; mode=display">r_L = -J_{21}b</script><script type="math/tex; mode=display">r_R = J_{22}b</script></li>
<li><p>至此轮式里程计标定完毕</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>激光slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>lidar-slam</tag>
      </tags>
  </entry>
  <entry>
    <title>激光slam介绍及相关数学基础</title>
    <url>/2020/04/18/%E6%BF%80%E5%85%89slam%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文是我在学习深蓝学院的激光slam第一课的学习笔记，这一课主要介绍了2d和3d的激光slam的一些基本概念，以及需要的一些数学基础。</p>
<a id="more"></a>
<h2 id="激光slam介绍"><a href="#激光slam介绍" class="headerlink" title="激光slam介绍"></a>激光slam介绍</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ol>
<li><p>输入</p>
<ul>
<li>里程计数据（odometry）：正常来说都会有，因为slam一般配备在移动机器人、无人车，在一些特殊场景可能没有（手持设备）</li>
<li>2d/3d激光雷达扫描结果：必须要有，在2dslam的情况下一般是单线的</li>
<li>IMU： 一般是可选的，可以没有</li>
</ul>
</li>
<li><p>输出</p>
<ul>
<li>3d点云地图：3dslam输出，在导航的时候会转成覆盖栅格地图进行导航</li>
<li>覆盖栅格地图（occupancy-grid map）：将环境分割成对栅格并输出每个栅格是否可通行</li>
<li>轨迹(trajectory) 或姿态（pose graph）</li>
</ul>
</li>
<li><p>帧间匹配方法（2d）</p>
<ul>
<li>PL-ICP(Point-to-line ICP)：利用<strong>点到线</strong>的距离做误差计算，相对于点到点的方法更加符合室内结构化场景，但比较依靠初始解</li>
<li>CSM(Correlation Scan Match)：<strong>暴力枚举</strong>所有可能的状态进行匹配相关性计算，取最优结果，（通过一定优化可以减少计算时间）</li>
<li>Optimization-Based：将地图空间看成解空间，依赖<strong>地图状态的梯度</strong>通过迭代求解，能方便引入额外约束，同样依赖初始解</li>
<li>实际常用 CSM + 梯度优化的方法，（也可以用 CSM + PL-ICP, 但是需要实际场景中有比较多结构化线段）</li>
</ul>
</li>
<li><p>帧间匹配方法（3d）</p>
<ul>
<li>Point-to-Plane ICP：用点到面的距离作误差匹配</li>
<li>Plane-to-Place ICP (GCIP): 面到面的距离</li>
<li>NDT：划分网格拟合高斯分布，因为计算速度快所以在3d场景用得多一点</li>
<li>NICP：在icp的基础上引入法向量信息（normal），角度精度较高</li>
<li>IMLS-ICP：对点云进行局部曲面拟合</li>
<li>Feature-based Method：参考视觉slam，提取特征点和描述子进行特征匹配，3d激光扫描结果信息量较多，所以可以使用</li>
</ul>
</li>
<li><p>回环检测方法</p>
<ul>
<li>Scan-to-Map</li>
<li>Map-to-Map</li>
<li>Branch and Bound &amp; Lazy Decision (延迟检测)：由于2d 激光slam对环境数据量太少，很容易造成不同场景结果相似，导致出现错误的回环，延迟检测的方法是只有在检测到<strong>多个回环</strong>的情况下并且回环都一致的时候才认为出现回环</li>
</ul>
</li>
</ol>
<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><ol>
<li><p>Filtered-based (滤波方法，目前在2d激光slam（主要是建图）已经很少使用，因为滤波方法更关注当前状态（位置），对历史信息不修正（没有回环的概念），所以不利于利用全局数据进行建图，在定位（VO，VIO等）用的较多)</p>
<ul>
<li>EKF-SLAM (1990s): 随环境增大状态量会急剧增大</li>
<li>FastSLAM (02~03)：粒子滤波，每个粒子携带一个地图</li>
<li>Gmapping (07): FastSLAM的升级版本</li>
<li>Optimal RBPF (10)：Gmapping的基础上进一步优化</li>
</ul>
</li>
<li><p>Graph-based (图优化方法)</p>
<ul>
<li>Karto-SLAM (10)：基于优化的方案（CSM + SPA）</li>
<li>Cartographer (16)：原理和Karto一样，用ceres实现，相对更完整</li>
</ul>
</li>
</ol>
<h3 id="实际应用中注意的问题"><a href="#实际应用中注意的问题" class="headerlink" title="实际应用中注意的问题"></a>实际应用中注意的问题</h3><ol>
<li><p><strong>数据预处理 (Preprocess)</strong></p>
<ul>
<li>轮式里程计标定，最好能到0.3%左右</li>
<li>激光雷达运动畸变（扫描过程中雷达的位置变化）</li>
<li>不同系统之间的时间同步（当每个传感器连接到不同处理器（cpu）上的时候系统时间可能会不一致，这个时候需要考虑时间同步获得统一时间戳）</li>
</ul>
</li>
<li><p>实际环境的问题（大部分可以通过和视觉融合来解决）</p>
<ul>
<li><p>动态物体、环境变化</p>
<ul>
<li>高动态：移动中的人，车</li>
<li>低动态：物体被移动（椅子，箱子），频率低</li>
</ul>
</li>
<li><p>几何结构相似环境：走廊等，容易发生状态退化，在3d的情况下则是比较空旷的区域，大部分点云无效导致环境退化</p>
</li>
<li>建图的操作复杂</li>
<li>全局定位</li>
<li>地面材质变化、地面凹凸不平、机器人载重变化：会造成里程计数据误差（间接改变了轮子直径）</li>
</ul>
</li>
</ol>
<h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><ol>
<li><p>位姿和转换矩阵（pose &amp; transformation matrix）</p>
<ul>
<li>假设机器人B在坐标系O中的坐标表示为 $(x, y, \theta)$</li>
<li><p>则坐标系B到坐标系O的转换矩阵为：</p>
<script type="math/tex; mode=display">T_{OB} = \begin{bmatrix}\cos{\theta} & -\sin{\theta} & x \\ \sin{\theta} & \cos{\theta} & y\\ 0 & 0 & 1 \end{bmatrix} = \begin{bmatrix}R & t \\ 0 & 1 \end{bmatrix}</script> <img src="/2020/04/18/%E6%BF%80%E5%85%89slam%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/transformation_matrix.png" class="" title="1-intro-math-basics&#x2F;transformation_matrix.png">
</li>
</ul>
</li>
<li><p>不同机器人坐标系转换</p>
<ul>
<li><p>机器人A和机器人B的坐标转换</p>
<script type="math/tex; mode=display">T_{AB} = T_{AO}T_{OB} = T_{OA}^{-1}T_{OB}</script></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>激光slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>lidar-slam</tag>
      </tags>
  </entry>
</search>

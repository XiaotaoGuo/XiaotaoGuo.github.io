<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 中 std::thread 的基本用法</title>
    <url>/2020/07/19/cpp_threads_usage/</url>
    <content><![CDATA[<p>C++11 中引入了 std::thread 可以比较方便的创建和管理多线程，这篇笔记主要简单记录了一下我的学习过程。包括线程的创建的管理还有在类中相关的用法。</p>
<a id="more"></a>
<h2 id="requirement"><a href="#requirement" class="headerlink" title="requirement"></a>requirement</h2><p>为了使用 <code>std::thread</code> 我们需要添加 <code>&lt;thread&gt;</code> 作为头文件，同时如果使用 <code>cmake</code> 进行项目编译管理的话，需要添加以下两行进行相关库的链接，然后就可以使用：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span> (Threads)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">add your executable</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span> (your_project_name <span class="variable">$&#123;CMAKE_THREAD_LIBS_INIT&#125;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="basic-usage"><a href="#basic-usage" class="headerlink" title="basic usage"></a>basic usage</h2><p><code>std::thread</code> 的使用比较简单，直接通过构造函数可以创建一个线程，有需要的话也可以传入参数，见以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参数函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A thread function!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooWithName</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> func_name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A thread function with name: "</span> &lt;&lt; func_name &lt;&lt; <span class="string">"!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(foo)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(fooWithName, <span class="string">"FuncName"</span>)</span></span>;</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">A thread function!</span><br><span class="line">A thread function with name: FuncName!!</span><br></pre></td></tr></table></figure>
<h2 id="join-vs-detach"><a href="#join-vs-detach" class="headerlink" title="join() vs detach()"></a>join() vs detach()</h2><p>可以看到，上面代码例子中创建的两个线程后都增加了一条 <code>join()</code> 方法，这是因为通过 <code>std::thread</code> 创建的线程默认下并不是独立于主线程 （<code>main()</code>）的，如果不加 <code>join()</code> 的话，当主线程退出之后子线程也会报错并退出，见如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooWithTime</span><span class="params">(<span class="keyword">int</span> n_seconds, <span class="built_in">std</span>::<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_seconds; i++) &#123;</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt;<span class="string">" Thread: worked for "</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" seconds.."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(fooWithTime, <span class="number">5</span>, <span class="string">"Child"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    fooWithTime(<span class="number">3</span>, <span class="string">"Main"</span>);</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Main thread exit! "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>由于在 <code>main</code> 函数最后加入 <code>t1.join()</code> 所以在主函数输出 3 秒之后会等到 子线程工作完返回时才退出，输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Main Thread: worked for 1 seconds..</span><br><span class="line">Child Thread: worked for 1 seconds..</span><br><span class="line">Main Thread: worked for 2 seconds..</span><br><span class="line">Child Thread: worked for 2 seconds..</span><br><span class="line">Main Thread: worked for 3 seconds..</span><br><span class="line">Child Thread: worked for 3 seconds..</span><br><span class="line">Child Thread: worked for 4 seconds..</span><br><span class="line">Child Thread: worked for 5 seconds..</span><br><span class="line">Main thread exit!</span><br></pre></td></tr></table></figure>
<p>如果把 <code>t1.join()</code> 去掉之后，输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Main Thread: worked for 1 seconds..</span><br><span class="line">Child Thread: worked for 1 seconds..</span><br><span class="line">Child Thread: worked for 2 seconds..</span><br><span class="line">Main Thread: worked for 2 seconds..</span><br><span class="line">Child Thread: worked for 3 seconds..</span><br><span class="line">Main Thread: worked for 3 seconds..</span><br><span class="line">Main thread exit!</span><br><span class="line">terminate called without an active exceptionn</span><br></pre></td></tr></table></figure>
<p>可以看到在主线程退出之后，子线程也被强制退出了，如果想让子线程独立于主线程的话，需要加入<code>detach()</code></p>
<p>代码和输出如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooWithTime</span><span class="params">(<span class="keyword">int</span> n_seconds, <span class="built_in">std</span>::<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_seconds; i++) &#123;</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt;<span class="string">" Thread: worked for "</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" seconds.."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(fooWithTime, <span class="number">5</span>, <span class="string">"Child"</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    fooWithTime(<span class="number">3</span>, <span class="string">"Main"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Main thread exit! "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Main Thread: worked <span class="keyword">for</span> 1 seconds..</span><br><span class="line">Child Thread: worked <span class="keyword">for</span> 1 seconds..</span><br><span class="line">Main Thread: worked <span class="keyword">for</span> 2 seconds..</span><br><span class="line">Child Thread: worked <span class="keyword">for</span> 2 seconds..</span><br><span class="line">Main Thread: worked <span class="keyword">for</span> 3 seconds..</span><br><span class="line">Main thread <span class="built_in">exit</span>!</span><br></pre></td></tr></table></figure>
<p>可以发现，我们虽然 detach 了子线程，但是从输出上来看在主线程退出之后子线程也没有输出了，这是因为在子线程 detach 了之后，主线程退出的同时主进程也同时退出了，而我们运行进程时只能看到该进程的输出，所以就看不到 <code>detach</code> 后的线程的输出了。值得注意的是一旦线程被detach 之后就不能再进行 <code>join</code> 操作了，所以对 <code>detach</code> 的使用需要谨慎一点，并且在对一个线程进行 <code>join</code> 之前，应该通过 <code>joinable()</code> 进行判断。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooWithTime</span><span class="params">(<span class="keyword">int</span> n_seconds, <span class="built_in">std</span>::<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_seconds; i++) &#123;</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt;<span class="string">" Thread: worked for "</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" seconds.."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(fooWithTime, <span class="number">5</span>, <span class="string">"Child"</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t1.joinable()) &#123;</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread unjoinable!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fooWithTime(<span class="number">3</span>, <span class="string">"Main"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Main thread exit! "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="threads-with-class"><a href="#threads-with-class" class="headerlink" title="threads with class"></a>threads with class</h2><p>在实际使用中，我们的项目通过使用了各种类，下面代码演示了如何把类和 <code>std::thread</code> 结合使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> class_param;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">funcWithoutParam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"non-static func: class param: "</span> &lt;&lt; class_param &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">funcWithParam</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> external_param)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"non-static func: class param: "</span> &lt;&lt; class_param &lt;&lt; <span class="string">", external param: "</span> &lt;&lt; external_param &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_func</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> param)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"static func: param: "</span> &lt;&lt; param &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.class_param = <span class="string">"Apple"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(&amp;A::funcWithoutParam, a)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(&amp;A::funcWithParam, a, <span class="string">"banana"</span>)</span></span>;</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t3</span><span class="params">(&amp;A::static_func, <span class="string">"Cherry"</span>)</span></span>;</span><br><span class="line">    t3.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Main thread exit! "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">non-static func: class param: Apple</span><br><span class="line">non-static func: class param: Apple, external param: banana</span><br><span class="line">static func: param: Cherry</span><br><span class="line">Main thread exit!</span><br></pre></td></tr></table></figure>
<p>上面包含了三种用法：</p>
<ul>
<li>如果传入线程的函数是类中的 <code>static</code> 函数，可以直接传入函数指针和相关的参数，主要这里的函数比如显示地用 <code>&amp;</code> 进行传入；</li>
<li>如果传入线程的函数是 <code>non-static</code> 函数，我们还必须要传入该类的某个实例，并且这样传入的线程可以调用该实例所有变量，构造函数顺序是 <code>类函数，实例，参数1， 参数2， ...</code></li>
</ul>
<h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>这篇笔记简单概括了一下 <code>std::thread</code>，值得注意的是，上面的所有例子都直接最简单的应用，并没有涉及资源分配的情况，在实际使用需要注意不同线程的对同一资源的使用 (race_condition)，避免出现死锁。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>multi-threads</tag>
      </tags>
  </entry>
  <entry>
    <title>基于图优化的激光 SLAM 方法</title>
    <url>/2020/07/14/lidarSLAM-backend/</url>
    <content><![CDATA[<p>本文是我在学习深蓝学院的<a href="https://www.shenlanxueyuan.com/course/152" target="_blank" rel="noopener">激光slam课程</a>关于激光 SLAM 后端优化的内容。本次课主要分成四部分：首先介绍以下基于图优化的的激光 SLAM 的基本概念；然后介绍非线性最小二乘的基本原理；接下来结合前两部分介绍一下非线性最小二乘在 SLAM 中的应用；最后介绍 cartographer 的代码思路作为实践例子。</p>
<a id="more"></a>
<h2 id="Graph-based-SLAM"><a href="#Graph-based-SLAM" class="headerlink" title="Graph-based SLAM"></a>Graph-based SLAM</h2><h2 id="非线性最小二乘原理"><a href="#非线性最小二乘原理" class="headerlink" title="非线性最小二乘原理"></a>非线性最小二乘原理</h2><h2 id="非线性最小二乘在-SLAM-中的应用"><a href="#非线性最小二乘在-SLAM-中的应用" class="headerlink" title="非线性最小二乘在 SLAM 中的应用"></a>非线性最小二乘在 SLAM 中的应用</h2><h2 id="Cartographer-介绍"><a href="#Cartographer-介绍" class="headerlink" title="Cartographer 介绍"></a>Cartographer 介绍</h2>]]></content>
      <categories>
        <category>激光SLAM</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>lidar-slam</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 OpenCV 的 fillPoly() 函数画多边形</title>
    <url>/2020/07/01/opencv_fill_polygon/</url>
    <content><![CDATA[<p>最近需要通过 OpenCV 来给输出的图像画多边形，看了一些帖子之后发现 fillPoly() 函数很好用，在这里记录一下。</p>
<a id="more"></a>
<p><code>cv::fillPoly()</code> 有多个重载版本，这里记录以下两个：</p>
<h3 id="第一个版本"><a href="#第一个版本" class="headerlink" title="第一个版本"></a>第一个版本</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CV_EXPORTS_W <span class="keyword">void</span> <span class="title">fillPoly</span><span class="params">(InputOutputArray img, InputArrayOfArrays pts,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Scalar&amp; color, <span class="keyword">int</span> lineType = LINE_8, <span class="keyword">int</span> shift = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Point offset = Point() )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个 API 比较好理解，<code>img</code> 是需要画多边形的图像， <code>pts</code> 是多边形的各个顶点，<code>color</code> 和 <code>lineType</code> 分别是多边形的颜色和边框类型，<code>shift</code> 和 <code>offset</code> 分别是对点坐标的偏移和多边形整体的偏移。需要注意的是由于这个 API 不限定用来画凸多边形，也可以用来画凹多边形或者自身交叉的多边形，所以 <code>pts</code> 的顺序需要保证是你想要的多边形的顶点顺序。下面用两个例子说明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">image</span><span class="params">(cv::Size(<span class="number">540</span>, <span class="number">540</span>), CV_8UC1)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point&gt; fillContSingle;</span><br><span class="line"><span class="comment">//add all points of the contour to the vector</span></span><br><span class="line">fillContSingle.push_back(cv::Point(<span class="number">200</span>, <span class="number">100</span>));</span><br><span class="line">fillContSingle.push_back(cv::Point(<span class="number">200</span>, <span class="number">200</span>));</span><br><span class="line">fillContSingle.push_back(cv::Point(<span class="number">100</span>, <span class="number">200</span>));</span><br><span class="line">fillContSingle.push_back(cv::Point(<span class="number">300</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">cv::fillPoly( <span class="built_in">image</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point&gt;&gt;&#123;fillContSingle&#125;, cv::Scalar(<span class="number">128</span>));</span><br></pre></td></tr></table></figure>
<p>上面的代码段的效果如下：</p>
<img src="/2020/07/01/opencv_fill_polygon/example-1.png" class="" title="opencv-fill-polygon">
<p>可以发现按照这个顺序的多边形画出来是自身交叉的。如果把其中其中第二和第三个点换一下，效果如下：</p>
<img src="/2020/07/01/opencv_fill_polygon/example-2.png" class="" title="opencv-fill-polygon">
<h3 id="第二个版本"><a href="#第二个版本" class="headerlink" title="第二个版本"></a>第二个版本</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CV_EXPORTS <span class="keyword">void</span> <span class="title">fillPoly</span><span class="params">(Mat&amp; img, <span class="keyword">const</span> Point** pts,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="keyword">int</span>* npts, <span class="keyword">int</span> ncontours,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> Scalar&amp; color, <span class="keyword">int</span> lineType = LINE_8, <span class="keyword">int</span> shift = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Point offset = Point() )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个重载版本其实看不太懂跟第一个区别在哪里，需要额外设置参数的参数有每个多边形的点的数量和多边形的数量。感觉上是能够更明确自己需要画的效果，不过我自己没有尝试过，所以这里只是简单记录一下。需要注意的是这里点的参数是二维的<code>Point</code> 指针所以不能直接传入 <code>vector</code> 需要坐一定转换，使用的例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point&gt; fillContSingle;</span><br><span class="line"><span class="comment">//add all points of the contour to the vector</span></span><br><span class="line">fillContSingle.push_back(cv::Point(<span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">fillContSingle.push_back(cv::Point(<span class="number">100</span>, <span class="number">200</span>));</span><br><span class="line">fillContSingle.push_back(cv::Point(<span class="number">-200</span>, <span class="number">200</span>));</span><br><span class="line">fillContSingle.push_back(cv::Point(<span class="number">200</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point&gt; &gt; fillContAll;</span><br><span class="line"></span><br><span class="line">fillContAll.push_back(fillContSingle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// convert 2d vector to Point**</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; tmp = fillContAll.at(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> Point* elementPoints[<span class="number">1</span>] = &#123; &amp;tmp[<span class="number">0</span>] &#125;;</span><br><span class="line"><span class="keyword">int</span> numberOfPoints = (<span class="keyword">int</span>)tmp.<span class="built_in">size</span>();</span><br><span class="line">fillPoly (<span class="built_in">image</span>, elementPoints, &amp;numberOfPoints, <span class="number">1</span>, Scalar (<span class="number">128</span>), <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>效果和上图一样。</p>
<p>参考：<a href="https://stackoverflow.com/questions/8281239/drawing-polygons-in-opencv" target="_blank" rel="noopener">StackOverFlow</a></p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>lidarSLAM - 第五次作业</title>
    <url>/2020/05/26/lidarSLAM-hw5/</url>
    <content><![CDATA[<p>本文是我在学习深蓝学院的<a href="https://www.shenlanxueyuan.com/course/152" target="_blank" rel="noopener">激光slam课程</a>第五次作业的笔记。本次作业主要是熟悉 imls-icp 的过程以及对 csm 接口调用，除此之外还有对课上讲的四种 icp 算法进行总结以及想一下 icp 的改进思路。</p>
<a id="more"></a>
<h2 id="实现高斯牛顿法进行点云配准"><a href="#实现高斯牛顿法进行点云配准" class="headerlink" title="实现高斯牛顿法进行点云配准"></a>实现高斯牛顿法进行点云配准</h2><blockquote>
<p>补充代码,实现 gaussian_newton_scanmatcher 模块</p>
</blockquote>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>老规矩，还是先阅读给定的框架代码，了解代码结构再考虑补全。这次作业主要也是涉及两个源文件，分别是 <code>main.cpp</code> 和 <code>gaussian_newton_method.cpp</code>。其中，<code>main.cpp</code> 里包含了一个 <code>GaussianNewtonDebug</code> 类，完成了 ROS 的相关设置，包括订阅和发布消息，消息的类型转换（将订阅的激光扫描话题消息转为更加方便使用的 <code>vector</code>），以及调用 <code>gaussian_new_method.cpp</code> 里定义的关于高斯牛顿法的相关函数。除了这两个文件之外，还提供了 <code>map.c</code> 和 <code>map_cspace.cpp</code> 两个文件，主要是外部提供的一些关于地图的模块。下面重点讲一下 <code>gaussian_new_method.cpp</code></p>
<h3 id="高斯牛顿发相关代码"><a href="#高斯牛顿发相关代码" class="headerlink" title="高斯牛顿发相关代码"></a>高斯牛顿发相关代码</h3><p><code>gaussian_new_method.cpp</code> 主要提供了关于高斯牛顿法的几个函数，有几个比较简单就不说了，对要补充的三个函数下面进行介绍。</p>
<ul>
<li><code>Eigen::Vector3d InterpMapValueWithDerivatives(map_t* map,Eigen::Vector2d&amp; coords)</code>：通过周围四个已知点插值计算出指定坐标点的势场值和梯度，这里可以用课程中提到的拉格朗日双方向插值来进行计算。<strong>注意计算出来的梯度需要考虑到尺度的影响</strong>。补充代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Eigen::Vector3d <span class="title">InterpMapValueWithDerivatives</span><span class="params">(<span class="keyword">map_t</span>* <span class="built_in">map</span>,Eigen::Vector2d&amp; coords)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Vector3d ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// calculate coordinates on the given map (noticed: might not be exact interger)</span></span><br><span class="line">    <span class="comment">/// remember the origin of map locates in center of the map thus need to plus half of size to get the real index</span></span><br><span class="line">    <span class="keyword">double</span> index_x = (coords(<span class="number">0</span>) - <span class="built_in">map</span>-&gt;origin_x) / <span class="built_in">map</span>-&gt;resolution + <span class="built_in">map</span>-&gt;size_x / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> index_y = (coords(<span class="number">1</span>) - <span class="built_in">map</span>-&gt;origin_y) / <span class="built_in">map</span>-&gt;resolution + <span class="built_in">map</span>-&gt;size_y / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int16_t</span> index_x0 = <span class="built_in">floor</span>(index_x);</span><br><span class="line">    <span class="keyword">int16_t</span> index_y0 = <span class="built_in">floor</span>(index_y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// calculate u, v using four nearest points</span></span><br><span class="line">    <span class="keyword">double</span> u, v;</span><br><span class="line">    u = index_x - index_x0;</span><br><span class="line">    v = index_y - index_y0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// calcualte scores for four nearest points</span></span><br><span class="line">    <span class="keyword">double</span> z1 = <span class="built_in">map</span>-&gt;cells[MAP_INDEX(<span class="built_in">map</span>, index_x0, index_y0)].score;</span><br><span class="line">    <span class="keyword">double</span> z2 = <span class="built_in">map</span>-&gt;cells[MAP_INDEX(<span class="built_in">map</span>, index_x0 + <span class="number">1</span>, index_y0)].score;</span><br><span class="line">    <span class="keyword">double</span> z3 = <span class="built_in">map</span>-&gt;cells[MAP_INDEX(<span class="built_in">map</span>, index_x0 + <span class="number">1</span>, index_y0 + <span class="number">1</span>)].score;</span><br><span class="line">    <span class="keyword">double</span> z4 = <span class="built_in">map</span>-&gt;cells[MAP_INDEX(<span class="built_in">map</span>, index_x0, index_y0 + <span class="number">1</span>)].score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// score of given coordinate in the map</span></span><br><span class="line">    ans(<span class="number">0</span>) = (<span class="number">1</span> - u) * (<span class="number">1</span> - v) * z1 + u * (<span class="number">1</span> - v) * z2 + u * v * z3 + (<span class="number">1</span> - u) * v *z4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// gradient</span></span><br><span class="line">    <span class="comment">/// noticed: need to remove scale influence by using resolution</span></span><br><span class="line">    ans(<span class="number">1</span>) = (v * (z3 - z4) + (<span class="number">1</span> - v) * (z2 - z1)) / <span class="built_in">map</span>-&gt;resolution;</span><br><span class="line">    ans(<span class="number">2</span>) = (u * (z3 - z2) + (<span class="number">1</span> - u) * (z4 - z1)) / <span class="built_in">map</span>-&gt;resolution;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void ComputeHessianAndb(map_t* map, Eigen::Vector3d now_pose,std::vector&lt;Eigen::Vector2d&gt;&amp; laser_pts,Eigen::Matrix3d&amp; H, Eigen::Vector3d&amp; b)</code> ： 计算 H 和 b 用来进行高斯优化，这里通过笔记中的方法计算即可，需要注意的是激光点和机器人的相对以及绝对 pose 的关系，不要用混，以及 J 矩阵的维度：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComputeHessianAndb</span><span class="params">(<span class="keyword">map_t</span>* <span class="built_in">map</span>, Eigen::Vector3d now_pose,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Eigen::Vector2d&gt;&amp; laser_pts,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Eigen::Matrix3d&amp; H, Eigen::Vector3d&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    H = Eigen::Matrix3d::Zero();</span><br><span class="line">    b = Eigen::Vector3d::Zero();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Eigen::Vector2d pt: laser_pts) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// compute laser pt pose globally</span></span><br><span class="line">        Eigen::Vector2d pt_pose = GN_TransPoint(pt, now_pose);</span><br><span class="line"></span><br><span class="line">        Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">3</span>&gt; ds;</span><br><span class="line">        ds &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, -<span class="built_in">sin</span>(now_pose(<span class="number">2</span>) * pt(<span class="number">0</span>)) - <span class="built_in">cos</span>(now_pose(<span class="number">2</span>)) * pt(<span class="number">1</span>),</span><br><span class="line">                <span class="number">0</span>, <span class="number">1</span>, <span class="built_in">cos</span>(now_pose(<span class="number">2</span>) * pt(<span class="number">0</span>)) - <span class="built_in">sin</span>(now_pose(<span class="number">2</span>)) * pt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// compute score &amp; grident of that point in map</span></span><br><span class="line">        Eigen::Vector3d score_gradient = InterpMapValueWithDerivatives(<span class="built_in">map</span>, pt_pose);</span><br><span class="line">        <span class="function">Eigen::Vector2d <span class="title">gradient</span><span class="params">(score_gradient(<span class="number">1</span>), score_gradient(<span class="number">2</span>))</span></span>;</span><br><span class="line">        <span class="keyword">double</span> score = score_gradient(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// noticed the dimension of J should 1 x 3</span></span><br><span class="line">        Eigen::RowVector3d J = gradient.transpose() * ds;</span><br><span class="line">        H += J.transpose() * J;</span><br><span class="line">        b += J.transpose() * (<span class="number">1</span> - score);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void GaussianNewtonOptimization(map_t*map,Eigen::Vector3d&amp; init_pose,std::vector&lt;Eigen::Vector2d&gt;&amp; laser_pts)</code>: 进行高斯优化，这一部分按照常规操作即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GaussianNewtonOptimization</span><span class="params">(<span class="keyword">map_t</span>*<span class="built_in">map</span>,Eigen::Vector3d&amp; init_pose,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Eigen::Vector2d&gt;&amp; laser_pts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxIteration = <span class="number">20</span>;</span><br><span class="line">    Eigen::Vector3d now_pose = init_pose;</span><br><span class="line">    Eigen::Matrix3d H;</span><br><span class="line">    Eigen::Vector3d b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxIteration;i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        ComputeHessianAndb(<span class="built_in">map</span>, now_pose, laser_pts, H, b);</span><br><span class="line"></span><br><span class="line">        Eigen::Vector3d delta_x = H.colPivHouseholderQr().solve(b);</span><br><span class="line"></span><br><span class="line">        now_pose += delta_x;</span><br><span class="line">    &#125;</span><br><span class="line">    init_pose = now_pose;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>运行结果如下图所示：</p>
<img src="/2020/05/26/lidarSLAM-hw5/result.png" class="" title="lidarSLAM-hw5">
<p>可以看出基本轮廓比较符合，但由于每一步的误差导致最后偏离较远，需要后端来进行校正。同时通过调整迭代次数和迭代终止条件也能进一步对算法效果进行微调。</p>
<h2 id="对上一题算法进行改进的方案"><a href="#对上一题算法进行改进的方案" class="headerlink" title="对上一题算法进行改进的方案"></a>对上一题算法进行改进的方案</h2><blockquote>
<p>提出一种能提升第一题激光匹配轨迹精度的方法,并解释原因</p>
</blockquote>
<p>除了调整迭代次数以外，还可以：</p>
<ul>
<li>使用另一种算法进行迭代，比如 LM 算法</li>
<li>对点云进行预处理，进行运动畸变的去除，过滤噪声等</li>
<li>使用更多点进行插值</li>
</ul>
<h2 id="NDT相关"><a href="#NDT相关" class="headerlink" title="NDT相关"></a>NDT相关</h2><blockquote>
<p>读论文 The Normal Distributions Transform: A New Approach to Laser Scan Matching,回<br>答以下问题<br>NDT 的优化函数(score)是什么?<br>简述 NDT 根据 score 函数进行优化求解的过程。</p>
</blockquote>
<p>参考我的上一篇笔记：<a href="https://guoxiaotao.xyz/2020/05/24/lidarSLAM-frontend-2/">激光SLAM 前端配准方法 - 基于势场的方法</a></p>
<h2 id="分支定界相关"><a href="#分支定界相关" class="headerlink" title="分支定界相关"></a>分支定界相关</h2><blockquote>
<p>机器人在 XY 方向上进行 CSM 匹配。下图左为机器人在目标区域粗分辨率下 4 个位置的匹配得分,得<br>分越高说明机器人在该位置匹配的越好,下图右为机器人在同一块地图细分辨率下每个位置的匹配得分(右<br>图左上 4 个小格对应左图左上一个大格,其它同理)。如果利用分枝定界方法获取最终细分辨率下机器人<br>的最佳匹配位置,请简述匹配和剪枝流程。</p>
</blockquote>
<img src="/2020/05/26/lidarSLAM-hw5/p4_problem.png" class="" title="lidarSLAM-hw5">
<p>首先将粗分辨率的四个节点分别定为 0， 1， 2， 3，细分辨率节点命名类似；</p>
<p>首先进行第一次计算：找出粗分辨率下分数最高的节点，选出 1 节点 (99分) 进行分支；<br>对 1 节点进行分支获得四个分数；最高分为 12 节点 （87分），并且该分支已经是子节点（所需要的分辨率），所以可以用该分数作为阈值进行剪枝；因此 0 节点不需要考虑；<br>接下来对 2 节点分支，最高分为 21 节点 （95分），因此更新最高分为 95 分；<br>最后对 3 节点分支，最高分为 89 分，不影响结果。<br>因此最后取 21 节点作为解，分数为 95 分。</p>
]]></content>
      <categories>
        <category>激光slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>lidar-slam</tag>
      </tags>
  </entry>
  <entry>
    <title>激光SLAM 前端配准方法 - 基于势场的方法</title>
    <url>/2020/05/24/lidarSLAM-frontend-2/</url>
    <content><![CDATA[<p>最近工作又搬家比较忙，趁周末有空继续学习一下。本文是我在学习深蓝学院的<a href="https://www.shenlanxueyuan.com/course/152" target="_blank" rel="noopener">激光slam课程</a>前端配准第二部分的学习笔记，第一部分中主要是学习了如何用 ICP 及其变种来进行前后两帧点云匹配，具体可以看我的<a href="https://guoxiaotao.xyz/2020/04/28/lidarSLAM-frontend-1/">上一篇笔记</a>，这一部分主要是介绍了前端配准的另一个方法——基于势场的方法。相较于 ICP 方法，这种匹配方法不需要找到两个点云之间的对应点的匹配的关系，这两种方法都在实际使用中有涉及。本次学习的基于势场的匹配算法有：高斯牛顿优化方法、NDT 方法，相关匹配方法及分支定界加速。</p>
<a id="more"></a>
<h2 id="高斯牛顿优化方法"><a href="#高斯牛顿优化方法" class="headerlink" title="高斯牛顿优化方法"></a>高斯牛顿优化方法</h2><h3 id="基本原则-amp-数学描述"><a href="#基本原则-amp-数学描述" class="headerlink" title="基本原则 &amp; 数学描述"></a>基本原则 &amp; 数学描述</h3><p>HectorSLAN 使用的是这种方法。根据基于优化方法，只要给定一个目标函数，我们可以把激光帧间的匹配问题转换为求解目标函数的极值问题（通常是求最小值）：</p>
<script type="math/tex; mode=display">
E(T) = \arg \min_{T} \sum{[1 - M(S_{i}(T))]^2}</script><p>其中， T 表示当前机器人的位姿矩阵 $T = T(T_x, T_y, T_\theta)$， $S_{i}(T)$ 表示将激光点 i 通过 T 转换后的坐标（可以认为是地图坐标），$M(x)$ 表示得到当前坐标下的地图的占用概率，这个值可以认为是转换后的坐标离真实值的相差程度，离真实值越近值越大，具体的计算方法是通过查表求得该点的值，注意这里并不是找某对点的匹配程度，而是比较两个地图。</p>
<h3 id="目标函数求解"><a href="#目标函数求解" class="headerlink" title="目标函数求解"></a>目标函数求解</h3><p>如上所示，我们的目标函数为：</p>
<script type="math/tex; mode=display">
E(T) = \arg \min_{T} \sum{[1 - M(S_{i}(T))]^2}</script><p>其中，假设 $p_i = (p_{ix}, p_{iy})$ 表示第 i 个激光点的坐标，则有：</p>
<script type="math/tex; mode=display">
S_{i}(T) = \begin{bmatrix}\cos{T_\theta} & -\sin{T_\theta} & T_x \\
                        \sin{T_\theta} & \cos{T_\theta} & T_y\\
                        0 & 0 & 1\end{bmatrix}\begin{bmatrix}p_{ix}\\p_{iy}\\1\end{bmatrix}</script><p>因为 $M(S_{i}(T))$ 为非线性函数，求极值需要对其进行一阶泰勒展开，则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
 & E(T) = \arg \min_{T} \sum{[1 - M(S_{i}(T))]^2} \\
 \rightarrow & E(T+\Delta T) = \arg \min_{T} \sum{[1 - M(S_{i}(T)) - \nabla M(S_{i}(T))\frac{\partial{S_{i}(T)}}{\partial{T}}\Delta{T}]^2}
\end{aligned}</script><p>对于上述线性方程，求极值可以通过求其对 $\Delta{T}$ 的导数，并使之为0，前两项和变量无关，直接去掉，<br>令：</p>
<script type="math/tex; mode=display">
f(x) = 1 - M(S_{i}(T)) -\nabla M(S_{i}(T))\frac{\partial{S_{i}(T)}}{\partial{T}}\Delta{T}</script><p>则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial{(\sum{f(x)})^2}}{\partial{x}} = 2\sum{f(x)\frac{\partial{f(x)}}{\partial{x}} }&=0\\
\sum{f(x)\frac{\partial{f(x)}}{\partial{x}}} &=0
\end{aligned}</script><p>即：</p>
<script type="math/tex; mode=display">
\sum{[\nabla M(S_{i}(T))\frac{\partial{S_{i}(T)}}{\partial{T}}]^{T}[ 1 - M(S_{i}(T)) -\nabla M(S_{i}(T))\frac{\partial{S_{i}(T)}}{\partial{T}}\Delta{T}]} = 0</script><p>我们需要求解上式得到 $\Delta{T}$，然后令 $T = T + \Delta{T}$，进行迭代即可。展开上式得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum{[\nabla{M(S_{i}(T))}\frac{\partial{S_{i}(T)}}{\partial{T}}]^T[ 1 - M(S_{i}(T)) -\nabla M(S_{i}(T))\frac{\partial{S_{i}(T)}}{\partial{T}}\Delta{T}]} = 0 \\
\sum{[\nabla{M(S_{i}(T))}\frac{\partial{S_{i}(T)}}{\partial{T}}]^T[ 1 - M(S_{i}(T))]} = \sum{[\nabla{M(S_{i}(T))}\frac{\partial{S_{i}(T)}}{\partial{T}}]^T[\nabla M(S_{i}(T))\frac{\partial{S_{i}(T)}}{\partial{T}}]\Delta{T}}
\end{aligned}</script><p>令:</p>
<script type="math/tex; mode=display">
\begin{aligned}
b &= \sum{[\nabla M(S_{i}(T))\frac{\partial{S_i(T)}}{\partial{T}}]^T[ 1 - M(S_i(T))]} \\
J &= \nabla{M(S_i(T))}\frac{\partial{S_i(T)}}{\partial{T}} \\
H &= \sum{J^{T}J}
\end{aligned}</script><p>则上式可以简化为：$H\Delta{T} = b$，两边同乘$H^{-1}$，则有：</p>
<script type="math/tex; mode=display">
\Delta{T} = H^{-1}b</script><p>其中,</p>
<script type="math/tex; mode=display">
\begin{aligned}
    S_{i}(T) &= \begin{bmatrix}
        \cos{T_\theta} & -\sin{T_\theta} & T_x \\
                        \sin{T_\theta} & \cos{T_\theta} & T_y\\
                        0 & 0 & 1\end{bmatrix}\begin{bmatrix}p_{ix}\\p_{iy}\\1
    \end{bmatrix} \\
    &= \begin{bmatrix}
        \cos{T_\theta}p_{ix} - \sin{T_\theta}p_{iy} + T_x \\
        \sin{T_\theta}p_{ix} + \cos{T_\theta}p_{iy} + T_y \\
        1
    \end{bmatrix}
\end{aligned}</script><p>最后一项常数可以不管（求导等于0， 最后补一行 0即可），对其求导有：</p>
<script type="math/tex; mode=display">
\frac{\partial{S_{i}(T)}}{\partial{T}} = \begin{bmatrix}
    1 & 0 & -\sin{T_\theta} p_{ix} - \cos{T_\theta}p_{iy} \\
    0 & 1 &  \cos{T_\theta} p_{ix} - \sin{T_\theta}p_{iy}
\end{bmatrix}</script><p>至此，在上式（$\Delta{T}$ 求解）中，除了 $\nabla{M(S_{i}(T))}$ 以外，其他变量都是已知，下面进行 $\nabla{M(S_{i}(T))}$ 求解。我们知道 $S_{i}(T)$ 表示地图坐标点， $M(S_{i}(T))$ 表示该点的地图势场值（离点云真实值越近值越大），在计算势场值的时候，我们通常是把地图离散化变成一个二维（三维）的矩阵用来表示地图各点的势场值，这个值通过查表得出，$\nabla{M(S_{i}(T))}$ 表示地图势场对该点的导数，对于 $\nabla{M(S_{i}(T))}$ 和部分 $M(S_{i}(T))$ （不在矩阵离散点内的），需要对地图进行插值。</p>
<h3 id="地图双线性插值"><a href="#地图双线性插值" class="headerlink" title="地图双线性插值"></a>地图双线性插值</h3><p>如下图所示，假设我们要求 $P_m$ 的势场值以及对应导数的值，我们需要对离散地图进行差值，这里我们使用拉格朗日插值法分别对 X, Y 两个方向进行插值，是一维线性插值的推广<br><img src="/2020/05/24/lidarSLAM-frontend-2/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC.png" class="" title="lidarSLAM-frontend-2"></p>
<h4 id="朗格朗日插值方法-一维线性插值"><a href="#朗格朗日插值方法-一维线性插值" class="headerlink" title="朗格朗日插值方法 - 一维线性插值"></a>朗格朗日插值方法 - 一维线性插值</h4><p>拉格朗日插值的方法的主要特点是将插值多项式表示成基函数的线性组合：</p>
<script type="math/tex; mode=display">
L_n(x) = \sum_{i = 0}^{n}{(l_i(x)y_i)}</script><p>其中，基函数 $l_i(x)$ 满足以下条件：</p>
<script type="math/tex; mode=display">
l_i(x_k) = \left\{ \begin{aligned}
    1 & & k = i \\
    0 & & k \neq i
\end{aligned}\right.</script><h4 id="朗格朗日插值方法-基函数构造"><a href="#朗格朗日插值方法-基函数构造" class="headerlink" title="朗格朗日插值方法 - 基函数构造"></a>朗格朗日插值方法 - 基函数构造</h4><p>通过上面式子，我们可以将基函数构造成：</p>
<script type="math/tex; mode=display">
l_i(x) = c(x - x_0)(x - x_1)...(x - x_{i-1})(x-x_{i})...(x-x_n)</script><p>显然这个式子满足上述条件，因为有$l_i(x_i) = 1$，有：</p>
<script type="math/tex; mode=display">
c = \frac{1}{(x - x_0)...(x-x_{i})...(x-x_n)}</script><p>则：</p>
<script type="math/tex; mode=display">
l_i(x) = \prod_{k = 0, k\neq i}^{n}\frac{x - x_k}{x_i - x_k}</script><h4 id="朗格朗日插值方法-双线性插值"><a href="#朗格朗日插值方法-双线性插值" class="headerlink" title="朗格朗日插值方法 - 双线性插值"></a>朗格朗日插值方法 - 双线性插值</h4><p>设平面中有四个点及其势场值：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    Z_1 = M(P_{00}) &= f(x_0, y_0) \\
    Z_2 = M(P_{10}) &= f(x_1, y_0) \\
    Z_3 = M(P_{11}) &= f(x_1, y_1) \\
    Z_4 = M(P_{01}) &= f(x_0, y_1) \\
\end{aligned}</script><p>我们定义一个新的坐标：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    u &= \frac{x - x_0}{x_1 - x_0} \\
    v &= \frac{y - y_0}{y_1 - y_0}
\end{aligned}</script><p>则在这个坐标系下有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    (x_0, y_0) &= (0, 0) \\
    (x_1, y_0) &= (1, 0) \\
    (x_1, y_1) &= (1, 1) \\
    (x_0, y_1) &= (0, 1) \\
\end{aligned}</script><p>根据上一部分的方法构造基函数：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    l_1(u, v) &= (1-u)(1-v) \\
    l_2(u, v) &= u(1 -v) \\
    l_3(u, v) &= uv \\
    l_4(u, v) &= (1-u)v
\end{aligned}</script><p>通过上一部分，插值函数为：</p>
<script type="math/tex; mode=display">
L_4(u, v) = Z_1l_1(u, v) + Z_2l_2(u, v) + Z_3l_3(u, v) + Z_4l_4(u, v)</script><h4 id="地图插值"><a href="#地图插值" class="headerlink" title="地图插值"></a>地图插值</h4><p>将上述插值方式转换为原来的坐标系有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    L(x, y) &= \frac{y - y_0}{y_1 - y_0}(\frac{x - x_0}{x_1 - x_0}(P_{11}) + \frac{x_1 - x}{x_1 - x_0}(P_{01})) \\
 &+ \frac{y_1 - y}{y_1 - y_0}(\frac{x - x_0}{x_1 - x_0}(P_{10}) + \frac{x_1 - x}{x_1 - x_0}(P_{00}))
\end{aligned}</script><p>其对 x 和 y 的偏导数分别为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \frac{\partial{L(x, y)}}{\partial{x}} &= \frac{y - y_0}{y_1 - y_0}(M(P_{11}) - M(P_{01})) + \frac{y_1 - y}{y_1 - y_0}(M(P_{10}) - M(P_{00})) \\
    \frac{\partial{L(x, y)}}{\partial{y}} &= \frac{x - x_0}{x_1 - x_0}(M(P_{11}) - M(P_{10})) + \frac{x_1 - x}{x_1 - x_0}(M(P_{01}) - M(P_{00}))
\end{aligned}</script><p>至此，我们可以求得 $\nabla{M(S_{i}(T))}$ 和 $M(S_{i}(T))$ 的值，进而求得 $\Delta{T}$，并进行迭代计算求得目标函数最小值。</p>
<h2 id="NDT-Normal-Distribution-Transform-方法"><a href="#NDT-Normal-Distribution-Transform-方法" class="headerlink" title="NDT (Normal Distribution Transform) 方法"></a>NDT (Normal Distribution Transform) 方法</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>NDT 方法的基本思想是将空间划分成一个个 cell，这里的 cell 的概念要和栅格 grid 区分一下，通常单个栅格会取很小，其只代表了一个值。相对而言，cell 更像是一个小区域。有了各个 cell 之后为每一个 cell 定义一个高斯分布用来替代势场，因此整个空间里面就形成了一个分段连续的势场（在各自的 cell 里面连续）。通过这样的方法，结合连续的势场我们可以直接用牛顿法进行迭代（Hessian 矩阵非常好求），同时这样一个势场也不受离散化的影响。</p>
<h3 id="数学描述"><a href="#数学描述" class="headerlink" title="数学描述"></a>数学描述</h3><p>首先定义几个变量：</p>
<p>$T = (t_x, t_y, t_\theta)$ 表示需要求解的值</p>
<p>$x_i = (x, y)^T$ 表示激光点坐标</p>
<p>$<br>\begin{aligned}<br>    T(x_i) = \begin{bmatrix}<br>        \cos{\theta} &amp; -\sin{\theta} \\<br>        \sin{\theta} &amp;  \cos{\theta}<br>    \end{bmatrix}<br>    \begin{bmatrix}<br>        x_i \\ y_i<br>    \end{bmatrix} +<br>    \begin{bmatrix}<br>        t_x \\ t_y<br>    \end{bmatrix}<br>\end{aligned}<br>$</p>
<p>$q_i$, $\Sigma_i$ 分别表示 $x_i$ 对应点的高斯分布的均值和方差，则当前激光点的的得分为(得分越小，匹配程度越高)：</p>
<script type="math/tex; mode=display">x_i' = T(x_i)</script><script type="math/tex; mode=display">score_i = -\exp{(-\frac{(x_i' - q_i)^T\Sigma_i^{-1}(x_i' - q_i)}{2})}</script><p>则对应的目标函数为：$\min{\sum_i{score_i}}$，令 $q = x_i’ - q_i$，则有：</p>
<script type="math/tex; mode=display">
socre_i = -\exp{(-\frac{q^T\Sigma^{-1}q}{2})}</script><p>值得注意的是，目标函数并没有取误差的平方；同时对误差函数也不需要进行线性化（用 $J^TJ$ 代替 Hassian 矩阵），因为 Hassian 矩阵本身容易求解。</p>
<h3 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h3><p>首先介绍以下牛顿法求解目标函数最小值：$\min{f(x)}$</p>
<p>上式等价于令一阶导数为 0： $g(x) = f’(x) = 0$</p>
<p>由于我们需要求解迭代量 $\Delta x$ 令一阶导数为 0，同时结合泰勒展开，即：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    g(x + \Delta x) &= g(x) + \frac{\partial{g(x)}}{\partial{x}} \\
    \frac{\partial{g(x)}}{\partial{x}}\Delta x &= -g(x)
\end{aligned}</script><p>接下来令 $x = x + \Delta x$，进行迭代即可。</p>
<p>上式等价于 $H\Delta x = -J$。因此用牛顿法进行迭代求解时，关键是计算目标函数 $f(x)$ 的 Hassian 矩阵和 Jacobian 矩阵。在某些函数里面，Hassian 矩阵比较难求，因此用 $J^TJ$ 来表示（高斯牛顿法的思想）。</p>
<p>如果 $f(x) = \sum{f_i(x)}$，则有：$J = \sum{J_i}$, $H = \sum{H_i}$</p>
<h3 id="用牛顿法进行-NDT-求解"><a href="#用牛顿法进行-NDT-求解" class="headerlink" title="用牛顿法进行 NDT 求解"></a>用牛顿法进行 NDT 求解</h3><script type="math/tex; mode=display">
f_i(T) = score_i = -\exp{(-\frac{(x_i' - q_i)^T\Sigma_i^{-1}(x_i' - q_i)}{2})}</script><p>首先求 J，令 $q = x_i’ - q_i = T(x_i) - q_i$，则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    J_i = \frac{\partial{f_i}}{\partial{T}} &= -\exp{(-\frac{q^T\Sigma^{-1}q}{2})}(-q^T\Sigma^{-1}\frac{\partial{q}}{\partial{T}}) \\
    \frac{\partial{q}}{\partial{T}} &= \frac{\partial{T(x_i)}}{\partial{T}}
\end{aligned}</script><p>上面涉及到矩阵求导，可以参考 <a href="https://zh.wikipedia.org/zh-hans/%E7%9F%A9%E9%98%B5%E5%BE%AE%E7%A7%AF%E5%88%86?oldformat=true" target="_blank" rel="noopener">维基百科：矩阵微积分</a></p>
<p>下面对 $T(x_i)$ 求导：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    T(x_i) &= \begin{bmatrix}
        \cos{\theta} & -\sin{\theta} \\
        \sin{\theta} & \cos{\theta}
    \end{bmatrix}
    \begin{bmatrix}
        x_i \\ y_i
    \end{bmatrix} +
    \begin{bmatrix}
        t_x \\ y_x
    \end{bmatrix} \\
\rightarrow \frac{\partial{T(x_i)}}{\partial{T}} &=
\begin{bmatrix}
    1 & 0 & -x_i\sin{\theta} - y_i\cos{\theta} \\
    0 & 1 & x_i\cos{\theta} - y_i\sin{\theta}
\end{bmatrix}
\end{aligned}</script><p>至此， J 求导完成，接下来求 H 矩阵，通过链式法则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    H_i = \frac{\partial{J_i}}{\partial{T}} &= -\exp{(-\frac{q^T\Sigma^{-1}q}{2})}(-q^T\Sigma^{-1}\frac{\partial{q}}{\partial{T}})(-q^T\Sigma^{-1}\frac{\partial{q}}{\partial{T}})\\
    &+ -\exp{(-\frac{q^T\Sigma^{-1}q}{2})}(-q^T\Sigma^{-1}\frac{\partial{q}}{\partial{T}}) \\
    &+ -\exp{(-\frac{q^T\Sigma^{-1}q}{2})}(-q^T\Sigma^{-1}\frac{\partial^2{q}}{\partial^2{T}})
\end{aligned}</script><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>总结以下， NDT 方法的算法流程分三步：</p>
<ul>
<li>对环境进行 cell 的划分，为每一个 cell 构造一个高斯分布</li>
<li>根据初始解把当前帧的激光点转换到参考帧上，并确定属于哪个 cell</li>
<li>用牛顿法进行迭代求解</li>
</ul>
<h2 id="相关匹配方法及分枝定界加速-（CSM）"><a href="#相关匹配方法及分枝定界加速-（CSM）" class="headerlink" title="相关匹配方法及分枝定界加速 （CSM）"></a>相关匹配方法及分枝定界加速 （CSM）</h2><h3 id="相关方法（Correlation-based-Method）——基本思想"><a href="#相关方法（Correlation-based-Method）——基本思想" class="headerlink" title="相关方法（Correlation-based Method）——基本思想"></a>相关方法（Correlation-based Method）——基本思想</h3><p>相关方法的基本思想是通过在一个范围内通过枚举所有位姿的可能性，从中选择一个最好的作为结果。这么做的原因主要是因为考虑到我们面对的是一个高度非凸问题，可能会有非常多局部极值，所以迭代方法对初值非常敏感，所以采用暴力匹配的方法可以避免出现初值影响，但是这么做的问题是计算量太大，所以通常需要通过加速策略来降低计算量。同时这个方法还有一个好处是可以计算位姿匹配的方差。</p>
<h3 id="相关方法——算法流程"><a href="#相关方法——算法流程" class="headerlink" title="相关方法——算法流程"></a>相关方法——算法流程</h3><img src="/2020/05/24/lidarSLAM-frontend-2/%E4%BC%BC%E7%84%B6%E5%9C%BA.png" class="" title="lidarSLAM-frontend-2">
<ul>
<li>如上图所示，首先我们需要对地图通过高斯模糊来构造似然场</li>
<li>在一个指定的搜索空间（比如 1m×1m，30°范围内）来进行搜索，这里可以有不同搜索的方法，后面会详细描述；对搜索得到的每一个位姿进行得分计算（匹配程度）</li>
<li>根据上一步得到位姿得分，计算本次位姿匹配的方差</li>
</ul>
<h3 id="相关方法——位姿搜索"><a href="#相关方法——位姿搜索" class="headerlink" title="相关方法——位姿搜索"></a>相关方法——位姿搜索</h3><p>常用的搜索方式主要包括以下几种：</p>
<ol>
<li>暴力搜索：通过多层循环（对 $(x, y, \theta)$ 而言是三层）枚举每一个位姿,分别计算每一个位姿的得分,计算量巨大。因为激光雷达数据在每一个位姿都要重新投影,投影需要计算 sin 和 cos 函数（循环顺序是： $x\rightarrow y\rightarrow \theta$）;</li>
<li>预先投影搜索：把暴力搜索中的三层循环 $(x, y, \theta)$ 交换一下顺序,最外层对 $\theta$ 进行搜索,这样内层 $x, y$ 的投影不需要单独计算 sin 和 cos 值，需要计算 sin 和 cos 函数的位姿数从 $n_xn_yn_\theta$ 降为 $n_\theta$ 。能极大的加速算法的运行速度;</li>
<li>多分辨率搜索：<ul>
<li>构造粗分辨率 25cm 和细分辨率 2.5cm 两个似然场</li>
<li>首先在粗分辨率似然场上进行搜索,获取最优位姿</li>
<li>把粗分辨率最优位姿对应的栅格进行细分辨率划分,然后再进行细分辨率搜索,再次得到最优位姿。</li>
<li><strong>要求：粗分辨率地图的栅格的似然值为对应的细分辨率地图对应空间的所有栅格的上界</strong></li>
</ul>
</li>
</ol>
<h3 id="分枝定界算法——基本思想"><a href="#分枝定界算法——基本思想" class="headerlink" title="分枝定界算法——基本思想"></a>分枝定界算法——基本思想</h3><p>分枝定界算法是一种常用的树形搜索剪枝算法，主要用来求解整数规划问题。可以将最优解问题转换为树形搜索问<br>题,根节点表示整个解空间,叶子节点表示最优解,中间的节点表示解空间的某一部分子空间。</p>
<p>算法主要分为两部分：</p>
<ul>
<li>分枝：跟节点表示整个解空间，深度为 1 的节点表示解空间的 n 个子空间之一（分辨率是根节点的 1 / n），以此类推。将解空间层层划分直至到真实解（分辨率达到所需要求）即叶节点。</li>
<li>定界：要实现通过剪枝来进行加速（dfs 搜索），对于某个子树而言，<strong>必须保证该子树根节点的值是该子树所有节点的值的上界</strong>（如果是求解最小值问题就是下界）；这样在搜索过程过程中只需要维护一个当前最优值，当遇到某个节点的值低于该值，我们就不需要对以该节点为根节点的子树进行搜索，从而进行加速。</li>
</ul>
<h3 id="分支定界算法——-score-函数定义"><a href="#分支定界算法——-score-函数定义" class="headerlink" title="分支定界算法—— score 函数定义"></a>分支定界算法—— score 函数定义</h3><p>从上面可知，分枝定界算法当中一个核心问题就是怎么定义一个 score 函数使得其能够上面提到的要求：对任意子树，根节点的值是该子树所有节点的值的上界</p>
<p>首先，搜索树中的节点表示一个正方形的搜索范围 $(c_x, c_y, c_\theta, c_h)$， $c_h$ 为高度。根节点最高，即：</p>
<script type="math/tex; mode=display">
\overline{\overline{W}}_c = (\{
    (j_x, j_u)\in \mathbb{Z}^2:
    \begin{aligned}
        c_x \leq j_x \leq c_x + 2^{c_h} \\
        c_y \leq j_y \leq c_y + 2^{c_h}
    \end{aligned}
    \} \times {c_\theta})</script><p>分枝：对于节点 $(c_x, c_y, c_\theta, c_h)$，分枝为 4 个子节点，分别为：</p>
<script type="math/tex; mode=display">
C_c = ((\{c_x, c_x + 2^{c_h-1}\}\times \{c_y, c_y + 2^{c_h-1}\}\times c_\theta) \cap \overline{W}) \times \{c_h - 1\}</script><p>定界：score 函数定义及证明如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    score(c) &= \sum_{k = 1}^{k}\max_{j \in \overline{\overline{W}}_c} M_{nearest}(T_{\zeta_j}, h_k) \\
    &\geq \sum_{k = 1}^{K}\max_{j \in \overline{W}_c} M_{nearest}(T_{\zeta_j}, h_k) \\
    &\geq \max_{j \in \overline{W}_c}\sum_{k = 1}^{K} M_{nearest}(T_{\zeta_j}, h_k)
\end{aligned}</script><p>如上述，第一行和第二行表示取当前层空间和下一层空间所有解的每一个激光束遍历所有位置取最大匹配值（注意：对每一个激光束取得分最大值的位姿可能会不同），显然对第一个式子大于等于第二个，因为搜索范围更大；第三行则是对下一层所有解空间挑出一个位姿使得所有激光束的得分之和最大，第二个式子的结果大于等于第三个，因为对单个位姿而言并不一定能保证所有激光束的匹配结果都是最大。得分函数是预先计算的，在进行计算的时候可以直接取，因此这是一种空间换时间的做法。</p>
<h3 id="分枝定界算法——算法流程"><a href="#分枝定界算法——算法流程" class="headerlink" title="分枝定界算法——算法流程"></a>分枝定界算法——算法流程</h3><p>以下是两种分枝定界算法的算法流程伪代码</p>
<img src="/2020/05/24/lidarSLAM-frontend-2/%E5%88%86%E6%9E%9D%E5%AE%9A%E7%95%8C.png" class="" title="lidarSLAM-frontend-2">
]]></content>
      <categories>
        <category>激光slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>lidar-slam</tag>
      </tags>
  </entry>
  <entry>
    <title>[CMU-15-445/645] Buffer Pool</title>
    <url>/2020/05/02/CMU-DB-5-buffer-pool/</url>
    <content><![CDATA[<p>这是我在学习<a href="https://15445.courses.cs.cmu.edu/fall2019/" target="_blank" rel="noopener">Databases Systems CMU 15-445/645/ Fall 2019</a>过程记录的一些笔记，这次学习的第五课。总体来说，DBMS 在内存分配管理上能够比操作系统做得好很多（因为有对数据的额外信息），这次课主要包括了对内存的管理因为各类内存置换策略。</p>
<a id="more"></a>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>这节课主要要解决的一个问题是：DBMS(database mangement system) 如何管理它的内存 (memory) 使用以及数据在磁盘( disk ) 之间的来回转移，主要从以下两个方面来体现：</p>
<ul>
<li><strong>空间控制</strong>：在磁盘的哪个位置写入 page，能够使得对于一起使用的 page 能够尽量保证他们在磁盘的位置也是靠近的</li>
<li><strong>时间控制</strong>：什么时候读取 page 进内存以及什么时候将 page 写进磁盘，能够使得对磁盘的读写次数尽可能少</li>
</ul>
<p>同样还是看下以磁盘为中心（主要存储位置）的 dbms 的结构：</p>
<img src="/2020/05/02/CMU-DB-5-buffer-pool/dbms.png" class="" title="CMU-DB-5-buffer-pool">
<p>之前的课程已经介绍了关于 disk 的部分，也就是数据库如何在 disk 里面进行存储的，接下来要讲的是 memory 部分，主要是缓存池的管理已经数据的写入和写出。</p>
<h2 id="Buffer-Pool-Manager-（缓存池管理）"><a href="#Buffer-Pool-Manager-（缓存池管理）" class="headerlink" title="Buffer Pool Manager （缓存池管理）"></a>Buffer Pool Manager （缓存池管理）</h2><p>首先，看一下缓存池的<em>组织结构</em>。在内存的区域空间被分成一系列固定尺寸的 page 的数组，每个数组参数被称为一帧 (frame)。每当 DBMS 请求一个 page 的时候，缓存池会从 disk 里面复制（不做任何修改）一个 page 进入一个 frame 当中，如下图所示：</p>
<img src="/2020/05/02/CMU-DB-5-buffer-pool/page_frame.png" class="" title="CMU-DB-5-buffer-pool">
<p>缓存池除了 frame 之外，还需要维护关于内存里存在的 page 的元数据（meta-data），主要通过 page-table来管理维护。 page-table 原理上是一个哈希表来追踪当前在内存里的 page，除此之外，对于每个 page 来说，还需要有一些额外的变量来维护其他信息，如 Dirty Flag (当前page从读入之后是否被修改过)，Pin/Reference Counter （当前page 是不是正在被使用/被使用过多少次）等等。如下图所示：</p>
<img src="/2020/05/02/CMU-DB-5-buffer-pool/page_table.png" class="" title="CMU-DB-5-buffer-pool">
<p>在介绍缓存池管理方法之前，需要区分以下两个概念：</p>
<ul>
<li><p>Locks：</p>
<ul>
<li>保护数据库的逻辑内容不被其他传输（数据交换）干扰</li>
<li>在整个传输持续期间都在起作用</li>
<li>可以回退这个操作（撤销）</li>
</ul>
</li>
<li><p>Latches:</p>
<ul>
<li>保护 dbms 的关键部分（critical sections）不被其他线程干扰</li>
<li>整个操作期间保持</li>
<li>不需要可以回退操作  </li>
</ul>
</li>
</ul>
<p>在操作系统里面我们常用的锁( mutex )其实是这里的第二个概念，更多的是关注不同线程在同一个区域共同操作的时候引起的互相干扰，数据库里的锁是第一个概念，需要实现的功能更加复杂一些，在底层也是通过 latches 来实现的。</p>
<p>接下来看一下页目录 (page directory) 和页表 (page table) 的区别：</p>
<ul>
<li>page directory: 通过 page ids 能够定位 page 在数据库文件中的位置（所有的修改都需要写入到 disk 里面，使得机器断电/重启后还能够使用）</li>
<li>page table：通过 page ids 能够找到在缓存池里面的 page 对应的 frame 的位置（不需要长期保存，所以不需要保持在 disk 里面）</li>
</ul>
<p>关于内存分配策略，有两种思路：</p>
<p><em>Global Policies</em> （全局策略）：做决定的时候考虑所有现存的传输记录（transaction）</p>
<p><em>Local Policies</em> （局部策略）：分配 frame 只关注当前某个传输记录，不需要考虑其他记录，但是同样需要可以支持 pages 在不同传输之间能工共享。</p>
<p>接下来讲一下缓存池的几种优化方法。</p>
<h3 id="Multiple-Buffer-Pools"><a href="#Multiple-Buffer-Pools" class="headerlink" title="Multiple Buffer Pools"></a>Multiple Buffer Pools</h3><p>首先可以考虑使用多个缓存池，目前大部分商用的 DBMS 在使用的时候都不止有一个缓存池，可以根据不同分类来使用多个缓存池，比如：每个 table 使用一个缓存池/每个数据库使用一个缓存池或者每个 page 类型（tuple, index）使用一个缓存池。这样做的好处有：可以提高某些操作的运行速度，同时可以减少 latch 的使用提升效率（一个传输在修改 page-table 的时候，另一个传输操作可以同时访问另一个缓存池的 page-table 等等）。</p>
<p>有两种方法可以来维护多个缓存池，分别是：</p>
<ul>
<li>object id：可以在每个传输记录里面额外加一个 object id 来以此将其映射到某个缓存池中</li>
<li>Hashing：可以直接通过哈希表的方式将 page id 映射到某个缓存池上。</li>
</ul>
<h3 id="Pre-fetching"><a href="#Pre-fetching" class="headerlink" title="Pre-fetching"></a>Pre-fetching</h3><p>我们还可以通过根据一个查询计划来提前读入一些pages，主要包括两种方法：顺序扫描（sequential scan），索引扫描（index scans）。具体参考下面例子：</p>
<p>假设我们要执行以下查询操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A</span><br><span class="line">    <span class="keyword">WHERE</span> val <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">250</span></span><br></pre></td></tr></table></figure>
<p>然后我们对对应的 index-page 存储方式如下所示：</p>
<img src="/2020/05/02/CMU-DB-5-buffer-pool/pre_fetching.png" class="" title="CMU-DB-5-buffer-pool">
<p>首先缓存池会顺序扫描 disk 上的页并读入到缓冲池中（page0, page1），当读取到 page1 的时候，通过 page1 我们知道 page3 的 val 是 100-199（二叉树存储）；我们也知道我们需要查询的的范围是 100 - 250，所以我们可以根据我们是通过二叉树存储从而通过 page3 定位到 page5，并进而把那两个页面读入进来，而不需要逐一访问 page2, page4。我们之所以能够这么做是因为 DBMS 知道其内部是怎么存储数据的也能通过对 query 操作的分析来获取需要哪些 page，这是通用操作系统做不到的。</p>
<h3 id="Scan-Sharing"><a href="#Scan-Sharing" class="headerlink" title="Scan Sharing"></a>Scan Sharing</h3><p>Scan Sharing 指的是，不同 queries 之间可以对其他 queries 的操作/或者存储的数据进行重复使用；允许多个 quries 重用一个扫描指针来扫描 table （共享扫描结果），可以共享中间结果。注意这个和对结果的缓存不是同一个概念（结果的缓存（result caching）指的是你在之前进行一个 query 操作之后结果被缓存了，当你再一起进行这个操作的时候可以直接获取上一次的结果），这里的不同 query 不需要完全一样，只要其中有部分中间操作有共同点就可以共享。</p>
<p>具体的实现方法可以是：当一个 query 开始对一个 table 进行扫描的时候已经有另一个 query 进行扫描的话， DBMS 会直接将第二个 query 的扫描指针放在正在进行的扫描指针上，同时 DBMS 会记录第二个 query 的扫描是在什么地方可以加入的，这样当扫描指针扫描到 table 结尾的时候可以从头开始并且知道到哪里结束。</p>
<p>目前已知 IBM DB2 和 MSSQL 支持这项技术。</p>
<h3 id="Buffer-Pool-Bypass"><a href="#Buffer-Pool-Bypass" class="headerlink" title="Buffer Pool Bypass"></a>Buffer Pool Bypass</h3><p>在有一些操作的时候，通过 sequential scan 操作扫描的的 page 不会存储到缓存池里面，主要是因为：</p>
<ul>
<li>对于一个 query 来说，内存本来就是局部的位置，当 query 结束的时候，内存里所有的frame 的 page 都会被释放，所以在某些情况不如直接绕过（尤其是当这些 page 不需要长期使用的时候）</li>
<li>当某个操作需要查找一个很长的而且在 disk 里面是连续的 page 的时候能够提升一点效率</li>
<li>也可以用在一些中间数据上（sorting, joins）</li>
</ul>
<h3 id="OS-Page-Cache"><a href="#OS-Page-Cache" class="headerlink" title="OS Page Cache"></a>OS Page Cache</h3><p>值得注意的时候，大部分有关 disk 的操作都是通过操作系统 api 来进行，除非特殊制定，否则操作系会维护自身的文件系统缓存。目前大部分 DBMS 通过 直接 I/O 来绕过操作系统的缓存（避免产生大量的 page 的副本和不同策略的冲突）。</p>
<p>这里建议看一下老师用 postgres 进行实际操作已经对 buffer pool 的演示。具体 Youtube 链接在<a href="https://www.youtube.com/watch?v=uZ3-aeFYE5k&amp;list=PLSE8ODhjZXjbohkNBWQs_otTrBTrjyohi&amp;index=5" target="_blank" rel="noopener">这里</a>，从40分钟左右开始。</p>
<h2 id="Replacement-Policies-（置换策略）"><a href="#Replacement-Policies-（置换策略）" class="headerlink" title="Replacement Policies （置换策略）"></a>Replacement Policies （置换策略）</h2><p>这一部分主要讨论当 DBMS 需要释放掉某一个 frame 来放新的 page 的时候，应该怎么决定来使得：</p>
<ul>
<li>正确性</li>
<li>准确性（释放的 page 短期内不会重用）</li>
<li>速度</li>
<li>元数据释放掉的话需要重新读取数据会使得效率下降</li>
</ul>
<p>下面讨论几种方法</p>
<h3 id="LRU-least-recntly-used"><a href="#LRU-least-recntly-used" class="headerlink" title="LRU(least recntly used)"></a>LRU(least recntly used)</h3><p>这是一种比较常用的方法，通过维护每个页面上一次使用的时间戳，每次需要释放的时候， DBMS 释放掉一个最不经常使用（上一次使用时间最远）的page。另外可以通过对 page 进行排序来减少搜索的时间。</p>
<h3 id="CLOCK"><a href="#CLOCK" class="headerlink" title="CLOCK"></a>CLOCK</h3><p>CLOCK 是一种对 LRU 的模拟方法，它不需要对每个 page 额外维护一个时间戳，具体实现方法如下：</p>
<ul>
<li>对每个 page 有一个 reference bit 记录是否被访问过（访问过之后设为 1）</li>
<li>将所有 pages 以一个环形来组织，如下图所示，在需要释放 frame 的时候，顺时针访问每个 frame：<ul>
<li>如果当前 page reference bit 为 1，将其设为 0</li>
<li>如果当前为 0，就把他释放掉</li>
</ul>
</li>
</ul>
<img src="/2020/05/02/CMU-DB-5-buffer-pool/clock.png" class="" title="CMU-DB-5-buffer-pool">
<h3 id="LRU-和-CLOCK-的问题"><a href="#LRU-和-CLOCK-的问题" class="headerlink" title="LRU 和 CLOCK 的问题"></a>LRU 和 CLOCK 的问题</h3><p>对于一个序列操作来说（扫描整个table），LRU 和 clock 反而可能会使效率下降，因为大部分数据只会在扫描的时候被读入进来一次然后再也不会使用，这样的话，最经常使用的 page （最后一个被扫描进来的） 实际上可能是最不需要的 page，具体可以参考以下例子，执行 Q1 的时候先把 page 0 读进来，然后执行 q2 的时候因为是一个扫描操作所以按顺序读取 page1 和 page2 进来，当需要读 page3 的时候，因为 lru 所以把 page0 释放掉了，注意如果我们接下来执行的 q3 和 q0 一样化，page0 才是我们需要保留的：</p>
<img src="/2020/05/02/CMU-DB-5-buffer-pool/%E4%BE%8B%E5%AD%90.png" class="" title="CMU-DB-5-buffer-pool">
<h3 id="改进的策略"><a href="#改进的策略" class="headerlink" title="改进的策略"></a>改进的策略</h3><ul>
<li>追踪前 k 个被访问的 page 并根据时间戳来计算某个相邻 page 的访问时间，并以此来估计当前 page 下一次被访问的时间。</li>
<li>定位：DBMS追踪每个 query 使用的 page，并针对其来进行选择哪个释放，这样可以最大程度的避免因为一个 query 的操作来将另一个 query 常使用的page 释放掉</li>
<li>优先级提示：因为DBMS知道query中涉及的每个 page 的内容，可以用它来提示哪个 page 更加重要</li>
</ul>
<h3 id="Dirty-Page"><a href="#Dirty-Page" class="headerlink" title="Dirty Page"></a>Dirty Page</h3><p>我们有两种方式来处理 dirty page（被修改过的）：</p>
<ul>
<li>快速方法：如果当前 page 没被修改过，可以直接释放掉，无需和 disk 进行交互</li>
<li>慢：如果当前 page 修改过，需要将其重新写入 disk</li>
</ul>
<p>我们选择哪类 page 来释放的时候需要考虑 trade off: 快速释放没被修改过的 page （但是有可能经常访问）还是 写入一个在短时间都不会访问的但是被修改过的 page。DBMS 可以周期性的进行一些后台访问 page table 并将 dirty page　写入　disk　里然后重置它的　dirty flag（但是需要注意不能再　dirty flag 被设为１和 该页实际被修改之间的时间进行写入！）。</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>lidarSLAM - 第四次作业</title>
    <url>/2020/05/01/lidarSLAM-hw4/</url>
    <content><![CDATA[<p>本文是我在学习深蓝学院的<a href="https://www.shenlanxueyuan.com/course/152" target="_blank" rel="noopener">激光slam课程</a>第四次作业的笔记。本次作业主要是熟悉 imls-icp 的过程以及对 csm 接口调用，除此之外还有对课上讲的四种 icp 算法进行总结以及想一下 icp 的改进思路。</p>
<a id="more"></a>
<h2 id="实现两帧之间的-IMLS-ICP-激光匹配"><a href="#实现两帧之间的-IMLS-ICP-激光匹配" class="headerlink" title="实现两帧之间的 IMLS-ICP 激光匹配"></a>实现两帧之间的 IMLS-ICP 激光匹配</h2><blockquote>
<p>补充代码,实现两帧间的 IMLS-ICP 激光匹配;</p>
</blockquote>
<h3 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h3><p>编程环境： <code>ubuntu 18.04 + ROS medodic</code><br>IDE: CLion, 安装官方教程配置：</p>
<ul>
<li>以项目方式打开想要编译的 package 文件夹中的 <code>CMakeLists.txt</code></li>
<li>CMake设置中： Generation path 设置成 <code>WORKSPACE_PATH/build</code></li>
<li>Cmake Option: <code>-DCATKIN_DEVEL_PREFIX:PATH=WORKSPACE_PATH/devel</code></li>
</ul>
<p>本次作业只给了模块代码，所以可以放在上次给的工作空间/自己的工作空间里编译运行。首先，需要安装好一些需要的模块：</p>
<ul>
<li>champion_nav_msgs：这个模块在上一次作业也有用到，如果上次安装了这次就不用了，否则可以根据内部的 <code>readme.md</code> 自行编译安装，注意 ros 版本的差异更改对应文件的对应位置。</li>
<li>libnabo: 参考<a href="https://blog.csdn.net/qq_36501182/article/details/79043592" target="_blank" rel="noopener">这篇教程</a></li>
<li>csm：第二次作业有用到，可以根据<a href="https://guoxiaotao.xyz/2020/04/25/ros-melodic-csm/">这篇教程</a>选择自己喜欢的方式安装，安装完成后在 <code>CMakeLists.txt</code> 修改csm的对应路径位置。</li>
</ul>
<p>另外注意一下 melodic 下安装的 pcl 版本貌似是1.8的，需要在对应 <code>hpp</code>， <code>CMakeLists.txt</code> 下修改需要的 pcl 版本。</p>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>老规矩，还是先阅读给定的框架代码，了解代码结构再考虑补全。</p>
<p><code>main.cpp</code>：和之前的作业类似，在一个定义好的类 <code>imlsDebug</code> 里面完成所有项目需要的基本函数（数据读取、初始化、话题订阅/发布），用另一个类 <code>imls_icp</code> 完成作业需要的功能（针对这次作业而言，就是激光数据配准）。</p>
<p><code>imlsDebug</code>：六个函数和一些成员变量，主要功能如下：</p>
<ul>
<li><p>构造函数：初始化两条路径的发布话题信息（ imls-icp 生成的和 odom 生成的）、利用<code>rosbag:View</code> 来读取 rosbag 中的话题信息（激光和里程计数据），并逐条处理，手动进入相应的 callback函数。（rosbag 读取的 api 可以参考<a href="http://wiki.ros.org/rosbag/Code%20API" target="_blank" rel="noopener">官方文档</a>）</p>
</li>
<li><p><code>void odomCallback(...)</code> 和 <code>pubPath(const nav_msgs::OdometryConstPtr&amp; msg, ...)</code> : 简单的接收里程计数据并发布</p>
</li>
<li><p><code>void ConvertChampionLaserScanToEigenPointCloud(...)</code>：工具函数，将激光扫描数据（距离，角度）换算成2d坐标（x, y）</p>
</li>
<li><p><code>void championLaserScanCallback(...)</code>：先将激光数据转换成点云，调用 <code>imls_icp</code> 中的方法对上一阵点云数据进行匹配，匹配成功的话输出当前帧位姿（通过上一阵位姿乘相对位姿变换）并发布</p>
</li>
<li><p><code>void pubPath(Eigen::Vector3d&amp; pose, nav_msgs::Path &amp;path, ros::Publisher &amp;mcu_path_pub_)</code>：发布由 imls-icp 生成的位姿</p>
</li>
</ul>
<p><code>imls_icp</code>类中功能函数比较多，大部分函数名字和注释都能说明功能，这里不赘述，只介绍一下几个核心的功能函数：</p>
<ul>
<li><p><code>projSourcePtToSurface(...)</code> ：将当前帧点云投影到上一阵点云构造的曲面上（对每个店调用下面的函数），并去除匹配不合格的点，计算输出匹配后的点云和法向量</p>
</li>
<li><p><code>bool ImplicitMLSFunction(Eigen::Vector2d x, double&amp; height)</code>：将当前激光点投影到上一帧曲面上，计算高度；大致流程是利用 kd 数搜索距离当前点最近的三个点（需要具有代表性）构造平面，进行投影。</p>
</li>
<li><p><code>SolveMotionEstimationProblem()</code>：已知匹配后的对应点和法向量，计算相对位姿，这部分已经写好了</p>
</li>
</ul>
<p>我们需要完成的有三个函数：<code>computeNormal()</code>（给定某个点周围的 n 个点，计算法向量），<code>ImplictMLSFunction()</code> 的高度计算部分（参考课上学习的公式），<code>projSourcePtToSurface()</code>将匹配后的点转换成点云和法向量输出。</p>
<h3 id="代码补充"><a href="#代码补充" class="headerlink" title="代码补充"></a>代码补充</h3><ul>
<li><code>ComputeNormal</code>：补充如下，基本参考课上内容，利用 pca 求解法向量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief IMLSICPMatcher::ComputeNormal</span></span><br><span class="line"><span class="comment"> * 计算法向量</span></span><br><span class="line"><span class="comment"> * @param nearPoints    某个点周围的所有激光点</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Eigen::Vector2d <span class="title">IMLSICPMatcher::ComputeNormal</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Eigen::Vector2d&gt; &amp;nearPoints)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Vector2d normal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据周围的激光点计算法向量，参考ppt中NICP计算法向量的方法</span></span><br><span class="line">    <span class="comment">// 计算周围点的几何中心</span></span><br><span class="line">    Eigen::Vector2d meanPoints = Eigen::Vector2d::Zero();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p: nearPoints) &#123;</span><br><span class="line">        meanPoints += p;</span><br><span class="line">    &#125;</span><br><span class="line">    meanPoints /= nearPoints.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方差</span></span><br><span class="line">    Eigen::Matrix2d sigma = Eigen::Matrix2d::Zero();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p: nearPoints) &#123;</span><br><span class="line">        Eigen::Vector2d diff = p - meanPoints;</span><br><span class="line">        sigma += diff * diff.transpose();</span><br><span class="line">    &#125;</span><br><span class="line">    sigma /= nearPoints.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特征分解</span></span><br><span class="line">    <span class="function">Eigen::EigenSolver&lt;Eigen::Matrix2d&gt; <span class="title">solver</span><span class="params">(sigma)</span></span>;</span><br><span class="line">    <span class="comment">// 取出特征值和特征向量</span></span><br><span class="line">    Eigen::MatrixXd eigenvalue = solver.eigenvalues().real();</span><br><span class="line">    Eigen::MatrixXd eigenvector = solver.eigenvectors().real();</span><br><span class="line">    Eigen::Index evalsMin;</span><br><span class="line">    <span class="comment">// 找到最小特征值的位置</span></span><br><span class="line">    eigenvalue.rowwise().sum().minCoeff(&amp;evalsMin);</span><br><span class="line">    <span class="comment">// 取出该列</span></span><br><span class="line">    normal &lt;&lt; eigenvector(<span class="number">0</span>, evalsMin), eigenvector(<span class="number">1</span>, evalsMin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ImplicitMLSFunction</code>：这个函数主要是补充高度计算部分，按照论文里的公式计算即可：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TODO</span></span><br><span class="line"><span class="comment">//根据函数进行投影．计算height，即ppt中的I(x)</span></span><br><span class="line"><span class="keyword">double</span> sum1 = <span class="number">0.0</span>, sum2 = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nearPoints.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">auto</span> p_i = nearPoints[i];</span><br><span class="line">    <span class="keyword">auto</span> normal_i = nearNormals[i];</span><br><span class="line">    <span class="keyword">auto</span> diff = x - p_i;</span><br><span class="line">    <span class="keyword">double</span> wi = <span class="built_in">exp</span>(- (diff.squaredNorm()) / (m_h * m_h));</span><br><span class="line">    sum1 += (wi * (diff.dot(normal_i)));</span><br><span class="line">    sum2 += wi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">height</span> = sum1 / sum2;</span><br><span class="line"><span class="comment">//end of TODO</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>projSourcePtToSurface</code> 这个主要是补充计算匹配后的点云 <code>yi</code>，同样按照论文公式计算即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TODO</span></span><br><span class="line"><span class="comment">//计算yi．</span></span><br><span class="line">yi = xi - <span class="built_in">height</span> * nearNormal;</span><br><span class="line"><span class="comment">//end of TODO</span></span><br></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>补充完成后运行结果如下所示：红色为根据 imls 算出的位姿轨迹，蓝色为 odom 的位姿轨迹。虽然由于没有进行后端优化导致后面轨迹飘了，但是整体来看大致方向是对的。</p>
<img src="/2020/05/01/lidarSLAM-hw4/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.png" class="" title="lidarSLAM-hw4">
<h2 id="用-csm-进行激光匹配比较结果"><a href="#用-csm-进行激光匹配比较结果" class="headerlink" title="用 csm 进行激光匹配比较结果"></a>用 csm 进行激光匹配比较结果</h2><blockquote>
<p>将第一题 IMLS-ICP 匹配的接口换成第二次作业中 CSM 库的 ICP 匹配接口,并生成激光匹配的轨迹</p>
</blockquote>
<h3 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h3><p>这一题主要是熟悉 csm 的接口并调用，主要是以下几个部分：</p>
<p>添加以下成员变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// csm 进行 pl-icp 需要的变量</span></span><br><span class="line"><span class="keyword">bool</span> run_pl_icp = <span class="literal">true</span>;</span><br><span class="line">LDP m_prevLDP;</span><br><span class="line">sm_params m_PIICPParams;</span><br><span class="line">sm_result m_OutputResult;</span><br></pre></td></tr></table></figure>
<p>添加 csm 相关的函数，注意部分变量的修改以及 <code>LaserScan</code> 和 <code>ChampionNavLaserScan</code> 之间的差异</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进行pl-icp的相关函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetPIICPParams</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LaserScanToLDP</span><span class="params">(<span class="keyword">const</span> champion_nav_msgs::ChampionNavLaserScanConstPtr&amp; pScan,</span></span></span><br><span class="line"><span class="function"><span class="params">                        LDP&amp; ldp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nPts = pScan-&gt;ranges.<span class="built_in">size</span>(); <span class="comment">// intensity 在 ChampionNavLaserScan 没用</span></span><br><span class="line">        ...</span><br><span class="line">        ldp-&gt;theta[i] = pScan-&gt;angles[i]; <span class="comment">// ChampionNavLaserScan 不规定统一角度间隔，所以可以直接取</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Eigen::Vector3d  <span class="title">PIICPBetweenTwoFrames</span><span class="params">(LDP&amp; currentLDPScan,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           Eigen::Vector3d tmprPose)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>然后在构造函数中进行 csm 的相关设置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">imlsDebug()</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行 pl-icp 相关设置</span></span><br><span class="line">        m_prevLDP = <span class="literal">NULL</span>;</span><br><span class="line">        SetPIICPParams();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取 rosbag 信息</span></span><br><span class="line">        rosbag::Bag bag;</span><br><span class="line">        bag.<span class="built_in">open</span>(bagfile, rosbag::bagmode::Read);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后在激光数据的 <code>callback</code> 函数中增加使用 pl-icp 匹配的分支：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(m_isFirstFrame == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"First Frame"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            m_isFirstFrame = <span class="literal">false</span>;</span><br><span class="line">            m_prevLaserPose = Eigen::Vector3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            pubPath(m_prevLaserPose, m_imlsPath, m_imlsPathPub);</span><br><span class="line">            <span class="comment">// 针对不同匹配算法做不一样的设置</span></span><br><span class="line">            <span class="keyword">if</span> (!run_pl_icp) &#123;</span><br><span class="line">                ConvertChampionLaserScanToEigenPointCloud(msg, m_prevPointCloud);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LaserScanToLDP(msg, m_prevLDP);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!run_pl_icp) &#123; <span class="comment">// 使用 imls-icp 匹配</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 用 csm 进行 pl-icp</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//把当前的激光数据转换为 pl-icp能识别的数据 &amp; 进行矫正</span></span><br><span class="line">            <span class="comment">//d_point_scan就是用激光计算得到的两帧数据之间的旋转 &amp; 平移</span></span><br><span class="line">            LDP currentLDP;</span><br><span class="line">            LaserScanToLDP(msg, currentLDP);</span><br><span class="line">            Eigen::Vector3d d_point_scan = PIICPBetweenTwoFrames(currentLDP, Eigen::Vector3d::Zero());</span><br><span class="line">            Eigen::Matrix3d lastPose, rPose;</span><br><span class="line"></span><br><span class="line">            lastPose &lt;&lt; <span class="built_in">cos</span>(m_prevLaserPose(<span class="number">2</span>)), -<span class="built_in">sin</span>(m_prevLaserPose(<span class="number">2</span>)), m_prevLaserPose(<span class="number">0</span>),</span><br><span class="line">                        <span class="built_in">sin</span>(m_prevLaserPose(<span class="number">2</span>)),  <span class="built_in">cos</span>(m_prevLaserPose(<span class="number">2</span>)), m_prevLaserPose(<span class="number">1</span>),</span><br><span class="line">                        <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            rPose &lt;&lt; <span class="built_in">cos</span>(d_point_scan(<span class="number">2</span>)), -<span class="built_in">sin</span>(d_point_scan(<span class="number">2</span>)), d_point_scan(<span class="number">0</span>),</span><br><span class="line">                    <span class="built_in">sin</span>(d_point_scan(<span class="number">2</span>)),  <span class="built_in">cos</span>(d_point_scan(<span class="number">2</span>)), d_point_scan(<span class="number">1</span>),</span><br><span class="line">                    <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            Eigen::Matrix3d nowPose = lastPose * rPose;</span><br><span class="line">            m_prevLaserPose &lt;&lt; nowPose(<span class="number">0</span>, <span class="number">2</span>) , nowPose(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">atan2</span>(nowPose(<span class="number">1</span>, <span class="number">0</span>), nowPose(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            pubPath(m_prevLaserPose, m_imlsPath, m_imlsPathPub);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="pl-icp-运行结果"><a href="#pl-icp-运行结果" class="headerlink" title="pl-icp 运行结果"></a>pl-icp 运行结果</h3><p>运行结果如下所示，使用 pl-icp 的速度明显变快，但由于没有优化结果同样也发生了漂移。</p>
<img src="/2020/05/01/lidarSLAM-hw4/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C2.png" class="" title="lidarSLAM-hw4">
<h2 id="比较各类-ICP-算法的特点以及异同"><a href="#比较各类-ICP-算法的特点以及异同" class="headerlink" title="比较各类 ICP 算法的特点以及异同"></a>比较各类 ICP 算法的特点以及异同</h2><blockquote>
<p>阅读 ICP 相关论文,总结课上所学的几种 ICP 及其相关变型并简述其异同(ICP,PL-ICL,NICP,<br>IMLS-ICP)</p>
</blockquote>
<p>课上讲解的几种 ICP 算法的基本思路都是类似的：找到前后两帧激光扫描数据的匹配关系，并根据匹配关系迭代找到相对位姿的最优值，主要的差异就是<strong>寻找对应点（匹配关系）</strong>以及<strong>计算误差</strong>两方面，几种 ICP 算法的详细说明可以参考我的<a href="https://guoxiaotao.xyz/2020/04/28/lidarSLAM-frontend-1/">上篇博客</a>。</p>
<h2 id="ICP-算法改进思路"><a href="#ICP-算法改进思路" class="headerlink" title="ICP 算法改进思路"></a>ICP 算法改进思路</h2><blockquote>
<p>简答题,开放性答案:现在你已经了解了多种 ICP 算法,你是否也能提出一种改进的 ICP 算法,或能提<br>升 ICP 总体匹配精度或速度的技巧?请简述你的改进策略。</p>
</blockquote>
<p>两个方面：</p>
<ul>
<li>精度上可以采用合理的方法提供初值（目前是人工设置）：其他传感器（odom等），用 Ransac 去除 outlier</li>
<li>效率上可以对点云采样（提高匹配速度）</li>
</ul>
]]></content>
      <categories>
        <category>激光slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>lidar-slam</tag>
      </tags>
  </entry>
  <entry>
    <title>激光SLAM 前端配准方法 - 基于 ICP 及其变种的方法</title>
    <url>/2020/04/28/lidarSLAM-frontend-1/</url>
    <content><![CDATA[<p>本文是我在学习深蓝学院的<a href="https://www.shenlanxueyuan.com/course/152" target="_blank" rel="noopener">激光slam课程</a>前端配准第一部分的学习笔记，前面几次基本把数据的预处理讲完了，本次课开始学习 slam 的内容，这次主要是讲了前端配准算法。</p>
<p>无论是激光 slam 还是视觉 slam， 大部分都分成两个部分：前端和后端。其中后端的话各种 slam 都差不多，主要是根据数学公式求解类似 $Ax = b$ 的公式，而不同 slam 方法的前端可以有各种方法。前端总体来说无论是视觉还是激光都是起到一个里程计的作用，本次主要是学习帧间匹配算法中类 ICP 的方法，包括：ICP 匹配方法、PL-ICP 匹配方法、NICP 匹配方法和IMLS-ICP 匹配方法。</p>
<a id="more"></a>
<h2 id="ICP-匹配方法"><a href="#ICP-匹配方法" class="headerlink" title="ICP 匹配方法"></a>ICP 匹配方法</h2><p>关于原始 ICP 匹配方法算法和原理都在前面的两篇笔记（<a href="https://guoxiaotao.xyz/2020/04/23/lidarSLAM-hw1/">lidarSLAM 第二次作业</a>和<a href="https://guoxiaotao.xyz/2020/04/21/lidarSLAM-3/">激光雷达运动畸变去除</a>）记录过了，这里不再赘述。</p>
<h2 id="PL-ICP-匹配方法"><a href="#PL-ICP-匹配方法" class="headerlink" title="PL-ICP 匹配方法"></a>PL-ICP 匹配方法</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>相对于原始的 ICP 算法中用点与点之间的距离作为误差， PL-ICP 是把点到线的距离作为误差。PL-ICP 的基本思想是：激光点是对实际环境中曲面的离散采样，在匹配过程中重要的不是激光点，而是隐藏在激光点中的曲面。这个很好理解，因为在前后两帧激光扫描数据中，我们<strong>不一定会准确扫描到上一帧的每个点</strong>（这个时候用点和点的距离作为误差就是有问题的），更大可能是<strong>扫到了同一个物体（曲面）上的不同点</strong>，所以相较于用点对点的距离作为误差，把点到实际曲面的距离作为误差尺度应该是更符合实际的。所以问题就变成了如何恢复曲面。不同算法有不同的恢复方法，PL-ICP 的方法是用<strong>分段线性的方法对实际曲面进行近似</strong>，以此来定义点到曲面的距离，不同方法的误差表示如下图所示。</p>
<img src="/2020/04/28/lidarSLAM-frontend-1/pl-icp.png" class="" title="lidarSLAM-frontend-1">
<h3 id="数学描述"><a href="#数学描述" class="headerlink" title="数学描述"></a>数学描述</h3><p>我们可以将原始 ICP 算法的目标函数看成以下形式：</p>
<script type="math/tex; mode=display">
\min_{\mathbf{q}}\sum_{i}||\mathbf{p}_i \oplus \mathbf{q} - \prod\{S^{ref}, \mathbf{p}_i \oplus \mathbf{q}\}||^2</script><p>其中，</p>
<script type="math/tex; mode=display">
q = (\mathbf{t}, \theta)</script><script type="math/tex; mode=display">
(\mathbf{p} \oplus (\mathbf{t}, \theta) \triangleq \mathbf{R}(\theta)\mathbf{p} + \mathbf{t})</script><p>$S^{ref}$ 代表参考激光帧生成曲面上的投影，这里我的理解是由于原始 ICP 没有考虑曲面的影响而是直接匹配每一个点，所以对该点处曲面的投影就是该点，所以对 ICP 而言，$||\mathbf{p}_i \oplus \mathbf{q} - \prod\{S^{ref}, \mathbf{p}_i \oplus \mathbf{q}\}|| = ||\mathbf{p}_i \oplus \mathbf{q} - x_i||, x_i$ 就是匹配点。</p>
<p>然后给定初始解对下式进行迭代：</p>
<script type="math/tex; mode=display">
\min_{q_{k+1}}\sum_{i}||\mathbf{p}_i \oplus \mathbf{q}_{k+1} - \prod\{S^{ref}, \mathbf{p}_i \oplus \mathbf{q}_{k}\}||^2</script><p>PL-ICP 目标函数如下：</p>
<script type="math/tex; mode=display">
\min_{q_{k+1}}\sum_{i}(\mathbf{n}^T[\mathbf{p}_i \oplus \mathbf{q}_{k+1} - \prod\{S^{ref}, \mathbf{p}_i \oplus \mathbf{q}_{k}\}])^2</script><p>通过引入了法向量将误差从两个点的距离（差）变成了两点连线在曲面上的法向量的投影，即点到线的距离。</p>
<h3 id="求解过程-amp-具体算法"><a href="#求解过程-amp-具体算法" class="headerlink" title="求解过程 &amp; 具体算法"></a>求解过程 &amp; 具体算法</h3><p>我们的已知数据有：</p>
<ul>
<li>参考激光帧 $y_{t-1}$</li>
<li>当前激光帧 $y_t$</li>
<li>参考激光帧生成的曲面 $S^{ref}$</li>
<li>初始解 $q_o$</li>
</ul>
<p>需要求解的是两帧激光之间机器人的相对位姿关系 $q^*$</p>
<p>算法过程跟原始 ICP 类似：</p>
<ul>
<li>将当前帧的数据根据初始位姿 $q_k$ 投影到参考帧坐标系下</li>
<li>对于当前帧的点 $i$， 在参考帧中找到最近的两个点（因为要连成直线）$(j_1, j_2)$</li>
<li>计算直线误差，去除误差过大的点</li>
<li>最小化误差函数 $<br>\sum_{i}(\mathbf{n}^T[\mathbf{R}(\theta)\mathbf{p} + \mathbf{t} - p_{j_1^i}])^2<br>$</li>
</ul>
<h3 id="跟-ICP-的区别"><a href="#跟-ICP-的区别" class="headerlink" title="跟 ICP 的区别"></a>跟 ICP 的区别</h3><p>首先是<em>误差形式不同</em>，原始 ICP 将点对点的距离作为误差，PL-ICP 对点到线的距离作为误差；</p>
<p>其次两种算法<em>收敛速度</em>不同， ICP 为一阶收敛， PL-ICP 为二阶收敛，速度更快：</p>
<script type="math/tex; mode=display">
||q_{k} - q_{\infty}|| < c ||q_{k-1} - q_{\infty}||</script><script type="math/tex; mode=display">
||q_{k} - q_{\infty}||^2 < c ||q_{k-1} - q_{\infty}||^2</script><p>PL-ICP 的求解精度更高（更符合实际），尤其是在<em>人工结构化环境</em>中（直线多）；</p>
<p>PL-ICP 对初值更敏感，通常要结合里程计一起使用</p>
<h2 id="NICP-匹配方法"><a href="#NICP-匹配方法" class="headerlink" title="NICP 匹配方法"></a>NICP 匹配方法</h2><h3 id="NICP-基本思想"><a href="#NICP-基本思想" class="headerlink" title="NICP 基本思想"></a>NICP 基本思想</h3><p>相较于前两种 ICP 算法而言，他们都是考虑将距离（点到点，点到线）作为误差尺度， NICP 更关注面与面（2d 里是线与线）的误差；因此它还利用实际曲面的特征来对错误匹配点进行过滤，主要考虑的参数为法向量和曲率；因此在误差项里除了考虑对应点的欧氏距离以外，还考虑对应点法向量的角度差。</p>
<h3 id="NICP-数学描述"><a href="#NICP-数学描述" class="headerlink" title="NICP 数学描述"></a>NICP 数学描述</h3><p>首先有以下变量：</p>
<p>$p_i$ 表示激光点坐标 $(x, y, z)$</p>
<p>$n_i$ 表示对应点的法向量</p>
<p>$\sigma_i$ 对应点曲率</p>
<p>$\tilde{p}_i = (p_i, n_i)^T$ 为扩展点（坐标加法向量）</p>
<p>$T$ 表示欧式变换矩阵</p>
<p>$\oplus$ 对于 $\tilde{p}$ 的操作符（对于法向量只需要考虑旋转）：</p>
<script type="math/tex; mode=display">
T\oplus \tilde{p}_i = \begin{bmatrix}Rp_i + t \\ Rn_i\end{bmatrix}</script><p>则 NICP 的误差函数定义为：</p>
<script type="math/tex; mode=display">
\mathbf{e}_{ij}(\mathbf{T}) = (\tilde{p}_i^c - \mathbf{T}\oplus \mathbf{\tilde{p}}_j^r)</script><p>目标函数为：</p>
<script type="math/tex; mode=display">
\sum_c\mathbf{e}_{ij}(\mathbf{T})^T\mathbf{\tilde{\Omega}}_{ij}\mathbf{e}_{ij}(\mathbf{T})</script><p>其中，$\tilde{\Omega}_{ij}$ 为信息矩阵（表示权重）：</p>
<script type="math/tex; mode=display">
\mathbf{\tilde{\Omega}}_{ij} = \begin{bmatrix}\mathbf{\Omega}_i^s & \mathbf{0} \\
                                    \mathbf{0} & \mathbf{\Omega}_i^n\end{bmatrix}</script><h3 id="法向量和曲率的计算"><a href="#法向量和曲率的计算" class="headerlink" title="法向量和曲率的计算"></a>法向量和曲率的计算</h3><p>先找到点 $p_i$ 周围半径 $R$ 范围内的所有点 $V_i$，然后计算均值和方差</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mu_i^s &= \frac{1}{|V_i|}\sum_{p_j\in V_i}p_j \\
\Sigma_i^s &= \frac{1}{|V_i|}\sum_{p_j \in V_i}(p_j - \mu_i)(p_j - \mu_i)^T\\
\end{aligned}</script><p>然后对方差进行特征分解（2维情况下）,用类似于 PCA （主成分分析）的方法找出这堆点对应曲面的曲率和法向量：</p>
<script type="math/tex; mode=display">
\Sigma_i^s = R\begin{bmatrix}\lambda_1 & 0 \\0 & \lambda_2\end{bmatrix}R^T</script><p>对曲率的定义为： $\sigma_i = \frac{\lambda_1}{\lambda_1 + \lambda_2}$</p>
<p>对法向量的定义为：最小特征值对应的特征向量</p>
<h3 id="对点进行过滤"><a href="#对点进行过滤" class="headerlink" title="对点进行过滤"></a>对点进行过滤</h3><p>如果没有 well-define 的法向量（杂点），拒绝匹配该点</p>
<p>两点间距离大于阈值，拒绝： $||p_i^c - T\oplus p_j^r|| &gt; \epsilon_d$</p>
<p>两点曲率之差大于阈值，拒绝： $|\log{\sigma_i^c}-\log{\sigma_j^r}| &gt; \epsilon_\sigma$</p>
<p>两点法向量角度之差，拒绝： $\mathbf{n}_i^c\mathbf{T}\oplus\mathbf{n}_j^r &lt; \epsilon_n$</p>
<h3 id="目标函数求解"><a href="#目标函数求解" class="headerlink" title="目标函数求解"></a>目标函数求解</h3><p>目标函数为：</p>
<script type="math/tex; mode=display">
\sum_c\mathbf{e}_{ij}(\mathbf{T})^T\mathbf{\tilde{\Omega}}_{ij}\mathbf{e}_{ij}(\mathbf{T})</script><p>没办法求解析解，只能通过 LM 求解，具体求解方法后面讲优化的时候具体讲解。</p>
<h3 id="NICP-总结"><a href="#NICP-总结" class="headerlink" title="NICP 总结"></a>NICP 总结</h3><p>由于在寻找点匹配过程中考虑了法向量和曲率，可以提前排除一些错误的匹配；在开源领域是效果最好的匹配方法。</p>
<p>具体算法流程为：</p>
<p>计算参考激光帧和当前激光帧中每一个点的法向量和曲率（通过特征分解）。</p>
<p>根据当前解,把当前激光帧的点转换到参考坐标系中,并且根据欧式距离、法向量、曲率等信息来选择匹配点(也有可能没有匹配点)。</p>
<p>根据上面介绍的方法,用LM方法进行迭代求解,迭代收敛即可得到两帧激光数据之间的相对位姿。</p>
<h2 id="IMLS-ICP-匹配方法-（Implicit-Moving-Least-Square）"><a href="#IMLS-ICP-匹配方法-（Implicit-Moving-Least-Square）" class="headerlink" title="IMLS-ICP 匹配方法 （Implicit Moving Least Square）"></a>IMLS-ICP 匹配方法 （Implicit Moving Least Square）</h2><h3 id="IMLS-ICP-基本思想"><a href="#IMLS-ICP-基本思想" class="headerlink" title="IMLS-ICP 基本思想"></a>IMLS-ICP 基本思想</h3><p>跟前面两种方法一样，还是考虑从点云重建曲面，重要的是怎么重建平面使其更符合实际； IMLS-ICP 的思想是<strong>选择具有代表性的激光点来进行匹配</strong>,既能减少计算量同时又能减少激光点分布不均匀导致的计算结果出现偏移（在3d情况下尤其重要，因为点太多了）。</p>
<h3 id="代表点选取"><a href="#代表点选取" class="headerlink" title="代表点选取"></a>代表点选取</h3><p>具有丰富特征的点,即为结构化的点:具有良好的曲率和法向量的定义。</p>
<p>曲率越小的点越好,因为曲率为0代表着直线,代表着最结构化的点,也代表着具有非常好的法向量定义,能够提供足够的约束。</p>
<p>选点的时候需要注意选取的激光点的均衡以保证可观性,因为是平面匹配,不存在角度不可观的情况。只需要考虑X方向和Y方向的可观性。要保证两者的约束基本上是一致的,才能让结果不出现偏移。</p>
<h3 id="曲面重建"><a href="#曲面重建" class="headerlink" title="曲面重建"></a>曲面重建</h3><p>已知点云集合 $P_k$ 中每一个点 $p_i$ 的法向量 $n_i$ , 则 $P_k$ 中隐藏的曲面为:</p>
<script type="math/tex; mode=display">
I^{P_k}(x) = \frac{\sum_{p_i\in P_k}W_i(x)((x-p_i)^T\vec{n_i})}{\sum_{p_j\in P_k}W_j(x)}</script><p>其中，</p>
<script type="math/tex; mode=display">
W_i(x) = e^{-||x-p_i||^2/h^2}</script><p>$I^{P_k}(x) = 0$ 对应的集合表示曲面，空间中点到曲面的距离代入方程计算即可，证明过程看参考文献 <a href="http://graphics.berkeley.edu/papers/Kolluri-PGM-2005-08/sodatalk.pdf" target="_blank" rel="noopener">Provably good moving least square</a>。</p>
<h3 id="匹配求解"><a href="#匹配求解" class="headerlink" title="匹配求解"></a>匹配求解</h3><ul>
<li>当前帧中一点 $x_i$ 到曲面的距离为$I^{P_k}(x_i)$</li>
<li>$P_k$ 中离点 $x_i$ 最近点的法向量为 $n_i$</li>
<li>点 $x_i$ 在曲面的投影为：$y_i = x_i - I^{P_k}(x_i)n_i$</li>
<li>点 $x_i$ 和 点 $y_i$ 为对应的匹配点，求解误差： $\sum((Rx_i + t - y_i)n_i)^2$</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://ieeexplore.ieee.org/document/7353455" target="_blank" rel="noopener">NICP:Dense Normal Based Point Cloud Registration</a></li>
<li><a href="https://arxiv.org/abs/1802.08633" target="_blank" rel="noopener">IMLS:SLAM-scan-to-model matching based on 3D data</a></li>
</ul>
]]></content>
      <categories>
        <category>激光slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>lidar-slam</tag>
      </tags>
  </entry>
  <entry>
    <title>[CMU-15-445/645] Database Storage - Part 2</title>
    <url>/2020/04/26/CMU-DB-5-database-storage-2/</url>
    <content><![CDATA[<p>这是我在学习<a href="https://15445.courses.cs.cmu.edu/fall2019/" target="_blank" rel="noopener">Databases Systems CMU 15-445/645/ Fall 2019</a>过程记录的一些笔记，这次学习的第四课，主要是关于数据库存储的第二部分，主要是分析了 tuple 的不同存储方式。</p>
<a id="more"></a>
<h2 id="数据表现方式-Data-Representation"><a href="#数据表现方式-Data-Representation" class="headerlink" title="数据表现方式 Data Representation"></a>数据表现方式 Data Representation</h2><h3 id="Tuple-Storage"><a href="#Tuple-Storage" class="headerlink" title="Tuple Storage"></a>Tuple Storage</h3><p>在内部存储的时候， tuples 只是一系列的字节数组，在使用的时候 DBMS 根据其内部存储的 schema 数据去推断 tuple 的组织方式来读取它。</p>
<p>数据的表现形式在不同层面有不同表现：</p>
<ul>
<li>C/C++ 表现方式： <code>INTEGER</code>/<code>BIGINT</code>/<code>SMALLINT</code>/<code>TINYINT</code></li>
<li><p>IEEE-754 标准和定点小数（浮点 vs. 定点）：</p>
<ul>
<li><code>FLOAT/REAL</code> vs. <code>NUMERIC/DECMAL</code></li>
</ul>
</li>
<li><p>表头： <code>VARCHAR</code>/<code>VARBINARY</code>/<code>TEXT</code>/<code>BLOB</code></p>
</li>
<li>时间表现方式（Unix epoch 之后的（微）秒数）：<code>TIME</code>/<code>DATE</code>/<code>TIMESTAMP</code></li>
</ul>
<h3 id="数字的存储方式"><a href="#数字的存储方式" class="headerlink" title="数字的存储方式"></a>数字的存储方式</h3><p>DBMS 的用户只需要关注最后两种，前两种由开发者考虑（主要是第二个两种表现方式的区别），对于第一种而言，这种数据类型主要是用了原生的 C/C++ 的数据类型，也是符合 IEEE-754 标准的，通常来说操作会比较快（CPU 有写好的指令，不需要额外操作），但是有的时候会有 rounding 的问题，具体参考以下两段代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> x = <span class="number">0.1</span>;</span><br><span class="line">    <span class="keyword">float</span> y = <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not rounding</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x + y = %f\n"</span>, x + y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0.3 = %f\n"</span>, <span class="number">0.3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rounding, error occurs!</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x + y = %.20f\n"</span>, x + y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0.3 = %.20f\n"</span>, <span class="number">0.3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他的输出是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x + y = 0.300000</span><br><span class="line">0.3 = 0.300000</span><br><span class="line">x + y = 0.30000001192092895508</span><br><span class="line">0.3 = 0.29999999999999998890</span><br></pre></td></tr></table></figure>
<p>出现这样问题主要是因为硬件没办法存储固定位数的小数，为了解决 rounding 的问题，我们需要考虑用定点小数去存储数据，这个时候我们考虑用一种类似<code>VARCHAR</code> 的方式（不过不是存成字符串）去存储一组定长的二进制表示并且有元数据（存储位数等等）说明的方式去存储。</p>
<p>Postgres 内部的数字存储方式如下（也是一种定点数存储方法）,对于这种方式存储，数字的操作方式会需要很多额外的考虑（为什么比浮点数计算速度慢的原因）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> NumbericDigit;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ndigits; <span class="comment">// # of digits</span></span><br><span class="line">    <span class="keyword">int</span> weight; <span class="comment">// weight of 1st digit</span></span><br><span class="line">    <span class="keyword">int</span> scale; <span class="comment">// scale factor</span></span><br><span class="line">    <span class="keyword">int</span> sign; <span class="comment">// positive/negative/NaN</span></span><br><span class="line">    NumericDigit *digits; <span class="comment">// digit storage</span></span><br><span class="line">&#125; numeric;</span><br></pre></td></tr></table></figure>
<h3 id="大尺寸的值的存储"><a href="#大尺寸的值的存储" class="headerlink" title="大尺寸的值的存储"></a>大尺寸的值的存储</h3><p>通常来说， DBMS 不允许单个 tuple 的尺寸超过一定值，对于 tuple 里面某些比较大的参数，有不同的处理方式：</p>
<ul>
<li><p>将超过规定的值存在一个单独的页面（overflow page）里，在 tuple 内部用一个指针指向它，如下图所示，这样做的原因是当 tuple 崩溃的时候不希望会影响到这个参数，通常比较大的参数大部分时候不需要 update，常用的操作是 read，常用的 DBMS 的 overflow page 有：</p>
<ul>
<li>Postgres: TOAST (&gt;2KB)</li>
<li>MySQL: Overflow (&gt;½ size of page)</li>
<li><p>SQL Server: Overflow (&gt;size of page)</p>
<img src="/2020/04/26/CMU-DB-5-database-storage-2/large-value.png" class="" title="CMU-DB-5-database-storage-2">
</li>
</ul>
</li>
<li><p>还有一种做法是将内容存在外部文件( <code>BLOB</code> 类型)里面，然后用指针指向该文件的位置，如下图所示。但是 DMBS 不能更改外部文件，只能读取，而且没办法对文件保护（如果其他进程对文件进行修改的话），用这种方法的 DBMS 有：</p>
<ul>
<li>Oracle: BFILE data type</li>
<li><p>Microsoft: FILESTREAM data type</p>
<img src="/2020/04/26/CMU-DB-5-database-storage-2/large-valye-2.png" class="" title="CMU-DB-5-database-storage-2">
</li>
</ul>
</li>
</ul>
<h2 id="System-Catalogs"><a href="#System-Catalogs" class="headerlink" title="System Catalogs"></a>System Catalogs</h2><p>一个 DBMS 会将与数据有关的一些元数据存储到它内部的目录里：包括表格，列，索引，用户和权限还有内部统计数据等等。同时这个目录会和数据库的内容一起存在 DBMS 里。</p>
<p>用户可以通过查询 DBMS 的 <code>INFORMATION_SCHEMA</code> 目录来获得关于该数据库的内部信息：这是 ANSI 的标准规定一个只读的方式来提供关于数据库的信息。同时，不同的 DBMS 也有自己的方式（快捷键）来获得信息，如下图所示。</p>
<img src="/2020/04/26/CMU-DB-5-database-storage-2/list_table.png" class="" title="CMU-DB-5-database-storage-2">
<p>关系模型没有规定我们必须将 tuple 的所有参数都存放在一个单独page上，因为在某些情况下这样未必是最好的布置方式，下面以 Wikipedia 举个例子：</p>
<p>下图是三个 table:</p>
<img src="/2020/04/26/CMU-DB-5-database-storage-2/wiki_example.png" class="" title="CMU-DB-5-database-storage-2">
<p>我们主要考虑两种工作模式（workload）：</p>
<ul>
<li><em>On-line Transaction Processing (OLTP)</em>: 每次查询从外部读取一小部分数据然后存入（更新）本地数据库中，通常是用户第一次搭建（安装）应用要做的步骤，对应的维基百科例子操作如下所示：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 更新页面</span><br><span class="line"><span class="keyword">SELECT</span> P.*, R.*</span><br><span class="line">    <span class="keyword">FROM</span> pages <span class="keyword">AS</span> P</span><br><span class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> revisions <span class="keyword">AS</span> R</span><br><span class="line">    <span class="keyword">ON</span> P.latest = R.revID</span><br><span class="line">  <span class="keyword">WHERE</span> P.pageID = ?</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 登陆账户</span><br><span class="line"><span class="keyword">UPDATE</span> useracct</span><br><span class="line">    <span class="keyword">SET</span> lastLogin = <span class="keyword">NOW</span>(),</span><br><span class="line">        hostname = ?</span><br><span class="line">    <span class="keyword">WHERE</span> userID = ?</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 插入数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> revisions</span><br><span class="line">    <span class="keyword">VALUES</span> (?,?…,?)</span><br></pre></td></tr></table></figure>
<ul>
<li>另一种工作模式是 <em>On-line Analytical Processing (OLAP)</em>: 一次读取大量数据计算计算处理，但是不对数据进行更新，对应的维基百科例子如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 计算一些统计数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(U.lastLogin),</span><br><span class="line">    <span class="keyword">EXTRACT</span>(<span class="keyword">month</span> <span class="keyword">FROM</span></span><br><span class="line">        U.lastLogin) <span class="keyword">AS</span> <span class="keyword">month</span></span><br><span class="line">  <span class="keyword">FROM</span> useracct <span class="keyword">AS</span> U</span><br><span class="line"> <span class="keyword">WHERE</span> U.hostname <span class="keyword">LIKE</span> <span class="string">'%.gov'</span></span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">  <span class="keyword">EXTRACT</span>(<span class="keyword">month</span> <span class="keyword">FROM</span> U.lastLogin)</span><br></pre></td></tr></table></figure>
<p>两种工作方式和读写关系如下图，这里不讨论HTAP：</p>
<img src="/2020/04/26/CMU-DB-5-database-storage-2/workload_rw.png" class="" title="CMU-DB-5-database-storage-2">
<h2 id="Storage-Models"><a href="#Storage-Models" class="headerlink" title="Storage Models"></a>Storage Models</h2><p>在了解两种工作方式，我们可以开始考虑存储模型。DBMS 针对 OLTP 或者 OLAP 工作方式可以有不同的方式去存储 tuples。目前我们假定统一用 n-ary 存储方式（行存储）。</p>
<h3 id="N-ary-Storage-Model-NSM"><a href="#N-ary-Storage-Model-NSM" class="headerlink" title="N-ary Storage Model (NSM)"></a>N-ary Storage Model (NSM)</h3><p>用这种模型 DBMS 连续存储 tuple 的所有参数在一页里，tuple 之间也是连续存放。这种方式对 OLTP 比较有利，因为大部分时间只需要读取/更新/插入单条信息（tuple），如下图所示。</p>
<img src="/2020/04/26/CMU-DB-5-database-storage-2/nsm.png" class="" title="CMU-DB-5-database-storage-2">
<p>下面是一个简单的查询过程演示，这种情况下每次只插入一个 tuple，这种存储方式比较快捷：</p>
<img src="/2020/04/26/CMU-DB-5-database-storage-2/nsm_example.png" class="" title="CMU-DB-5-database-storage-2">
<p>对于下面的例子，NSM 的存储方式比较不好，因为查询过程不得不访问（读取）所有的 tuple，哪怕我们只需要其中两个参数，效率比较低</p>
<img src="/2020/04/26/CMU-DB-5-database-storage-2/nsm_bad_example.png" class="" title="CMU-DB-5-database-storage-2">
<p>总结一下， NSM 的优缺点分别是：</p>
<p>优点：</p>
<ul>
<li>快速插入，更新和删除</li>
<li>对于需要整个 tuple 的查询指令比较友好</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于扫描某组参数的查询指令不友好（效率低）</li>
</ul>
<h3 id="DECOMPOSITION-STORAGE-MODEL-DSM"><a href="#DECOMPOSITION-STORAGE-MODEL-DSM" class="headerlink" title="DECOMPOSITION STORAGE MODEL (DSM)"></a>DECOMPOSITION STORAGE MODEL (DSM)</h3><p>针对上面的问题，还有第二种存储模型，这种存储模型按参数将所有值连续存放（也被称为列模型），对于 OLAP 工作模型（需要扫描（只读取）所有 tuple 的某个参数）比较友好，对应的例子如下所示：</p>
<img src="/2020/04/26/CMU-DB-5-database-storage-2/dsm_example.png" class="" title="CMU-DB-5-database-storage-2">
<p>在这种情况下，我们怎么识别哪个参数对应哪个 tuple 呢？有两种方法选择：</p>
<ul>
<li>固定长度的偏移（fixed-length offsets）:每个值保存成相同的长度；</li>
<li>嵌入 id（embedded tuple ids）每个值额外存储一个 tuple id 值用于识别，比较浪费空间。</li>
</ul>
<p>总结一下， DSM 的优缺点分别是：</p>
<p>优点：</p>
<ul>
<li>减少需要的I/O数（只读取需要的数据）</li>
<li>因为同一个page 保存的是相同的类型，所以可以有数据压缩的方法</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于查询（插入，更新，删除）单个 tuple 效率较低。</li>
</ul>
<p>目前绝大部分系统都有 DSM 存储方式。</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>lidarSLAM-第三次作业</title>
    <url>/2020/04/25/lidarSLAM-hw2/</url>
    <content><![CDATA[<p>本文是我在学习深蓝学院的<a href="https://www.shenlanxueyuan.com/course/152" target="_blank" rel="noopener">激光slam课程</a>第三次作业的笔记。本次作业第一题是通过代码实践课上学习到的用里程计辅助去除激光扫描数据畸变的方法；第二题是补充一下课上提到的 ICP 算法的原理推导；第三题是复习激光雷达的测距原理；第四题是设计用 IMU 去除运动畸变的思路。</p>
<a id="more"></a>
<h2 id="结合里程计数据去除激光雷达运动畸变"><a href="#结合里程计数据去除激光雷达运动畸变" class="headerlink" title="结合里程计数据去除激光雷达运动畸变"></a>结合里程计数据去除激光雷达运动畸变</h2><p>作业里已经包括了代码大致框架，只需要补充其中一个函数即可。首先还是来学习一下代码结构，具体推导过程见前文 <a href="https://guoxiaotao.xyz/2020/04/21/lidarSLAM-3/">_激光雷达运动畸变去除_</a>。</p>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>思路和上一次作业差不多，<code>main()</code> 初始化节点和一个用于矫正激光雷达运动畸变的实例 <code>tmpLidarMotionCalib</code>，由该实例完成全部工作。</p>
<p><code>LidarMotionCalibrator</code> 通过一个 Subscriber 订阅一个自定义的激光扫描类型 <code>ChampionNavLaserScan</code> 话题 <code>champion_scan</code> 来启动 callback 函数，完成后续流程，看了一下 <code>ChampionNavLaserScan</code> 内部，本次作业应该要用到的是扫描时间 <code>scan_time</code>， 距离 <code>ranges</code> 和角度<code>angles</code> 。</p>
<p>每次收到一帧激光数据时节点会进入 <code>ScanCallBack()</code> 函数，首先通过开始时间和激光束数量获得当前激光帧起止时间，然后将距离和角度数据复制一份用于校正，并将校正前的扫描数据计算成 xyz 坐标（因为是单线激光雷达，这里 z 设为 0）通过 pcl 可视化， 接着进入 <code>Lidar_Calibration()</code> 进行校正。</p>
<p><code>Lidar_Calibration()</code> 函数主要是将当前激光帧按照一定时间间隔进行分段（这里是取 5ms），每一段分别通过 <code>getLaserPose()</code> 方法取得当前段的起止激光束对应的位姿，通过 <code>Lidar_MotionCalibration()</code> 进行分段线性插值校正。</p>
<p><code>getLaserPose()</code> 通过 <code>tf_-&gt;waitForTransform(&quot;/odom&quot;, &quot;/base_laser&quot;, dt, ros::Duration(0.5))</code> 找到激光数据到里程计的位姿转换， 并通过 <code>tf_-&gt;transformPose(&quot;/odom&quot;, robot_pose, odom_pose)</code>求出转换后的位姿返回。</p>
<p><code>Lidar_MotionCalibration()</code> 为要补充的函数，在下一部分记录。</p>
<h3 id="补充线性插值函数"><a href="#补充线性插值函数" class="headerlink" title="补充线性插值函数"></a>补充线性插值函数</h3><p>通过上一部分的分析，<code>Lidar_MotionCalibration()</code>的思路很明确只需要将给定的一段激光束数据通过起止时间以及对应的位姿进行插值求出该段内每个激光束的位姿，并将其转换到 <code>frame_base_pose</code> 坐标系上，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Lidar_MotionCalibration</span></span><br><span class="line"><span class="comment"> *        激光雷达运动畸变去除分段函数;</span></span><br><span class="line"><span class="comment"> *        在此分段函数中，认为机器人是匀速运动；</span></span><br><span class="line"><span class="comment"> * @param frame_base_pose       标定完毕之后的基准坐标系</span></span><br><span class="line"><span class="comment"> * @param frame_start_pose      本分段第一个激光点对应的位姿</span></span><br><span class="line"><span class="comment"> * @param frame_end_pose        本分段最后一个激光点对应的位姿</span></span><br><span class="line"><span class="comment"> * @param ranges                激光数据－－距离</span></span><br><span class="line"><span class="comment"> * @param angles                激光数据－－角度</span></span><br><span class="line"><span class="comment"> * @param startIndex            本分段第一个激光点在激光帧中的下标</span></span><br><span class="line"><span class="comment"> * @param beam_number           本分段的激光点数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lidar_MotionCalibration</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        tf::Stamped&lt;tf::Pose&gt; frame_base_pose,</span></span></span><br><span class="line"><span class="function"><span class="params">        tf::Stamped&lt;tf::Pose&gt; frame_start_pose,</span></span></span><br><span class="line"><span class="function"><span class="params">        tf::Stamped&lt;tf::Pose&gt; frame_end_pose,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; ranges,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; angles,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>&amp; beam_number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// get the transfomation from start/end to base</span></span><br><span class="line">   tf::Pose baseToworld = frame_base_pose.inverse();</span><br><span class="line">   tf::Pose startTobase = baseToworld * frame_start_pose;</span><br><span class="line">   tf::Pose endTobase = baseToworld * frame_end_pose;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// get translation and rotation for start/end pose</span></span><br><span class="line">   tf::Vector3 startTranslation = startTobase.getOrigin();</span><br><span class="line">   tf::Vector3 endTranslation = endTobase.getOrigin();</span><br><span class="line"></span><br><span class="line">   tf::Quaternion startRotation = startTobase.getRotation();</span><br><span class="line">   tf::Quaternion endRotation = endTobase.getRotation();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> index = startIndex;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; beam_number; i++) &#123;</span><br><span class="line">        <span class="comment">// linear interpolate translation and rotation</span></span><br><span class="line">        tf::Vector3 currTrans = startTranslation.lerp(endTranslation, i / (<span class="number">1.0</span> * beam_number - <span class="number">1</span>));</span><br><span class="line">        tf::Quaternion currRot = startRotation.slerp(endRotation, i / (<span class="number">1.0</span> * beam_number - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the scan point coordinate before calibration, set Z to 0.00</span></span><br><span class="line">        <span class="keyword">float</span> currX = ranges[index] * <span class="built_in">cos</span>(angles[index]);</span><br><span class="line">        <span class="keyword">float</span> currY = ranges[index] * <span class="built_in">sin</span>(angles[index]);</span><br><span class="line">        <span class="function">tf::Vector3 <span class="title">currXYZ</span><span class="params">(currX, currY, <span class="number">0.00</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// transform coordinates to base coordinates</span></span><br><span class="line">        tf::Transform currTobase;</span><br><span class="line">        currTobase.setOrigin(currTrans);</span><br><span class="line">        currTobase.setRotation(currRot);</span><br><span class="line">        tf::Vector3 baseCoordinates = currTobase * currXYZ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update scan data point</span></span><br><span class="line">        ranges[index] = <span class="built_in">sqrt</span>(baseCoordinates[<span class="number">0</span>] * baseCoordinates[<span class="number">0</span>] + baseCoordinates[<span class="number">1</span>] * baseCoordinates[<span class="number">1</span>]);</span><br><span class="line">        angles[index] = <span class="built_in">atan2</span>(baseCoordinates[<span class="number">1</span>], baseCoordinates[<span class="number">0</span>]);</span><br><span class="line">        index++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下，可以看出校正效果比较好，校正后的激光显示出来的走廊轮廓比较稳定。<br><img src="/2020/04/25/lidarSLAM-hw2/laser_scan_calib.gif" class="" title="lidarSLAM-hw2"></p>
<h2 id="推导已知对应点的-ICP-求解方法"><a href="#推导已知对应点的-ICP-求解方法" class="headerlink" title="推导已知对应点的 ICP 求解方法"></a>推导已知对应点的 ICP 求解方法</h2><blockquote>
<p>题目要求：阅读论文 Least-Squares Fitting of Two 3-D Points Sets,推导并证明已知对应点的 ICP 求解方法。</p>
</blockquote>
<p>这里主要是归纳一下文章的思路和推导过程。</p>
<p>首先，<strong>要解决的问题</strong>是：给定两组点 $\{p_i\}$ 和 $\{p’_i\}$，假设他们符合以下关系，其中 $R$ 是 3x3 的旋转矩阵， T 是 3x1 的平移向量， $N_i$ 是噪声：</p>
<script type="math/tex; mode=display">p_i' = Rp_i + T + N_i</script><p>我们需要找到一个找到一个 R 和 T 使得下式结果最小化：</p>
<script type="math/tex; mode=display">\Sigma^2 = \sum_{i=1}^N||p_i' - (Rp_i + T)||^2</script><p>作者的思路是首先想办法<strong>将问题解耦成分别求 R 和 T</strong>，使问题简单化，解耦过程如下：</p>
<p>根据已有结论（在另一篇文章里），假设 $\hat{R}$ 和 $\hat{T}$ 使得要求的的最优解，那么 $\{p_i’\}$ 和 $\{p_i’’\triangleq \hat{R}p_i + T_i \}$ 两组点会有一样的重心（这里表现是几何中心），即满足下列等式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
p'&\triangleq \frac{1}{N}\sum_{i = 1}^{N}p_i'\\
p &\triangleq \frac{1}{N}\sum_{i = 1}^{N}p_i\\
p'' &\triangleq \frac{1}{N}\sum_{i = 1}^N p_i'' = \hat{R}p+\hat{T}\\
\rightarrow p' &= p''
\end{aligned}</script><p>接下来我们令：</p>
<script type="math/tex; mode=display">
\begin{aligned}
q_i &\triangleq p_i - p\\
q_i' &\triangleq p_i' - p'
\end{aligned}</script><p>则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
p_i' - (Rp_i + T) &= q_i' - (\hat{R}q_i + \hat{T} + \hat{R}p) + p' \\
                    &= q_i' - \hat{R}q_i + (p' - (\hat{R}p + \hat{T}))\\
                    &= q_i' - \hat{R}q_i - (p' - p'')\\
                    &= q_i' - \hat{R}q_i
\end{aligned}</script><p>所以要求解的问题就变成令下式最小</p>
<script type="math/tex; mode=display">
\Sigma^2 = \sum_{i=1}^N||q_i' - Rq_i||^2</script><p>这样问题就变成两个子问题：</p>
<ul>
<li>求解一个旋转矩阵 $\hat{R}$ 令上式最小；</li>
<li>通过 $\hat{T} = p’ - \hat{R}p$ 求解平移向量。</li>
</ul>
<p>作者在第三部分分别给出了求解算法和推导过程，这边只讲推导过程具体算法可以参考我的<a href="https://guoxiaotao.xyz/2020/04/21/lidarSLAM-3/">上一篇博文</a>：</p>
<p>首先将上式展开：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Sigma^2 &= \sum_{i = 1}^N(q'_i - Rq_i)^T(q_i' - Rq_i)\\
            &= \sum_{i = 1}^N(q_i'^Tq_i' + q_i^TR^TRq_i - q_i'^TRq_i - q_i^TR^Tq_i')\\
            &\overset{R^TR = I}{=} \sum_{i = 1}^N(q_i'^Tq_i' + q_i^Tq_i - 2q_i'^TRq_i)
\end{aligned}</script><p>因为前两项与R无关，所以令上式最小等效于令下式最大，$H = \sum_{i = 1}^N(q_i’^Tq_i)$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F &= \sum_{i = 1}^Nq_i'^TRq_i\\
    &= Trace(\sum_{i = 1}^NRq_i'q_i^T)\\
    &= Trace(RH)
\end{aligned}</script><p>这里引入一条引理(这里不证了)：对于任何正定矩阵 $AA^T$ 和 任何正交矩阵 $B$，满足以下不等式：</p>
<script type="math/tex; mode=display">
Trace(AA^T) \geq Trace(BAA^T)</script><p>令 $H$ 的 SVD 分解如下：</p>
<script type="math/tex; mode=display">H = U\Lambda V^T</script><p>令 $X = VU^T$, 容易知道 $X$ 也是正交的</p>
<p>则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
XH &= VU^TU\Lambda V\\
    &= V\Lambda V^T
\end{aligned}</script><p>这个矩阵显然是正定的，从上述引理可得，对于任何一个正交矩阵 $B$， 都有：</p>
<script type="math/tex; mode=display">
Trace(XH) \geq Trace(BXH)</script><p>所以可以知道对于我们要求的式子， $X$ 使 $F$ 最大化， 假如 $det(X) = 1$就是我们想取得的 $\hat{R}$， 否则它就是仿射变换矩阵，但是这种情况通常不会发生，作者在后半部分论证了这部分，这里就不赘述了。</p>
<h2 id="简述激光测距原理"><a href="#简述激光测距原理" class="headerlink" title="简述激光测距原理"></a>简述激光测距原理</h2><blockquote>
<ol>
<li>阅读论文 Precise indoor localization for mobile laser scanner 前两章，简述激光雷达测距原理；</li>
<li>简要介绍一下下图的含义。</li>
</ol>
</blockquote>
<img src="/2020/04/25/lidarSLAM-hw2/%E6%BF%80%E5%85%89%E6%B5%8B%E8%B7%9D%E5%8E%9F%E7%90%86%E5%9B%BE.png" class="" title="lidarSLAM-hw2">
<p>这一部分的答案大部分都在我的<a href="https://guoxiaotao.xyz/2020/04/21/lidarSLAM-3/">上一篇笔记</a>记录过，这里不再重复。</p>
<h2 id="使用-IMU-去除激光雷达运动畸变的方法"><a href="#使用-IMU-去除激光雷达运动畸变的方法" class="headerlink" title="使用 IMU 去除激光雷达运动畸变的方法"></a>使用 IMU 去除激光雷达运动畸变的方法</h2><blockquote>
<ol>
<li>仅用 IMU 去除运动畸变可能会有哪些不足之处?</li>
<li>在仅有 IMU 和激光雷达传感器的情况下,你会如何设计运动畸变去除方案(平移+旋转),达到较好的畸变去除效果?</li>
</ol>
</blockquote>
<p>使用 IMU 去除运动畸变的思路同样可以参考运用里程计的方法，通过 IMU 来计算出一个位姿然后，然后同样将一帧数据分段每段取起止时间的对应位姿，然后对应激光束的位姿插值并转换到统一的坐标系下（该帧起始位姿坐标系），但是不足之处也很明显：IMU 的线加速度精度太低，过一段时间很容易偏移。<br>改进方法可以是只用 IMU 进行旋转部分校正，平移部分根据匀速假设进行校正，将校正后的结果于原结果相比得到一个误差然后均分到每一个时刻的 IMU 结果上作为 IMU 的误差，重新修正，直至误差小至合理范围内（收敛为止）。</p>
]]></content>
      <categories>
        <category>激光slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>lidar-slam</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS melodic 下使用 CSM 库</title>
    <url>/2020/04/25/ros-melodic-csm/</url>
    <content><![CDATA[<p>在学习slam的时候偶尔需要用到 CSM 这个库，但是目前这个库最高支持到kinetic可以直接通过 apt install 下载，后来找到几种做法可以通过源码安装 CSM 使用，在这里记录一下，另外注意一下安装csm需要安装一个gsl的库。</p>
<a id="more"></a>
<p>首先从Github上把<a href="https://github.com/AndreaCensi/csm" target="_blank" rel="noopener">源码</a> clone 或者下载下来解压，然后有两种思路可以安装。</p>
<ul>
<li><p>第一种方式：只在目录内安装，然后作为第三方库保存在自己的workspace里，比较推荐这种方法，因为安装到usr目录的话可能后续如果要清理会比较麻烦。具体做法是在 csm 目录里使用作者写好的脚本安装：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./install_quickstart.sh</span><br></pre></td></tr></table></figure>
<p>  安装完成后使用 csm 所需的文件都在 <code>csm/deploy</code>文件夹里，在需要用到<code>csm</code>的项目和目标链接的<code>CMakeList.txt</code>中加入这两项添加csm的目录和链接csm的动态库(csm的目录位置换成你自己的)：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">...</span><br><span class="line">PATH_TO_CSM/deploy/<span class="keyword">include</span>/csm</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(target_name</span><br><span class="line">...</span><br><span class="line">PATH_TO_CSM/deploy/lib/libcsm.so</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>  然后就能顺利编译通过了。</p>
</li>
<li><p>第二种方式：直接安装到本机上，和上面的过程差不多，在 csm 的目录下执行常规的cmake安装操作：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install <span class="comment"># 这一步会安装csm到本机上</span></span><br></pre></td></tr></table></figure>
<p>  安装完成后应该能找到这几个位置： <code>/usr/local/include/csm</code>，<code>/usr/local/lib/libcsm.so</code>，<code>/usr/local/lib/libcsm-static.a</code>。也是一样在<code>CMakeList.txt</code>做相应修改就可以了：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">...</span><br><span class="line">/usr/local/<span class="keyword">include</span>/csm</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(target_name</span><br><span class="line">...</span><br><span class="line">/usr/local/lib/libcsm.so</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>lidarSLAM-第二次作业</title>
    <url>/2020/04/23/lidarSLAM-hw1/</url>
    <content><![CDATA[<p>本文是我在学习深蓝学院的<a href="https://www.shenlanxueyuan.com/course/152" target="_blank" rel="noopener">激光slam课程</a>第二次作业的笔记。本次作业前半部分是通过代码实践熟悉里程计不同标定方法和看下实现的效果；第三题是关于线性方程组不同解法的总结；第四题是扩展题，考虑一下怎么设计里程计和激光雷达外参标定方法。</p>
<a id="more"></a>
<h2 id="直接线性方法的里程计标定的模块"><a href="#直接线性方法的里程计标定的模块" class="headerlink" title="直接线性方法的里程计标定的模块"></a>直接线性方法的里程计标定的模块</h2><p>这一题老师提供了一个 ROS 的工作空间以及一个 <code>odom_calib</code> 的 package，大致代码框架已经写好，只需要补充一下几个关键函数。</p>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>首先大致了解一下下代码框架，<code>src</code>文件夹里面有一个<code>main.cpp</code>用来初始化节点以及做各个topic之间的数据传递用，<code>odom_calib.cpp</code>和<code>odom_calib.hpp</code>是用来校正里程计数据的类。首先通过<code>main.cpp</code>来了解大致涉及到的 node 、 topic以及大致的工作流程。</p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>可以看到文件一开始一个初始化了一个<code>odom_calib</code>对象用来后面校正用，<code>main</code>函数里定义了一个<code>scan2</code>，大部分的工作由这个对象完成。<code>scan2</code>的构造函数里面声明了一些关于 PI-ICP 的变量和函数，这些这次作业先不用处理，后续地学习会涉及到，这次主要两个 subscriber 和 3 个 publisher。</p>
<ul>
<li><p><code>scan_filter_sub_</code> ： 订阅激光 scan的主题并和里程计数据通过<code>message_filters</code>做了同步，所以后面不需要考虑时间问题，每当接收到一个激光扫描信息时，计算前后<em>两帧激光数据的位姿差</em>（这一部分本次作业不涉及）。同时获取最近时间的两个里程计数据点，<em>通过里程计数据也计算一个位姿差</em>（通过<code>cal_delta_distence()</code>计算）。这样就可以产生两条路径分别通过两个publisher发布到相应的topic，同时每次更新数据的时候会把相应的激光和里程计数据存进<code>odom_calib</code>对象里。</p>
</li>
<li><p><code>calib_flag_sub_</code> : 通过订阅一个校正的 topic 通过<code>odom_calib</code>启动校正，校正完成后将校正之后的数据发布到相应的publisher上。</p>
</li>
<li><p><code>odom_path_pub_</code>,<code>scan_path_pub_</code>,<code>calib_path_pub_</code>：分别发布里程计，激光数据，校正之后的位姿数据。</p>
</li>
</ul>
<h4 id="OdomCalib类"><a href="#OdomCalib类" class="headerlink" title="OdomCalib类"></a>OdomCalib类</h4><p>OdomCalib 类内部比较简单：</p>
<ul>
<li><code>set_data_len()</code>设置数据的最大长度</li>
<li><code>set_data_zero()</code>将存放数据的数组清零</li>
<li><code>is_full()</code>判断数据有没有存满</li>
<li><code>add_data()</code>添加新的数据到<code>A</code>和<code>b</code></li>
<li><code>solve()</code>对存好的数据进行校正，最后返回一个 3x3 的校正矩阵。</li>
</ul>
<p>这次作业主要是补充一下<code>main.cpp</code>里面的<code>cal_delta_distance()</code>函数以及<code>OdomCalib</code>类里面的<code>add_data()</code>函数以及<code>solve()</code>函数。</p>
<h3 id="代码补充"><a href="#代码补充" class="headerlink" title="代码补充"></a>代码补充</h3><ul>
<li><code>Eigen::Vector3d cal_delta_distance(Eigen::Vector3d odom_pose)</code></li>
</ul>
<p>这里输入参数是当前的位姿，要计算的是两帧之间的位姿差，所以要求的是当前位姿在上一时间点的位姿，主要涉及坐标转换，具体代码部分如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求解得到两帧数据之间的位姿差</span></span><br><span class="line"><span class="comment">//即求解当前位姿 在 上一时刻 坐标系中的坐标</span></span><br><span class="line"><span class="function">Eigen::Vector3d  <span class="title">cal_delta_distence</span><span class="params">(Eigen::Vector3d odom_pose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    Eigen::Vector3d d_pos;  <span class="comment">//return value</span></span><br><span class="line">    now_pos = odom_pose;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一时刻的位姿矩阵(在世界坐标系下)</span></span><br><span class="line">    Eigen::Matrix3d T_world_last;</span><br><span class="line">    T_world_last &lt;&lt; <span class="built_in">cos</span>(last_pos(<span class="number">2</span>)), -<span class="built_in">sin</span>(last_pos(<span class="number">2</span>)), last_pos(<span class="number">0</span>),</span><br><span class="line">                    <span class="built_in">sin</span>(last_pos(<span class="number">2</span>)),  <span class="built_in">cos</span>(last_pos(<span class="number">2</span>)), last_pos(<span class="number">1</span>),</span><br><span class="line">                    <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一时刻的位姿矩阵(在世界坐标系下)</span></span><br><span class="line">    Eigen::Matrix3d T_world_now;</span><br><span class="line">    T_world_now &lt;&lt; <span class="built_in">cos</span>(now_pos(<span class="number">2</span>)), -<span class="built_in">sin</span>(now_pos(<span class="number">2</span>)), now_pos(<span class="number">0</span>),</span><br><span class="line">                    <span class="built_in">sin</span>(now_pos(<span class="number">2</span>)),  <span class="built_in">cos</span>(now_pos(<span class="number">2</span>)), now_pos(<span class="number">1</span>),</span><br><span class="line">                    <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T_AB = (T_OA)^(-1)*T_(OB)</span></span><br><span class="line">    Eigen::Matrix3d T_last_world = T_world_last.inverse();</span><br><span class="line">    Eigen::Matrix3d T_last_now = T_last_world * T_world_now;</span><br><span class="line"></span><br><span class="line">    d_pos &lt;&lt; T_last_now(<span class="number">0</span>, <span class="number">2</span>), T_last_now(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            <span class="built_in">atan2</span>(T_last_now(<span class="number">1</span>, <span class="number">0</span>), T_last_now(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d_pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过计算位姿差之后可以分别输出用前后两帧 odom 和 scan 产生的路径，如下图所示，可以发现两者有比较的偏移：</p>
<img src="/2020/04/23/lidarSLAM-hw1/odom_scan.png" class="" title="lidarSLAM-hw1">
<ul>
<li><code>bool Add_Data(Eigen::Vector3d Odom,Eigen::Vector3d scan)</code></li>
</ul>
<p>添加校正数据比较简单，基本按照课上的讲解将 odom 数据放入A矩阵，scan 数据放入b矩阵即可，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输入:里程计和激光数据</span></span><br><span class="line"><span class="comment"> * 构建最小二乘需要的超定方程组</span></span><br><span class="line"><span class="comment"> * Ax = b</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OdomCalib::Add_Data</span><span class="params">(Eigen::Vector3d Odom,Eigen::Vector3d scan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(now_len&lt;INT_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 构建超定方程组</span></span><br><span class="line">        A(now_len * <span class="number">3</span>, <span class="number">0</span>) = Odom(<span class="number">0</span>);</span><br><span class="line">        A(now_len * <span class="number">3</span>, <span class="number">1</span>) = Odom(<span class="number">1</span>);</span><br><span class="line">        A(now_len * <span class="number">3</span>, <span class="number">2</span>) = Odom(<span class="number">2</span>);</span><br><span class="line">        A(now_len * <span class="number">3</span> + <span class="number">1</span>, <span class="number">3</span>) = Odom(<span class="number">0</span>);</span><br><span class="line">        A(now_len * <span class="number">3</span> + <span class="number">1</span>, <span class="number">4</span>) = Odom(<span class="number">1</span>);</span><br><span class="line">        A(now_len * <span class="number">3</span> + <span class="number">1</span>, <span class="number">5</span>) = Odom(<span class="number">2</span>);</span><br><span class="line">        A(now_len * <span class="number">3</span> + <span class="number">2</span>, <span class="number">6</span>) = Odom(<span class="number">0</span>);</span><br><span class="line">        A(now_len * <span class="number">3</span> + <span class="number">2</span>, <span class="number">7</span>) = Odom(<span class="number">1</span>);</span><br><span class="line">        A(now_len * <span class="number">3</span> + <span class="number">2</span>, <span class="number">8</span>) = Odom(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        b(now_len * <span class="number">3</span>, <span class="number">0</span>) = scan(<span class="number">0</span>);</span><br><span class="line">        b(now_len * <span class="number">3</span> + <span class="number">1</span>, <span class="number">0</span>) = scan(<span class="number">1</span>);</span><br><span class="line">        b(now_len * <span class="number">3</span> + <span class="number">2</span>, <span class="number">0</span>) = scan(<span class="number">2</span>); </span><br><span class="line">        <span class="comment">//end of TODO</span></span><br><span class="line">        now_len++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Eigen::Matrix3d Solve()</code></li>
</ul>
<p>这一部分主要就是通过求解 Ax=b 求出对 odom 数据的校正矩阵，因为是直接线性方法所以不需要考虑模型，ROS 中有很多求解工具，这里用的是 QR 分解的一种，具体各种求解方法放在第三题统一讨论，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 求解线性最小二乘Ax=b</span></span><br><span class="line"><span class="comment"> * 返回得到的矫正矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Eigen::Matrix3d <span class="title">OdomCalib::Solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Matrix3d correct_matrix;</span><br><span class="line"></span><br><span class="line">    <span class="function">Eigen::VectorXd <span class="title">correct_vector</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    correct_vector = A.colPivHouseholderQr().solve(b);</span><br><span class="line">    correct_matrix &lt;&lt; correct_vector(<span class="number">0</span>),correct_vector(<span class="number">1</span>),correct_vector(<span class="number">2</span>),</span><br><span class="line">                        correct_vector(<span class="number">3</span>),correct_vector(<span class="number">4</span>),correct_vector(<span class="number">5</span>),</span><br><span class="line">                        correct_vector(<span class="number">6</span>),correct_vector(<span class="number">7</span>),correct_vector(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> correct_matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校正之后的数据如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输出</span></span><br><span class="line">correct_matrix:</span><br><span class="line">  0.936194    1.81675 -0.0432266</span><br><span class="line"> -0.012844    7.20126   0.142539</span><br><span class="line">0.00144064    23.4053   0.378674</span><br><span class="line">calibration over!!!!</span><br></pre></td></tr></table></figure>
<img src="/2020/04/23/lidarSLAM-hw1/odom_scan_calib.png" class="" title="lidarSLAM-hw1">
<p>可以发现，将 scan 的结果作为真实值的话，经过用直接线性方法校正之后的 odom 结果明显准确很多。</p>
<h2 id="基于模型方法的里程计设计模块"><a href="#基于模型方法的里程计设计模块" class="headerlink" title="基于模型方法的里程计设计模块"></a>基于模型方法的里程计设计模块</h2><p>这一部分老师也给出了大致的代码框架，只需要按照课程上的推导结果填入系数矩阵求解即可，推导过程见<a href="https://guoxiaotao.xyz/2020/04/18/%E8%BD%AE%E5%BC%8F%E9%87%8C%E7%A8%8B%E8%AE%A1%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%A0%87%E5%AE%9A/">这里</a>，代码结构也比较简单，大致是读取预先存好的 scan 数据和 odom 数据，然后通过积分每两帧 scan 数据之间的轮速计数据来求角速度，接下来就是利用这些数据求机器人的$J_{21}$, $J_{22}$, $b$, $r_L$, $r_R$ 参数，中间补充的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充A, b矩阵</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> (3~5 lines)</span></span><br><span class="line">A(id_s, <span class="number">0</span>) = w_Lt;</span><br><span class="line">A(id_s, <span class="number">1</span>) = w_Rt;</span><br><span class="line">b(id_s) = s_th;</span><br><span class="line"><span class="comment">//end of TODO</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进行最小二乘求解</span></span><br><span class="line">Eigen::Vector2d J21J22;</span><br><span class="line">J21J22 = (A.transpose() * A).inverse() * A.transpose() * b;</span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> (1~2 lines)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充C, S矩阵</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> (4~5 lines)</span></span><br><span class="line">C(id_s * <span class="number">2</span>) = cx;</span><br><span class="line">C(id_s * <span class="number">2</span> + <span class="number">1</span>) = cy;</span><br><span class="line">S(id_s * <span class="number">2</span>) = s_x;</span><br><span class="line">S(id_s * <span class="number">2</span> + <span class="number">1</span>) = s_y;</span><br><span class="line"><span class="comment">//end of TODO</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> (3~5 lines)</span></span><br><span class="line">b_wheel = (C.transpose() * C).inverse() * C.transpose() * S;</span><br><span class="line">r_L = -J21 * b_wheel;</span><br><span class="line">r_R = J22 * b_wheel;</span><br><span class="line"><span class="comment">//end of TODO</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./odom_calib/odom_calib</span><br><span class="line">J21: -0.163886</span><br><span class="line">J22: 0.170575</span><br><span class="line">b: 0.59796</span><br><span class="line">r_L: 0.0979974</span><br><span class="line">r_R: 0.101997</span><br><span class="line">参考答案：轮间距b为0.6m左右，两轮半径为0.1m左右</span><br></pre></td></tr></table></figure>
<h2 id="线性方程组-Ax-b-的不同解法"><a href="#线性方程组-Ax-b-的不同解法" class="headerlink" title="线性方程组 $Ax = b$ 的不同解法"></a>线性方程组 $Ax = b$ 的不同解法</h2><p>这一部分网上已经有很多关于推导以及优缺点的资料，这里主要是做一个总结整理。</p>
<h3 id="从高斯消元法到-LU-分解-和-Cholesky-分解"><a href="#从高斯消元法到-LU-分解-和-Cholesky-分解" class="headerlink" title="从高斯消元法到 LU 分解 和 Cholesky 分解"></a>从高斯消元法到 LU 分解 和 Cholesky 分解</h3><p>高斯消元法是我们比较熟悉的解线性方程组的方法，而 LU 分解则是把列主元的高斯消元法用矩阵变换的思路表示出来，具体推导过程看<a href="http://www.math.pku.edu.cn/teachers/lidf/docs/statcomp/html/_statcompbook/matrix-solve.html" target="_blank" rel="noopener">这里</a>，具体方法是利用以下变换：</p>
<script type="math/tex; mode=display">PA = LU</script><p>其中 P 是置换矩阵， L 是单位下三角矩阵， U 是上三角矩阵，通过这个方法求解 $Ax = b$ 可以转换为 $P(Ax) = P(b) \rightarrow LUx = Pb$， 令$y = Ux$，简单可以求出 $Ly = Pb$ 的解，再进而求出 $Ux = y$ 的解。</p>
<p>对于正定矩阵，还能通过 Cholesky 分解减少一点计算量，具体分解公式如下：</p>
<script type="math/tex; mode=display">A = LL^T</script><p>还能进一步分解为以下形式，其中 $\tilde{L}$ 为单位下三角阵， $\tilde{D}$ 为主对角线为正值的对角阵，这个分解也被称为矩阵 A 的 LDL 分解：</p>
<script type="math/tex; mode=display">A = \tilde{L}\tilde{D}\tilde{L}^T</script><p>其中 A 要求是 <em>正定矩阵</em>， L 是主对角元素都是正值的小三角矩阵，利用分解公式求解线性方程组和上述方法类似。</p>
<h3 id="从正交化到-QR-分解"><a href="#从正交化到-QR-分解" class="headerlink" title="从正交化到 QR 分解"></a>从正交化到 QR 分解</h3><p>正交化意味着将矩阵变换成一个正交矩阵和三角矩阵的乘积，具体形式如下：</p>
<script type="math/tex; mode=display">A = QR</script><p>其中， Q 为正交矩阵， R 为上三角阵，通过这种方法也可以求解线性方程组，具体方式同上，区别在于求解 $Qy = b$ 的过程中，由于 Q 是正交阵，所以可以通过转置求出他的逆进而求解方程组，QR 分解主要有基于 Gram-Schmidt 和 Householder 两种正交化方法，具体推导过程和原理同样可以参考<a href="http://www.math.pku.edu.cn/teachers/lidf/docs/statcomp/html/_statcompbook/matrix-qr.html" target="_blank" rel="noopener">这篇文章</a>。</p>
<h3 id="SVD-分解"><a href="#SVD-分解" class="headerlink" title="SVD 分解"></a>SVD 分解</h3><p>除了 QR 分解以外，还可以将矩阵 A 分解成两个正交矩阵和一个对角矩阵的乘积，具体形式如下：</p>
<p>设 $A \in R^{m\times n}$, $rank(A) = r$,  $(r &gt; 0)$，则 $A$ 可以分解成以下形式：</p>
<script type="math/tex; mode=display">A = U\Sigma V^T</script><p>其中， $U$ 和 $V$ 分别为 m 和 n 阶的正交矩阵，$\Sigma$ 为对角矩阵，其中前 r 个元素为A 的奇异值，后面对角线元素为0，这称为矩阵 A 的 SVD 分解。通过这种方法也能求解线性方程组的解，具体解的个数和 A 的秩有关，具体推导过程见<a href="https://blog.csdn.net/MyArrow/article/details/53780972" target="_blank" rel="noopener">这篇博客</a>。</p>
<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p>我们在实际过程中大部分只在乎求解的速度、稳定性和准确性，下面对 Eigen 里面的各种求法做一个归纳，具体参考自 <a href="https://eigen.tuxfamily.org/dox/group__TutorialLinearAlgebra.html" target="_blank" rel="noopener">Eigen 官方文档</a>。</p>
<img src="/2020/04/23/lidarSLAM-hw1/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.png" class="" title="lidarSLAM-hw1">
<h2 id="设计里程计和激光雷达外参标定方法（思路）"><a href="#设计里程计和激光雷达外参标定方法（思路）" class="headerlink" title="设计里程计和激光雷达外参标定方法（思路）"></a>设计里程计和激光雷达外参标定方法（思路）</h2><blockquote>
<p>我们一般把传感器内自身要调节的参数称为内参,比如前面作业中里程计模型的两轮间距与两个轮子的半径。把传感器之间的信息称为外参,比如里程计与激光雷达之间的时间延迟,位姿变换等。</p>
</blockquote>
<p>这里的主要思路找到一些想要标定的外参，整理出一个时间点的等式，这样通过列举多个时间点的等式就可以构建超定方程组从而进行标定，比如我们如果想要标定传感器之间的位姿关系，可以有以下思路。</p>
<p>首先假设里程计和激光雷达的内参都已经标定好，忽略时间同步的问题，在每一时刻，我们可以通过里程计和激光雷达分别计算出一个位姿。以激光雷达求出的位姿为标定观测值，里程计求出的位姿为预测值。同时假设激光雷达和里程计之间是刚性连接（位姿关系不变），那么每一个时间段可以有以下等式：</p>
<script type="math/tex; mode=display">T_t^sT_{t+1}^s = T_t^rT_{t+1}^r</script><p>通过这个等式以及后续的变换可以构建超定方程组求解，具体的关于标定方面的知识可以参阅这篇论文 <a href="https://www.researchgate.net/publication/260634803_Simultaneous_Calibration_of_Odometry_and_Sensor_Parameters_for_Mobile_Robots" target="_blank" rel="noopener">Simultaneous Calibration of Odometry and SensorParameters for Mobile Robots</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="http://www.math.pku.edu.cn/teachers/lidf/docs/statcomp/html/_statcompbook/matrix-solve.html" target="_blank" rel="noopener">线性方程组求解</a></p>
</li>
<li><p><a href="https://blog.csdn.net/MyArrow/article/details/53780972" target="_blank" rel="noopener">SVD 求解线性方程组</a></p>
</li>
<li><a href="https://eigen.tuxfamily.org/dox/group__TutorialLinearAlgebra.html" target="_blank" rel="noopener">Eigen 不同方法求解线性方程组性能比较</a></li>
</ul>
]]></content>
      <categories>
        <category>激光slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>lidar-slam</tag>
      </tags>
  </entry>
  <entry>
    <title>[CMU-15-445/645] Database Storage - Part 1</title>
    <url>/2020/04/22/CMU-DB-4-database-storage-1/</url>
    <content><![CDATA[<p>这是我在学习<a href="https://15445.courses.cs.cmu.edu/fall2019/" target="_blank" rel="noopener">Databases Systems CMU 15-445/645/ Fall 2019</a>过程记录的一些笔记。通过前两次课已经学习了<a href="https://guoxiaotao.xyz/2020/04/20/CMU-DB-1/">一个数据库应该是怎么样的</a>以及<a href="https://guoxiaotao.xyz/2020/04/20/CMU-DB-2-Advanced-SQL/">怎么通过sql去对数据库进行操作</a>，接下来就是学习怎么样去构建一个数据库管理系统，这次课主要是介绍数据库的存储过程，主要是介绍了数据库里页的概念，以及不同方式去追踪页、存储页以及存储tuple。</p>
<a id="more"></a>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>这门课研究的DBMS(数据库管理系统)都假定数据库的数据主要存储位置都是在非易失性存储空间( Non-volatile disk，硬盘等)，而数据库管理系统的操作则是管理数据库从非易失性存储空间（硬盘）转移到易失性存储空间(内存)，前三层是易失性的，在计算机断电之后数据不会保留，而后三层则是非易失性的，数据可以长期存储，在CPU进行运算时，需要把数据从后三层的空间转移到前三层。目前还有一种最新的存储技术叫非易失性内存(Non-Voltatile Memory, NVM)，这种存储结构即有内存的高速度处理，也能像硬盘一样在断电之后也能保持速度，不过目前还在研究过程，没有普及。</p>
<p>一个典型的数据库存储层次结构如下所示，从上往下数据读写速度逐级递减：</p>
<img src="/2020/04/22/CMU-DB-4-database-storage-1/hirarchy.png" class="" title="CMU-DB-4-database-storage-1">
<p>在这门课中我们主要关注后四层，把后三层统称为磁盘(Disk)，DRAM称为内存(Memory)，不同存储介质的读写速度可以参考下图，右侧是的数据主要是用来可视化长度对比。</p>
<img src="/2020/04/22/CMU-DB-4-database-storage-1/access_time.png" class="" title="CMU-DB-4-database-storage-1">
<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>针对DBMS，我们的设计目标主要是让整个系统可以管理一个数据库，它需要的空间会超过内存的可用空间（不超过的话直接全部读入内存就可以一直快速处理了）。并且用于对磁盘的读写代价太昂贵（速度太慢），所以我们需要尽可能避免大空间的读写而导致性能下降。</p>
<p>基于磁盘的数据库管理系统一个典型工作过程如下图：</p>
<img src="/2020/04/22/CMU-DB-4-database-storage-1/disk-oriented-dbms.png" class="" title="CMU-DB-4-database-storage-1">
<p>首先，处理器发出要求获得某个数据，此时内存里还没有该数据，需要从磁盘读取，读取之后再将该文件的指针给处理器，然后处理器进行运算，数据库则负责其中的数据转移和检查的部分，并不关心处理器会做什么运算。</p>
<p>从上面图以及目标来看，我们需要管理比实际内存空间要大的数据，那么为什么不直接用操作系统的虚拟内存机制然后让操作系统去管理读写操作而是去每次亲自读写内存和磁盘呢？</p>
<p>虚拟内存的原理大致如下图所示：操作系统维护一个虚拟的地址列表(memory-mapping, mmap)，每次需要获取一页时会先在内存找有没有存好，如果没有就从磁盘读进来，有就直接访问。但是当实际内存存满数据的时候，操作系统需要决定清空哪个页面，而这个时候如果直接让操作系统来选择的话，并不可以根据数据库的性质已经查找命令做出有效率的选择，所以直接让操作系统选择并不好。</p>
<img src="/2020/04/22/CMU-DB-4-database-storage-1/virtual-memory.png" class="" title="CMU-DB-4-database-storage-1">
<p>如果要解决这个问题的话我们有以下选择：</p>
<ul>
<li>madvise: 告诉操作系统你想要怎么样读取某页</li>
<li>mlock：告诉操作系统那些页面需要保留</li>
<li>msync：让操作系统把内存的数据存到磁盘去</li>
</ul>
<p>目前市面上只有有部分DBMS (mongoDB, SQLite,…) 是采取这种策略去使用mmap，大部分都是历史原因。因为数据库管理系统本身总是能做到比操作系统来管理性能更高，主要集中在：</p>
<ul>
<li>把用过的page 用一个合理的顺序flush到磁盘中</li>
<li>专门化的预处理某些数据</li>
<li>缓存替换策略</li>
<li>线程/线程调度</li>
</ul>
<p>因为操作系统总是通用性的看待这些操作，所以数据库直接管理能做的更好，所以一般不让操作系统管理，本门课搭建的数据库管理系统也不会用到mmap。</p>
<h2 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h2><p>数据库管理系统有很多模块，目前我们只关注存储模块，这一方面主要有两个问题：</p>
<ul>
<li>数据库管理系统用什么样的方式表示磁盘里的数据库文件？<ul>
<li>文件怎么存储？</li>
<li>数据库里面tuple怎么表示？</li>
<li>内存和磁盘里的页(page)怎么表示？</li>
</ul>
</li>
<li>数据库管理系统怎么样管理磁盘和内存间的移动操作？</li>
</ul>
<p>本文主要集中解决第一个问题。</p>
<h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><p>首先，DBMS 会将数据库文件写进一个或多个文件存在磁盘里。在操作系统的层面上并不关心文件的内容和格式，只要是符合一个通用的文件系统都能识别。但是对 DBMS 而言这是独有的，每个 DBMS 的数据库文件用别的 DBMS 都可能无法正确识别（早期的DBMS有一部分会用定制的文件系统来存储数据，但是现在几乎没有系统这样做了）。</p>
<h4 id="存储管理器"><a href="#存储管理器" class="headerlink" title="存储管理器"></a>存储管理器</h4><p>首先我们需要有一个存储管理器来负责维护数据库的数据：包括对数据的读写调度来提高效率。对于存储管理器而言，文件在其的管理形式主要是表现为一系列的页（page），进而对数据的读写转为对页的读写读写和可用空间的管理。</p>
<h4 id="数据库中的页"><a href="#数据库中的页" class="headerlink" title="数据库中的页"></a>数据库中的页</h4><p>这里要区分一些数据库中的页和和操作系统的页的概念。这里的<em>页</em>（page）的概念主要是指一个固定空间大小的数据，可以包括tuples，元数据，索引和登录数据，大部分系统不会混着存储各种数据在一个页里面，比如tuple和索引会分开存储。<br>同时大部分系统都要求页里面应该包含关于页的所有数据，包括存储了什么以及怎么样去解析等等。这里主要是为了数据的安全性，假设我们有一个表，我们把表头放在一个page里而把所有的tuple放在另一个page里面，这个时候如果磁盘损坏存着表头的page无法读取了会导致包含tuple的页也没法发挥作用。</p>
<p>每个page都会被管理器分配一个独有的id（identifier）来进行空间上的追踪管理，这样当存储位置变了的时候管理器不需要改变页的id，只需要改变映射的地址就可以了，操作更加简介。</p>
<p>在数据库里面不同的page的操作如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">层次</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">硬件层面上的页</td>
<td style="text-align:left">通常4KB</td>
<td style="text-align:left">能保证读写成功的最小单位，假如我们要写入16KB，其中每4KB的读写都可以认为是一次性完成，不存在写入到一半（比如2KB）失效的</td>
</tr>
<tr>
<td style="text-align:left">操作系统的页</td>
<td style="text-align:left">通常4KB</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">数据库的页</td>
<td style="text-align:left">512B ~ 16KB</td>
<td style="text-align:left">不同数据库页的大小不一样，SQLite和Oracle的页大小4KB，mySQL页的大小是16KB</td>
</tr>
</tbody>
</table>
</div>
<h4 id="页面管理架构"><a href="#页面管理架构" class="headerlink" title="页面管理架构"></a>页面管理架构</h4><p>不同的数据库管理系统有不同方式去管理磁盘里面文件的page，大致有以下三种，这门课主要介绍第一种，堆文件组织。在这个层面上我们不需要知道page的具体内容是什么，只需要关心怎么存储页和读写。</p>
<ul>
<li>Heap File Organization （堆文件组织）</li>
<li>Sequential / Sorted File Organization （序列文件组织）</li>
<li>Hashing File Organization （哈希文件组织）</li>
</ul>
<h4 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h4><p>堆文件指的是一个关于页的无序集合，并且支持页的创建/读取/写入/删除的操作，同时还需要可以遍历所有页。同时堆文件需要有元数据来追踪哪些页面已经存在以及哪些页面有空余空间。堆文件的表示方式有两种：</p>
<ul>
<li>链表：目前比较少用</li>
<li>页目录</li>
</ul>
<p>用链表的方法比较简单，只需要在文件起始位置存放两个链表的表头：分别是数据页列表的表头以及空页列表的表头，每个page追踪自身的可用空间，大致如下图所示。</p>
<img src="/2020/04/22/CMU-DB-4-database-storage-1/linkedlist.png" class="" title="CMU-DB-4-database-storage-1">
<p>用页目录的方法需要DBMS 维护一个特定的页来通过数据页的id来追踪数据库中所有数据页的位置，并且记录每个页还有多少可用空间，因此很重要的一点是保证页目录和各个页需要同步（我们需要考虑当在页目录更新过程系统崩溃的话有什么机制能够让页目录能继续同步）。页目录的原理大致如下图所示：</p>
<img src="/2020/04/22/CMU-DB-4-database-storage-1/page-directory.png" class="" title="CMU-DB-4-database-storage-1">
<h3 id="Page-layout"><a href="#Page-layout" class="headerlink" title="Page layout"></a>Page layout</h3><h4 id="Page-header-页头"><a href="#Page-header-页头" class="headerlink" title="Page header 页头"></a>Page header 页头</h4><p>每个页都包含一个页头来存储关于这个页的内容的元数据，主要包括以下几个参数，部分数据要求页面可以自我解析（例如Oracle，如上述）：</p>
<ul>
<li>Page size: 尺寸</li>
<li>Checksum</li>
<li>BDMS version: 系统版本</li>
<li>Transaction Vsiibility</li>
<li>Compression</li>
</ul>
<h4 id="Page-layout-页布局"><a href="#Page-layout-页布局" class="headerlink" title="Page layout 页布局"></a>Page layout 页布局</h4><p>对于页存储架构来说，我们现在需要理解怎么组织页内部的数据（上一部分关注怎么找到这个页），现在假设我们只存储tuples。有两种方式，分别是：</p>
<ul>
<li><p>tuple-oriented</p>
<ul>
<li><p>strawman 的方法：页面维护一个变量更新该页tuple的个数，每次往后面逐次添加tuple，如下图。这样的存储方式有一些问题：首先，当我们存的tuple是长度可变的值的话，当我们从中间删除一个tuple然后想添加一个tuple进去的时候，空间不一定匹配，另外我们需要遍历所有tuple找到我们想要的那个，效率比较低，所以目前比较少用。</p>
<img src="/2020/04/22/CMU-DB-4-database-storage-1/strawman.png" class="" title="CMU-DB-4-database-storage-1">
</li>
<li><p>slotted pages：最常用的方案是在page分成两部分，前面部分存页头和一个slot 数组，每个数组位置存取到某个tuple的偏移量（offset），而后面部分则是存tuple数据，页头需要最终用过的slot的数量以及最后一个用过的slot的起始位置，大致原理如下图所示：</p>
<img src="/2020/04/22/CMU-DB-4-database-storage-1/slot_pages.png" class="" title="CMU-DB-4-database-storage-1">
</li>
</ul>
</li>
<li><p>Log-structured：相对于存放tuple，log-sturctured 的组织方式存放的用户用户操作记录，如下图所示：每次操作往 page 插入一条新的 entry，插入新 tuple 的时候就在该 entry 存放 tuple，删除 tuple 或者更新 tuple 就查找该 tuple 的位置标记为已删除/更新参数，这种方法优点是便于回滚以及写入速度快，缺点是查找某个 tuple 的时候需要从后往前扫描来重新生成需要的 tuple，优化方法是可以生成 indexes 来定位tuple在 log 的位置，以及周期性的压缩记录（把更新和删除反映到 该 tuple 创建的 log 上，减少存放的 log 数量）</p>
  <img src="/2020/04/22/CMU-DB-4-database-storage-1/log-structure.png" class="" title="CMU-DB-4-database-storage-1">
</li>
</ul>
<h3 id="tuple-layout"><a href="#tuple-layout" class="headerlink" title="tuple layout"></a>tuple layout</h3><p>一个tuple一般都是一序列字节，由DBMS来解析字节理解具体的类型和值。每个tuple都有一个header包含所有元数据（可见性，null值的bitmap），这里注意我们不需要把数据库的schema存进去，只关注tuple本身。另外，tuple的参数存储顺序<em>一般</em>和我们创建他们的顺序是一致的。</p>
<p>一般可以将相关的tuple存到同一个page（denormalization），这样有可能可以减少需要的I/O操作数，但是在更新的时候可能代价更高（更慢）。如下图，bar里面有foreign key指向boo，denormalization可以把他们的表头预先合在一起。（这种做法现在比较少用，一般不同table的tuple存在不同page里）</p>
<img src="/2020/04/22/CMU-DB-4-database-storage-1/denormal1.png" class="" title="CMU-DB-4-database-storage-1">
<img src="/2020/04/22/CMU-DB-4-database-storage-1/denormal2.png" class="" title="CMU-DB-4-database-storage-1">
<p>DBMS 需要用一个方式来管理每个单独的tuple，一般会对每个tuple 分配一个 record id，大部分的形式是：<code>page_id + offset/slot</code>（在上一部分提到的方式），也有可能还会存文件位置信息。但是这个信息每个DBMS的管理策略都不一样，用户不应该依赖这些信息表明顺序等等任何事情。</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>[CMU-15-445/645]-Assignment 1</title>
    <url>/2020/04/22/CMU-DB-3-HW1/</url>
    <content><![CDATA[<p>这是我在学习 <a href="https://15445.courses.cs.cmu.edu/fall2019/" target="_blank" rel="noopener">Databases Systems CMU 15-445/645/ Fall 2019</a> 过程记录的一些笔记，本文了记录我在完成第一次作业的过程中完成结果和遇到的一些疑问。</p>
<a id="more"></a>
<h2 id="作业-amp-软件安装"><a href="#作业-amp-软件安装" class="headerlink" title="作业 &amp; 软件安装"></a>作业 &amp; 软件安装</h2><p>本次作业主要是熟悉以下SQL的各种用法，用的软件是Sqlite3，软件安装过程以及数据集下载都可以根据<a href="https://15445.courses.cs.cmu.edu/fall2019/homework1/" target="_blank" rel="noopener">作业指导</a>，下载完数据集之后用sqlite验证一下各部分是不是都完好，这一部分没遇到什么问题。以下是我的运行环境：</p>
<pre><code>    系统：Ubuntu18.04
    sqlite版本：
    $ sqlite3 -version
    3.22.0 2018-01-22 18:45:57 0c55d179733b46d8d0ba4d88e01a25e10677046ee3da1d5b1581e86726f2alt1
</code></pre><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h3 id="Q1-SAMPLE"><a href="#Q1-SAMPLE" class="headerlink" title="Q1 SAMPLE"></a>Q1 SAMPLE</h3><p>运行一下样本代码并保存。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 输出电影里面所有类别（不重复）</span><br><span class="line">sqlite&gt; select distinct(type) from titles order by type;</span><br><span class="line">movie</span><br><span class="line">short</span><br><span class="line">tvEpisode</span><br><span class="line">tvMiniSeries</span><br><span class="line">tvMovie</span><br><span class="line">tvSeries</span><br><span class="line">tvShort</span><br><span class="line">tvSpecial</span><br><span class="line">video</span><br><span class="line">videoGame</span><br></pre></td></tr></table></figure>
<h3 id="Q2-UNCOMMON-TYPE"><a href="#Q2-UNCOMMON-TYPE" class="headerlink" title="Q2 UNCOMMON_TYPE"></a>Q2 UNCOMMON_TYPE</h3><blockquote>
<p>List the longest title of each type along with the runtime minutes.</p>
</blockquote>
<p>找出每一类电影中时长最久的电影，如果有时长一样的话全部选择，最后输出电影类型，电影名和持续时间。输出时按照类别升序，类别相同时按照名称升序输出。<br>这道题最初想用嵌套查找+<code>RANK()</code>来做，类似课上讲的 <a href="https://guoxiaotao.xyz/2020/04/20/CMU-DB-2-Advanced-SQL/">输出每门课上id最高的学生</a> 的例子，但是sqlite3一直报括号附近语法错误，直接运行老师的代码都不行，最后也没弄明白，最后换了一种思路用  <code>with</code>来写，先找出每类最长电影的持续时长存在一个中间table里面，后面输出就比较简单了，结果和答案一样，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select longest runtime by type and its type</span></span><br><span class="line"><span class="keyword">WITH</span> temp(maxruntime, t) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(runtime_minutes), titles.type <span class="keyword">FROM</span> titles <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">type</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> titles.type, titles.primary_title, titles.runtime_minutes <span class="keyword">FROM</span> titles, temp</span><br><span class="line"><span class="keyword">WHERE</span> titles.runtime_minutes = temp.maxruntime</span><br><span class="line"><span class="keyword">AND</span> titles.type = temp.t</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">type</span> <span class="keyword">ASC</span>, primary_title <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">sqlite&gt; .read ./placeholder/q2_uncommon_type.sql</span><br><span class="line">movie|Logistics|51420</span><br><span class="line">short|Kuriocity|461</span><br><span class="line">tvEpisode|Téléthon 2012|1800</span><br><span class="line">tvMiniSeries|Kôya no yôjinbô|1755</span><br><span class="line">tvMovie|ArtQuench Presents Spirit Art|2112</span><br><span class="line">tvSeries|The Sharing Circle|8400</span><br><span class="line">tvShort|Paul McCartney Backstage at Super Bowl XXXIX|60</span><br><span class="line">tvShort|The People Next Door|60</span><br><span class="line">tvSpecial|Katy Perry Live: Witness World Wide|5760</span><br><span class="line">video|Midnight Movie Madness: 50 Movie Mega Pack|5135</span><br><span class="line">videoGame|Flushy Fish VR: Just Squidding Around|1500</span><br></pre></td></tr></table></figure>
<h3 id="Q3-TV-VS-MOVIE"><a href="#Q3-TV-VS-MOVIE" class="headerlink" title="Q3 TV_VS_MOVIE"></a>Q3 TV_VS_MOVIE</h3><blockquote>
<p>List all types of titles along with the number of associated titles.</p>
</blockquote>
<p>输出每个类别和该类别的电影数量，按数量升序输出。<br>这道题相对上一道题比较简单，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> type_number(<span class="keyword">type</span>, <span class="built_in">number</span>) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">type</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> titles <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">type</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> type_number <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">number</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">tvShort|4075</span><br><span class="line">videoGame|9044</span><br><span class="line">tvSpecial|9107</span><br><span class="line">tvMiniSeries|10291</span><br><span class="line">tvMovie|45431</span><br><span class="line">tvSeries|63631</span><br><span class="line">video|90069</span><br><span class="line">movie|197957</span><br><span class="line">short|262038</span><br><span class="line">tvEpisode|1603076</span><br></pre></td></tr></table></figure>
<h3 id="Q4-OLD-IS-NOT-GOLD"><a href="#Q4-OLD-IS-NOT-GOLD" class="headerlink" title="Q4 OLD_IS_NOT_GOLD"></a>Q4 OLD_IS_NOT_GOLD</h3><blockquote>
<p>Which decades saw the most number of titles getting premiered? List the number of titles in every decade. Like <code>2010s|2789741</code>.</p>
</blockquote>
<p>按电影年代输出每个年代的电影数量，按电影数量降序输出。</p>
<p>这道题一开始想到用一个<code>WITH</code>创建了临时表格存储年代以及对应的电影，最后可以通过按年代<code>COUNT</code>输出年代以及数量（上映年份为<code>NULL</code>的去除），但是这样不能用数量作为排序标准，后来参考<a href="https://cakebytheoceanluo.github.io/2020/03/07/CMU-15445-HomeWork1-19Fall/" target="_blank" rel="noopener">这个博主的做法</a>，创建了两个临时表格最后输出，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">period</span>(<span class="keyword">year</span>, movie) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="keyword">CAST</span>(premiered <span class="keyword">AS</span> <span class="built_in">TEXT</span>), <span class="number">1</span>, <span class="number">3</span>) ||  <span class="string">"0s"</span>,</span><br><span class="line">                primary_title <span class="keyword">FROM</span> titles</span><br><span class="line">        <span class="keyword">WHERE</span> premiered <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">), year_num(<span class="keyword">year</span>, <span class="keyword">num</span>) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">year</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> <span class="keyword">period</span></span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">year</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>, <span class="keyword">num</span> <span class="keyword">FROM</span> year_num <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 输出</span></span><br><span class="line">sqlite&gt; .read ./placeholder/q4_old_is_not_gold.sql</span><br><span class="line">2010s|1050732</span><br><span class="line">2000s|494639</span><br><span class="line">1990s|211453</span><br><span class="line">1980s|119258</span><br><span class="line">1970s|99707</span><br><span class="line">1960s|75237</span><br><span class="line">1950s|39554</span><br><span class="line">1910s|26596</span><br><span class="line">1920s|13153</span><br><span class="line">1930s|11492</span><br><span class="line">1940s|10011</span><br><span class="line">1900s|9586</span><br><span class="line">2020s|2492</span><br><span class="line">1890s|2286</span><br><span class="line">1880s|22</span><br><span class="line">1870s|1</span><br></pre></td></tr></table></figure>
<h3 id="Q5-PERCENTAGE"><a href="#Q5-PERCENTAGE" class="headerlink" title="Q5 PERCENTAGE"></a>Q5 PERCENTAGE</h3><blockquote>
<p>List the decades and the percentage of titles which premiered in the corresponding decade. Display like : <code>2010s|45.7042</code></p>
</blockquote>
<p>在上一题的基础上把数量换成总电影的百分比（包括<code>NULL</code>的部分）。这一题一开始卡在怎么计算电影总量不被 <code>group</code> 影响，后来发现可以用 <code>select</code> 生成一个临时变量，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">period</span>(<span class="keyword">year</span>, movie) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="keyword">CAST</span>(premiered <span class="keyword">AS</span> <span class="built_in">TEXT</span>), <span class="number">1</span>, <span class="number">3</span>) ||  <span class="string">"0s"</span>,</span><br><span class="line">                primary_title <span class="keyword">FROM</span> titles</span><br><span class="line">        <span class="keyword">WHERE</span> premiered <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>)</span><br><span class="line">, year_num(<span class="keyword">year</span>, <span class="keyword">num</span> ) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">year</span>, </span><br><span class="line">        <span class="keyword">ROUND</span>(<span class="number">100.0</span> * <span class="keyword">COUNT</span>(*)/ (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> titles), <span class="number">4</span>) <span class="keyword">FROM</span> <span class="keyword">period</span></span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">year</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>, <span class="keyword">num</span> <span class="keyword">FROM</span> year_num <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 输出</span></span><br><span class="line">sqlite&gt; .read ./placeholder/q5_percentage.sql</span><br><span class="line">2010s|45.7891</span><br><span class="line">2000s|21.5555</span><br><span class="line">1990s|9.2148</span><br><span class="line">1980s|5.1971</span><br><span class="line">1970s|4.3451</span><br><span class="line">1960s|3.2787</span><br><span class="line">1950s|1.7237</span><br><span class="line">1910s|1.159</span><br><span class="line">1920s|0.5732</span><br><span class="line">1930s|0.5008</span><br><span class="line">1940s|0.4363</span><br><span class="line">1900s|0.4177</span><br><span class="line">2020s|0.1086</span><br><span class="line">1890s|0.0996</span><br><span class="line">1880s|0.001</span><br><span class="line">1870s|0.0</span><br></pre></td></tr></table></figure>
<h3 id="Q6-DUBBED-SMASH"><a href="#Q6-DUBBED-SMASH" class="headerlink" title="Q6 DUBBED_SMASH"></a>Q6 DUBBED_SMASH</h3><blockquote>
<p>List the top 10 dubbed titles with the number of dubs.</p>
</blockquote>
<p>按配音版本数量降序输出前十名配音版本最多的电影名和对应的数量，这道题先找到所有的配音版本电影数量，再用 <code>LIMIT</code> 来限制输出数量，代码如下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> dubbed(t_id, <span class="keyword">num</span>) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> title_id, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> akas</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> title_id</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> primary_title, <span class="keyword">num</span>  <span class="keyword">FROM</span> dubbed, titles</span><br><span class="line"><span class="keyword">WHERE</span> titles.title_id = dubbed.t_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 输出</span></span><br><span class="line">sqlite&gt; .read ./placeholder/q6_dubbed_smash.sql</span><br><span class="line">Mutant Virus: Vol. 1|126</span><br><span class="line">The Good, the Bad and the Ugly|73</span><br><span class="line">Star Wars: Episode V - The Empire Strikes Back|71</span><br><span class="line">Dr. Strangelove or: How I Learned to <span class="keyword">Stop</span> Worrying <span class="keyword">and</span> Love the Bomb|<span class="number">68</span></span><br><span class="line">Raiders <span class="keyword">of</span> the Lost Ark|<span class="number">62</span></span><br><span class="line">Star Wars: Episode VII - The <span class="keyword">Force</span> Awakens|<span class="number">62</span></span><br><span class="line">The Shawshank Redemption|<span class="number">61</span></span><br><span class="line">Once Upon a <span class="built_in">Time</span> <span class="keyword">in</span> the West|<span class="number">60</span></span><br><span class="line">Indiana Jones <span class="keyword">and</span> the Kingdom <span class="keyword">of</span> the Crystal Skull|<span class="number">60</span></span><br><span class="line">Airplane!|<span class="number">59</span></span><br></pre></td></tr></table></figure>
<h3 id="Q7-IMDB-250"><a href="#Q7-IMDB-250" class="headerlink" title="Q7 IMDB_250"></a>Q7 IMDB_250</h3><blockquote>
<p>List the IMDB Top 250 movies along with its weighted rating.</p>
</blockquote>
<p>按权重分数降序输出IMDB TOP250电影，计算规则如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Weighted rating (WR) = (v/(v+m)) * R + (m/(v+m)) * C</span><br><span class="line">R = 电影平均得分 i.e. ratings.rating</span><br><span class="line">v = 电影投票数, i.e. ratings.votes</span><br><span class="line">m = 要进top250的最少投票数 (current 25000)</span><br><span class="line">C = 所有投票的平均得分 （计算方式是所有投票乘相应得分再除以总票数）</span><br></pre></td></tr></table></figure>
<p>这道题主要就是注意以下各个变量的计算方法还有imbd要限定类型是电影，代码如下，结果太长就不打了，确认过和答案一样。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> wr( t_id, WR ) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> ratings.title_id,</span><br><span class="line">        (votes / (votes + <span class="number">25000.0</span>)) * rating +</span><br><span class="line">        (<span class="number">25000.0</span> / (votes + <span class="number">25000.0</span>)) * </span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="keyword">SUM</span>(rating * votes) / <span class="keyword">SUM</span>(votes) <span class="keyword">FROM</span> ratings, titles </span><br><span class="line">         <span class="keyword">WHERE</span> ratings.title_id = titles.title_id <span class="keyword">AND</span> titles.type = <span class="string">"movie"</span>)</span><br><span class="line">        <span class="keyword">FROM</span> ratings,titles</span><br><span class="line">        <span class="keyword">WHERE</span> ratings.title_id = titles.title_id <span class="keyword">AND</span> titles.type = <span class="string">"movie"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> primary_title, WR <span class="keyword">FROM</span> wr, titles</span><br><span class="line"><span class="keyword">WHERE</span> titles.title_id = t_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> WR <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">250</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Q8-NUMBER-OF-ACTORS"><a href="#Q8-NUMBER-OF-ACTORS" class="headerlink" title="Q8 NUMBER_OF_ACTORS"></a>Q8 NUMBER_OF_ACTORS</h3><blockquote>
<p>List the number of actors / actresses who have appeared in any title with Mark Hamill (born in 1951).</p>
</blockquote>
<p>输出所有和mark hamill有合作过的演员。这道题的思路是可以先找到所有mark hamill参演过的节目，然后再找到参演过那些节目的演员，主要去去重，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> title_with_hamill(title_id) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> title_id <span class="keyword">FROM</span> crew, people</span><br><span class="line">        <span class="keyword">WHERE</span> crew.person_id = people.person_id  </span><br><span class="line">        <span class="keyword">AND</span> people.name = <span class="string">"Mark Hamill"</span> </span><br><span class="line">        <span class="keyword">AND</span> people.born = <span class="number">1951</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> person_id) <span class="keyword">FROM</span> crew, title_with_hamill</span><br><span class="line"><span class="keyword">WHERE</span> crew.title_id = title_with_hamill.title_id</span><br><span class="line"><span class="keyword">AND</span> (crew.category = <span class="string">"actor"</span> <span class="keyword">OR</span> crew.category = <span class="string">"actress"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 输出</span></span><br><span class="line">sqlite&gt; .read ./placeholder/q8_number_of_actors.sql</span><br><span class="line">206</span><br></pre></td></tr></table></figure>
<h3 id="Q9-MOVIE-NAMES"><a href="#Q9-MOVIE-NAMES" class="headerlink" title="Q9 MOVIE_NAMES"></a>Q9 MOVIE_NAMES</h3><blockquote>
<p>List the movies in alphabetical order which cast both Mark Hamill (born in 1951) and George Lucas (born in 1944).</p>
</blockquote>
<p>输出所有Mark Hamill 和 George Lucas 共同参演的电影名，按字母顺序输出，思路跟上一题差不多，找到mark hamill 参演的电影在在里面找 Georage Lucas 参演的过输出名字就可以了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> title_with_hamill(title_id) <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> title_id <span class="keyword">FROM</span> crew, people</span><br><span class="line">        <span class="keyword">WHERE</span> crew.person_id = people.person_id  </span><br><span class="line">        <span class="keyword">AND</span> people.name = <span class="string">"Mark Hamill"</span></span><br><span class="line">        <span class="keyword">AND</span> people.born = <span class="number">1951</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> primary_title <span class="keyword">FROM</span> crew, title_with_hamill, people, titles</span><br><span class="line"><span class="keyword">WHERE</span> crew.title_id = title_with_hamill.title_id</span><br><span class="line"><span class="keyword">AND</span> titles.type = <span class="string">"movie"</span></span><br><span class="line"><span class="keyword">AND</span> crew.title_id = titles.title_id</span><br><span class="line"><span class="keyword">AND</span> (crew.person_id = people.person_id </span><br><span class="line">        <span class="keyword">AND</span> people.name = <span class="string">"George Lucas"</span> </span><br><span class="line">        <span class="keyword">AND</span> people.born = <span class="number">1944</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> primary_title;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 输出</span></span><br><span class="line">sqlite&gt; .read ./placeholder/q9_movie_names.sql</span><br><span class="line">Star Wars: Episode V - The Empire Strikes Back</span><br></pre></td></tr></table></figure>
<h3 id="Q10-GENRE-COUNTS"><a href="#Q10-GENRE-COUNTS" class="headerlink" title="Q10 GENRE_COUNTS"></a>Q10 GENRE_COUNTS</h3><blockquote>
<p>List all distinct genres and the number of titles associated with them.</p>
</blockquote>
<p>从<code>title</code>里面的<code>genres</code>类别提取出所有不重复的类别，并类别输出相对应的节目数量，按降序排列，这里主要参考了<a href="https://stackoverflow.com/a/32051164" target="_blank" rel="noopener">这种做法</a>，将<code>genres</code>里的值取出来然后统一成<code>&#39;&#39;, &#39;...,...,...,&#39;</code>的格式，然后通过迭代和用<code>INSTR</code>找到逗号的位置，以及<code>SUBSTR</code>分割字符串来提取出所有类，最后按类别输出数量，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">split</span>(word, <span class="keyword">str</span>) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="string">''</span>, genres || <span class="string">','</span> <span class="keyword">FROM</span> titles</span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">SUBSTR</span>(<span class="keyword">str</span>, <span class="number">0</span>, <span class="keyword">INSTR</span>(<span class="keyword">str</span>, <span class="string">','</span>)),</span><br><span class="line">    <span class="keyword">SUBSTR</span>(<span class="keyword">str</span>, <span class="keyword">INSTR</span>(<span class="keyword">str</span>, <span class="string">','</span>)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">FROM</span> <span class="keyword">split</span> <span class="keyword">WHERE</span> <span class="keyword">str</span>!=<span class="string">''</span></span><br><span class="line">), </span><br><span class="line">genre_num(genre, <span class="keyword">num</span>) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> word, <span class="keyword">count</span>(word) </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">split</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> word</span><br><span class="line"><span class="keyword">HAVING</span> word != <span class="string">''</span> <span class="keyword">AND</span> word != <span class="string">'\N'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span>  * <span class="keyword">FROM</span> genre_num</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">sqlite&gt; .read ./placeholder/q10_genre_counts.sql</span><br><span class="line">Drama|620063</span><br><span class="line">Comedy|486163</span><br><span class="line">Short|310619</span><br><span class="line">Documentary|222187</span><br><span class="line">Talk-<span class="keyword">Show</span>|<span class="number">215144</span></span><br><span class="line">Romance|<span class="number">211462</span></span><br><span class="line">Family|<span class="number">159035</span></span><br><span class="line">News|<span class="number">148941</span></span><br><span class="line">Animation|<span class="number">115998</span></span><br><span class="line">Reality-TV|<span class="number">113180</span></span><br><span class="line">Music|<span class="number">105724</span></span><br><span class="line">Crime|<span class="number">99019</span></span><br><span class="line"><span class="keyword">Action</span>|<span class="number">97544</span></span><br><span class="line">Adventure|<span class="number">81686</span></span><br><span class="line">Game-<span class="keyword">Show</span>|<span class="number">75169</span></span><br><span class="line">Adult|<span class="number">65704</span></span><br><span class="line">Sport|<span class="number">48855</span></span><br><span class="line">Fantasy|<span class="number">48341</span></span><br><span class="line">Mystery|<span class="number">47155</span></span><br><span class="line">Horror|<span class="number">41552</span></span><br><span class="line">Thriller|<span class="number">40664</span></span><br><span class="line">History|<span class="number">31675</span></span><br><span class="line">Sci-Fi|<span class="number">31441</span></span><br><span class="line">Biography|<span class="number">27001</span></span><br><span class="line">Musical|<span class="number">17939</span></span><br><span class="line">Western|<span class="number">9811</span></span><br><span class="line">War|<span class="number">9309</span></span><br><span class="line">Film-Noir|<span class="number">322</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>激光雷达运动畸变去除</title>
    <url>/2020/04/21/lidarSLAM-3/</url>
    <content><![CDATA[<p>本文是我在学习深蓝学院的<a href="https://www.shenlanxueyuan.com/course/152" target="_blank" rel="noopener">激光slam课程</a>第三讲的学习笔记，在上一节课学习了轮式里程计的校正之后，这一课学习传感器数据预处理的另一部分：激光雷达运动畸变的校正，这一部分是对激光slam的效果和性能影响非常大的部分。这篇大部分的公式推导并不困难，主要在理解不同方法的要点和思想以及优缺点。</p>
<a id="more"></a>
<h2 id="激光雷达"><a href="#激光雷达" class="headerlink" title="激光雷达"></a>激光雷达</h2><h3 id="传感器介绍"><a href="#传感器介绍" class="headerlink" title="传感器介绍"></a>传感器介绍</h3><p>按照测距原理分激光雷达有两种</p>
<h4 id="三角测距"><a href="#三角测距" class="headerlink" title="三角测距"></a>三角测距</h4><p>三角测距的大致原理如下图所示，和双目类似通过两个点测出目标点和两点连线的距离，计算方法大概如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x + y &= L \\
\frac{x}{\sin{(\frac{\pi}{2}-\beta)}} &= \frac{d}{\sin{\beta}} \\
\frac{y}{\sin{(\frac{\pi}{2}-\alpha)}} &= \frac{d}{\sin{\alpha}}
\end{aligned}</script><p>三个方程三个未知数，联立可以解出，可以发现距离和基线和两个出射角都有关：</p>
<script type="math/tex; mode=display">d = L \frac{\sin{\alpha}\sin{\beta}}{\sin{(\alpha+\beta)}}</script><img src="/2020/04/21/lidarSLAM-3/%E4%B8%89%E8%A7%92%E6%B5%8B%E8%B7%9D.png" class="" title="lidarSLAM-3">
<p>三角测距有以下特点：</p>
<ul>
<li><em>受限于基线长度</em>，中近距离精度较高，远距离精度较差（所以一般在室内用）</li>
<li>结构简单，价格比较便宜</li>
<li>比较容易受干扰（强光等）</li>
</ul>
<h4 id="飞行时间测距（tof）"><a href="#飞行时间测距（tof）" class="headerlink" title="飞行时间测距（tof）"></a>飞行时间测距（tof）</h4><p>飞行时间的测距原理如下所示，原理偏光学一点所以不推导了。</p>
<img src="/2020/04/21/lidarSLAM-3/tof.png" class="" title="lidarSLAM-3">
<p>TOF的特点：</p>
<ul>
<li>测距范围广（只跟时间差/光相位差有关，距离影响不大）</li>
<li>测距精度高</li>
<li>抗干扰能力强</li>
<li>价格贵</li>
<li>室内/外都可以用</li>
</ul>
<h3 id="激光雷达数学模型介绍"><a href="#激光雷达数学模型介绍" class="headerlink" title="激光雷达数学模型介绍"></a>激光雷达数学模型介绍</h3><p>这里主要介绍如何通过激光束的观测结果以及地图来计算机器人位姿的数学模型。</p>
<h4 id="光束模型（beam-model）"><a href="#光束模型（beam-model）" class="headerlink" title="光束模型（beam model）"></a>光束模型（beam model）</h4><p>这个模型是概率学提出的比较传统的数学模型，具体来说可以参考以下四张图。假设机器人位姿是 $x_t$, 并且发射一束激光期望能够打到前方 $z_t^*$ (期望值)距离处的物体（根据地图 $m$ 获得期望值），但是由于各种原因（噪声），返回来的值 $z_t$ (观测值)不一定和实际值一致。而光束模型认为总共能有四种噪声和真实值耦合形成观测值，分别是：</p>
<ul>
<li>高斯噪声：高斯噪声使得观测值在真实值周围形成高斯分布 （大部分时候是符合这个分布）</li>
<li>物体被遮挡：因为物体被遮挡所以观测值会比真实值小很多，形成指数分布 （出现动态物体的时候会出现）</li>
<li>没扫到物体：因为物体没被扫到所以观测值无穷大（可以通过判断是否超出有效距离过滤掉）</li>
<li>均匀噪声：均匀噪声使得观测值在真实值周围形成均匀分布（正常传感器应该不太会出现这种噪声）</li>
</ul>
<img src="/2020/04/21/lidarSLAM-3/%E5%85%89%E6%9D%9F%E6%A8%A1%E5%9E%8B.png" class="" title="lidarSLAM-3">
<p>基于这四种模型，我们给每种模型分配不同的权重(对每一个激光点 $z_t^k$， 共k个)<em>计算出在当前位姿基于建好的地图出现观测值的概率就可以用来判断位姿的准确性</em>，计算过程如下：<br>先计算出每个激光点的得分（出现概率，越高所以越准确），第一项是四个模型的权重，一般高斯分布的权重会比较高（大部分），均匀分布的权重比较低（出现情况很少）。</p>
<script type="math/tex; mode=display">
p(z_t^k|x_t, m) = \begin{bmatrix}z_{hit}\\z_{short}\\z_{max}\\z_{rand}\end{bmatrix}^T\begin{bmatrix}p_{hit}(z_t^k|x_t,m)\\p_{short}(z_t^k|x_t,m)\\p_{max}(z_t^k|x_t,m)\\p_{rand}(z_t^k|x_t,m)\end{bmatrix}</script><p>然后我们再把该帧所有激光点的概率相乘就能得到这帧激光束的得分（概率），这个模型的要点就要搜索一个位姿 $x_t^*$ 使得该帧的得分（出现概率）最高。</p>
<script type="math/tex; mode=display">
p(z_t|x_t, m) = \prod_{k=1}^Kp(z_t^k|x_t, m)</script><p>这个模型需要将一个激光束中所有的点的概率都计算出来（一条线上的所有激光点）而且一帧有很多条激光束，<em>计算量大</em>。<br>并且这个模型有一个致命的缺点。假设我们考虑在一个比较结构化的场景（室内环境，大部分都是平面的结构等等）的时候，这个时候当我们在靠近真实值的过程中，我们可以发现计算出来的激光束的得分是逐渐上升的，而且变化大部分是一个连续的过程，这种场景下没有问题。但是如果在比较不规则的场景（室外环境，假设有一个电线杆在 $z_t^<em>$ 处），这个时候只要我们<em>*假设的位姿离真实位姿有一点点的变化都会导致激光束的得分急剧降低</em></em>（只要稍微旋转一下就扫不动电线杆，所以会出现无穷大 $z_{max}$ ，而实际激光束 $z_t$ 并不是），所以这会给搜索带来很大的困难以及误匹配，因为这两个原因，所以现在实际上比较少采用这种模型。</p>
<h4 id="似然场模型-likelyhood-model"><a href="#似然场模型-likelyhood-model" class="headerlink" title="似然场模型 (likelyhood model)"></a>似然场模型 (likelyhood model)</h4><p>似然场模型的原理如下图所示，左边是实际环境图 $m$ ，这个时候如果不考虑似然场的话我们可以认为如果在给定位姿 $x_t$ 的时候打中 实际障碍物的概率是 1，如果没打中就是 0，这样每条激光束出现概率非 0 即 1，过于绝对出现光束模型的病态问题，似然场模型的要点是将地图进行高斯平滑，激光束击中障碍物周围的环境形成以障碍物位姿为中心的高斯分布，这样就算我们估算的位姿不是很准确导致在那个位姿实际上打不到障碍物，如右图所示，该帧观测值的概率也不会是0，而是一个接近1的值，这样做的好处有：</p>
<ul>
<li>结果随环境影响变化不大，适合用于结构化和非结构化环境</li>
<li>不用对每束激光束的所有激光点都计算（只需要对每束光束的端点查表计算概率），计算比较简单</li>
</ul>
<img src="/2020/04/21/lidarSLAM-3/%E4%BC%BC%E7%84%B6%E5%9C%BA.png" class="" title="lidarSLAM-3">
<h3 id="运动畸变成因"><a href="#运动畸变成因" class="headerlink" title="运动畸变成因"></a>运动畸变成因</h3><p>运动畸变如下图所示，观测结果会和真实结果有一个偏差，主要产生的根本原因是<strong>我们假设激光雷达的扫描结果是在同一时刻（机器人位姿没有变化）产生，但是实际上激光雷达的扫描结果需要一定时间，在这个时间内机器人如果有运动的话实际的扫描的结果就会出现偏移</strong>。假设按照下图场景，激光雷达逆时针旋转，在一开始旋转的时候 $t_0$ 机器人还没有往前走，所以结果是准确的，但是在转过一半之后$(t+\delta t)$机器人已经往前走了一段距离，这个时候激光扫描结果会变小（因为靠近墙了），但是我们还是认为他在$t_0$时刻的位置，所以结果就会显示是墙离我们越来越近了，所以会出现歪掉的现象，原因是因为<strong>激光帧率比较低的时候，机器人的运动不能忽略</strong>，这个畸变现象是由于运动畸变带来的（根本原因是旋转速度太慢），所以叫做运动畸变。</p>
<img src="/2020/04/21/lidarSLAM-3/%E7%95%B8%E5%8F%98.png" class="" title="lidarSLAM-3">
<h2 id="运动畸变去除"><a href="#运动畸变去除" class="headerlink" title="运动畸变去除"></a>运动畸变去除</h2><p>接下来开始介绍怎么进行运动畸变的去除。</p>
<h3 id="纯估计方法"><a href="#纯估计方法" class="headerlink" title="纯估计方法"></a>纯估计方法</h3><p>首先讲纯估计的方法，这种方法是一种<em>类ICP</em>的方法。</p>
<h4 id="迭代最近点-ICP-方法"><a href="#迭代最近点-ICP-方法" class="headerlink" title="迭代最近点(ICP)方法"></a>迭代最近点(ICP)方法</h4><p>先介绍ICP的方法，ICP(Itrative Cloest Point)迭代最近点的方法的要点是，给定两个两个点云：</p>
<script type="math/tex; mode=display">
\begin{aligned}
X &= \{x_1, x_2, ..., x_N\}\\
P &= \{p_1, p_2, ..., p_N\}
\end{aligned}</script><p>我们需要找到一个变换关系 $(R, t)$ 使得下式最小，这个过程叫<em>点云配准</em>，或者匹配点云。式子里面有旋转矩阵 $R$ 所以会引入三角量，因此不能用线性最小二乘解来求：</p>
<script type="math/tex; mode=display">
E(R, t) = \frac{1}{N}\sum_{i=1}^{N}||x_i-Rp_i-t||^2</script><p>在<strong>给定两个点云的对应点</strong>的时候，虽然不能用线性最小二乘解，但是这个式子的最小值有解析解（在后面讲到帧间匹配的时候会推导，这里先直接说明，之后补充），计算过程是：</p>
<ul>
<li>先求出两个点云的几何中心</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
u_x &= \sum_{i=1}^{N}x_i\\
u_p &= \sum_{i=1}^{N}p_i
\end{aligned}</script><ul>
<li>对两个点云去中心化</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
X' = \{x_i-u_x\} = \{x_i'\}\\
P' = \{p_i-u_p\} = \{p_i'\}
\end{aligned}</script><ul>
<li>SVD 分解</li>
</ul>
<script type="math/tex; mode=display">
W = \sum_{i=1}^{N}x_i'p_i'^T = U\begin{bmatrix}\sigma_1 & 0 & 0 \\ 0 & \sigma_2 & 0 \\0 & 0 & \sigma_3\end{bmatrix}V^T</script><ul>
<li>ICP 的解是：</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
R &= UV^T\\
t &= u_x - Ru_p
\end{aligned}</script><p>实际过程中，我们大概率并<strong>不知道对应点关系</strong>，这个时候不可以一步计算出 $R$ 和 $t$ 的最佳结果，需要用到<strong>期望最大化</strong> (Expectation Maxmization, EM) 的思想，先给定一个初值（匹配关系），利用初值进行计算 R 和 t, 再根据 R 和 t 对点云进行转换，计算误差和新的匹配关系，根据新的匹配关系进项迭代计算，直至最后算出误差小于一个阈值，这个时候可以认为匹配关系和点云之间的转换关系都计算比较准确了，大概过程如下图所示：</p>
<img src="/2020/04/21/lidarSLAM-3/%E7%BA%AF%E4%BC%B0%E8%AE%A1%E6%B3%95.png" class="" title="lidarSLAM-3">
<h4 id="VICP方法"><a href="#VICP方法" class="headerlink" title="VICP方法"></a>VICP方法</h4><p>ICP在激光匹配中没有考虑两种情况：激光的运动畸变和部分激光数据可能是错误的（错误数据可能就是来自于运动畸变）。基于这种情况，VICP（Velocity-ICP）把速度的影响也考虑在内，它的要点是假设机器人在扫描过程中进行<strong>匀速运动</strong>，在匹配迭代的时候同时估计机器人的速度，本质上用匀速运动对一帧内的位姿进行线性插值（LOAM里面也有用到这个方法），具体计算过程如下：</p>
<ul>
<li>$X^i, X^{i-1}$ 表示第i帧和第i-1帧的激光扫描数据</li>
<li>$T^i, T^{i-1}$ 表示对应时刻的位姿</li>
<li>机器人的速度$V_i$可以通过两个时刻的位姿和时间差求出</li>
<li>我们把第i帧的时间划分为n段，分别是:</li>
</ul>
<script type="math/tex; mode=display">(t_i-n\Delta t, t_i - (n-1)\Delta t, ... ,t_i - \Delta t, t_i)</script><ul>
<li>则第i帧的第j个节点的位姿矩阵是：$T_{t_i - (n-j)\Delta t} = T_ie^{(n-j)\Delta t(-V_i)}$</li>
<li>所以校正过程是：$\bar X^i = \{e^{(n-j)\Delta t(-V_i)}x_j|j=0,…,n\}$</li>
</ul>
<p>算法流程和效果如下图所示：</p>
<img src="/2020/04/21/lidarSLAM-3/vicp.png" class="" title="lidarSLAM-3">
<h3 id="里程计辅助方法"><a href="#里程计辅助方法" class="headerlink" title="里程计辅助方法"></a>里程计辅助方法</h3><p>VICP有两个缺点：</p>
<ul>
<li>在用低帧率（5Hz， 200ms）的激光雷达，匀速运动假设不成立（每帧时间太长）</li>
<li>在数据预处理（去畸变）的过程中跟状态估计（速度和位姿估计）耦合在一起</li>
</ul>
<p>而里程计/IMU可以弥补这个缺点，因为它的位姿更新频率很快(200Hz，5ms, IMU能到1kHz)，所以能够更加准确的反应运动情况，同时可以跟状态估计完全解耦。因此在里程计短时间内(200ms)的准确度比较高的时候，我们可以借助里程计来去除畸变，IMU的更新频率也很快，但是它的线性加速度精度太差（控制成本的情况下），所以几乎不能用来估计位置信息。</p>
<p>在处理信息的时候也有两种思路：</p>
<ul>
<li>单片机读取激光雷达数据和位姿信息，进行运动畸变去除，然后上传到CPU，好处是不用考虑不同系统的时间同步问题，但是由于在单片机处理之后再上传所以数据需要压缩，否则会产生延时</li>
<li>用CPU读取激光雷达数据，然后单片机上传里程计积分数据，先对数据进行时间同步然后统一进行畸变去除，需要位姿插值，因为没有时延问题所以通常采用这种方法。</li>
</ul>
<p>接下来介绍具体方法，我们已知的数据有：</p>
<ul>
<li>当前帧激光起始时间：$t_s, t_e$</li>
<li>(同一帧内)两束激光的时间差$\Delta t$</li>
<li>一个包含里程计数据的队列，时间范围应该覆盖当前帧激光的时间范围</li>
</ul>
<p>接下来具体目标为：</p>
<ul>
<li>获得当前帧激光数据每一个激光束端点的机器人位姿</li>
<li>根据求解的位姿把所有激光束转换到统一坐标系下</li>
<li>重新封装成一帧激光数据并发布</li>
</ul>
<p>其中关键步骤就是计算当前帧激光数据的对应机器人位姿：</p>
<ul>
<li>假如里程计数据队列正好对到了激光数据的时间范围（时间同步好了），那么激光帧的起止时间的位姿就是里程计数据队列的队头和队尾数据的时间戳</li>
<li>如果开始时间没有对应里程计位姿数据，则用里程计相邻的两个位姿数据进行线性插值（因为里程计数据采集频率高，所以做匀速运动进行线性插值比较合理）</li>
<li>在一帧数据之间的任意一点<ul>
<li>认为机器人做匀加速运动进行二次插值（用起始点，结束点和中间点）</li>
<li>还可以进行分段线性插值（用激光帧时间范围内的所有里程计数据点进行分段线性插值）</li>
</ul>
</li>
</ul>
<p>获得每个激光点对应的机器人位姿 $p_i$ 之后，可以将激光点信息 $x_i$（在当前时间插值得到的位姿坐标系下）转换为统一的坐标系下（比如起始时间）：$x_i’=p_i^Tx_i$，接下来重新封装激光信息发布出去：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x_i' &= (p_x, p_y)\\
range &= \sqrt{p_x^2+p_y^2}\\
angle &= \arctan{(p_y, p_x)}
\end{aligned}</script><h3 id="融合方法"><a href="#融合方法" class="headerlink" title="融合方法"></a>融合方法</h3><p>融合方法主要就是考虑前两种的方法的融合。我们先用里程计方法插值得到位姿数据进行去畸变。假设我们认为里程计方法还是存在误差（采集频率还是不够快），我们可以认为误差是跟时间线性分布的，所以我们用ICP的方法进行一次匹配，并将匹配结果作为正确值，这个过程会产生一个误差作为里程计的误差值。基于误差线性分布的假设，我们可以把误差平均分配到每一个时间段内，进行激光点修正，然后再进行ICP迭代直到结果收敛。</p>
]]></content>
      <categories>
        <category>激光slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>lidar-slam</tag>
      </tags>
  </entry>
  <entry>
    <title>[CMU-15-445/645]-Advanced SQL</title>
    <url>/2020/04/20/CMU-DB-2-Advanced-SQL/</url>
    <content><![CDATA[<p>这是我在学习<a href="https://15445.courses.cs.cmu.edu/fall2019/" target="_blank" rel="noopener">Databases Systems CMU 15-445/645/ Fall 2019</a>过程记录的一些笔记，这节课介绍了SQL的各种语法和应用，主要包括聚合/窗口函数、对字符串和日期的操作、输出控制和重定向以及常用表达式，一部分代码可能逻辑上有点模糊，最好自己跑一下深化理解。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="关于-relational-language-的复习"><a href="#关于-relational-language-的复习" class="headerlink" title="关于 relational language 的复习"></a>关于 relational language 的复习</h3><p>在上一篇中主要介绍了Relational Language的一些基本概念以及相对应的Relational Algebra的一些基本用法。这里面有一个很重要的概念是在使用Relational language的时候只需要说明他们想要得到什么样的结果/答案，并不用去关心如何得到这个结果（包括怎么用relational algebra的基本操作去得到答案），这一部分应该由DBMS(数据库管理系统)去完成以及优化每一次查询操作（包括重新排列用户给的操作以及产生一个查找计划）。</p>
<h3 id="SQL的历史"><a href="#SQL的历史" class="headerlink" title="SQL的历史"></a>SQL的历史</h3><p>SQL最初是从IBM的 system R 中一个叫 “SEQUEL” 的语言演变而来，意思是 “Structred English Query Language”，并在19世纪79年代被 Oracle 采用。在1983年 IBM 发布了DB2，接下来在1986 年被ANSI 作为标准，ISO 在1987 年将他命名为 SQL (Structured Query Language)，目前最新的 SQL 标准到 2016 年，大部分 DBMS 至少支持 SQL-92。</p>
<p>SQL 实际上包括了三种语言，分别是：</p>
<ul>
<li>Data Manipulation Language (DML)：插入，更新，删除数据</li>
<li>Data Definition Language (DDL)：创建定义数据库</li>
<li>Data Conrtol Language (DCL)：权限控制</li>
</ul>
<p>除此之外还包括：查看定义（View Definition），添加控制条件保证数据完整性等等。另外，跟之前提到relational model不一样，SQL是基于 <strong>Bag(无序，但是允许重复数据)</strong> 的，而不是Set(无序且不允许重复)。</p>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="聚合（Aggregations）-分组-Group-By"><a href="#聚合（Aggregations）-分组-Group-By" class="headerlink" title="聚合（Aggregations） + 分组(Group By)"></a>聚合（Aggregations） + 分组(Group By)</h3><p>假设我们现在有一个数据库包括以下三个表格，主要表示了学生信息和课程信息以及他们之间关系：</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/example.png" class="" title="CMU-DB-2-Advanced-SQL">
<h4 id="Aggregates-（聚合）"><a href="#Aggregates-（聚合）" class="headerlink" title="Aggregates （聚合）"></a>Aggregates （聚合）</h4><p>聚合操作是一系列函数的总称，这些函数的特点是取一系列 tuples 然后返回一个单元素(single value)，具体包括以下这些：</p>
<ul>
<li><code>AVG(col)</code>: 返回该列的平均值，下面以此类推</li>
<li><code>MIN(col)</code></li>
<li><code>MAX(col)</code></li>
<li><code>SUM(col)</code></li>
<li><code>COUNT(col)</code>:返回该列元素个数</li>
</ul>
<p>下面看一下这些函数的具体使用场景。</p>
<p>假设我们想要获取用“@cs”邮箱登录的学生个数，我们可能会用以下SQL语句，我们会注意到聚合函数只会用在 SELECT 语句的输出列表中（很显然，因为聚合函数只会产生一个元素所以肯定是最终结果）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(login) <span class="keyword">AS</span> cnt</span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> login <span class="keyword">LIKE</span> <span class="string">'%@cs'</span></span><br></pre></td></tr></table></figure>
<p>我们还可以用以下两种语句来进一步简化：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// ver 2</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt</span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> login <span class="keyword">LIKE</span> <span class="string">'@cs'</span></span><br><span class="line"></span><br><span class="line">// ver <span class="number">3</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">AS</span> cnt</span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> login <span class="keyword">LIKE</span> <span class="string">'%@cs'</span></span><br></pre></td></tr></table></figure>
<p>我们还可以同时使用多个聚合函数，假设我们想获得<code>“@cs”</code>邮箱登录的学生个数和他们的平均GPA，可以用以下方式查找，最后会输出含一个tuple（平均GPA和学生个数）的表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(gpa), <span class="keyword">COUNT</span>(<span class="keyword">sid</span>)</span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> login <span class="keyword">LIKE</span> <span class="string">'%@cs'</span></span><br></pre></td></tr></table></figure>
<p>聚合函数中 <code>COUNT</code>, <code>SUM</code>, <code>AVG</code> 还支持对其输入参数用关键字 <code>DISTINCT</code> 来进行去重，用以下方式可以获得用”@cs”邮箱登录的不重复学生人数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> login) <span class="keyword">AS</span> cnt</span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> login <span class="keyword">LIKE</span> <span class="string">'%@cs'</span></span><br></pre></td></tr></table></figure>
<p>在使用聚合函数的过程要注意在聚合函数以外的列的输出是<em>未定义的(undefined)</em>，具体参考以下例子</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 获取每门课上注册学生的平均GPA</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(s.gpa), e.cid</span><br><span class="line">    <span class="keyword">FROM</span> enrolled <span class="keyword">as</span> e, student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> e.sid = s.sid</span><br></pre></td></tr></table></figure>
<p>程序在不同程序(pavlo，mysql, sqlite)的运行结果，可以发现对这种未定义的行为，不同程序的标准一样，可能会直接报错，也有可能随机挑选一个值输出，所以要尽可能避免出现这种情况：</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/output-result.png" class="" title="CMU-DB-2-Advanced-SQL">
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/result-mysql.png" class="" title="CMU-DB-2-Advanced-SQL">
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/sqlite.png" class="" title="CMU-DB-2-Advanced-SQL">
<h4 id="分组（group-by）"><a href="#分组（group-by）" class="headerlink" title="分组（group by）"></a>分组（group by）</h4><p>要实现上述提到的查找（获取每门课上注册学生的平均GPA），我们还需要加入分组操作来将输入的tuples分成不同部分并对每个部分进行聚合运算，代码和结果如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(s.gpa), e.cid</span><br><span class="line">    <span class="keyword">FROM</span> enrolled <span class="keyword">AS</span> e, student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> e.sid = s.sid</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> e.sid</span><br></pre></td></tr></table></figure>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/result2.png" class="" title="CMU-DB-2-Advanced-SQL">
<p>注意：所有出现在 <code>SELECT</code> 输出语句的非聚合值必须都要出现 <code>GROUP BY</code> 语句里，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// s.name 要出现在 GROUP BY 语句里</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(s.gpa), e.cid， s.name</span><br><span class="line">    <span class="keyword">FROM</span> enrolled <span class="keyword">AS</span> e, student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> e.sid = s.sid</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> e.sid</span><br></pre></td></tr></table></figure>
<p>如果我们想对输出的table进行筛选，比如选出平均gpg高于3.9的，我们可能会想到以下语句，但是聚合计算的结果不能出现<code>ADD</code>语句里面，我们可以用HAVGING语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// avg_gpa 不能出现在 AND 作为条件！</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(s.gpa) <span class="keyword">AS</span> avg_gpa, e.cid</span><br><span class="line">    <span class="keyword">FROM</span> enrolled <span class="keyword">AS</span> e, student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> e.sid = s.sid</span><br><span class="line">    <span class="keyword">AND</span> avg_gpa &gt; <span class="number">3.9</span></span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> e.sid</span><br><span class="line"></span><br><span class="line">// avg_gpa 可以出现在<span class="keyword">HAVING</span>语句里作为筛选条件</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(s.gpa) <span class="keyword">AS</span> avg_gpa, e.cid</span><br><span class="line">    <span class="keyword">FROM</span> enrolled <span class="keyword">AS</span> e, student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> e.sid = s.sid</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> e.sid</span><br><span class="line">    <span class="keyword">HAVING</span> avg_gpa &gt; <span class="number">3.0</span>;</span><br></pre></td></tr></table></figure>
<p>成果运行结果如下：</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/result-filter.png" class="" title="CMU-DB-2-Advanced-SQL">
<p>通过这种方式可以很方便筛选我们想要的结果，而且不用考虑实现过程。</p>
<h3 id="String-amp-Date-Time-Operation"><a href="#String-amp-Date-Time-Operation" class="headerlink" title="String &amp; Date/Time Operation"></a>String &amp; Date/Time Operation</h3><p>下面对SQL里面有关string, date 和 time 的操作进行介绍</p>
<h4 id="String-字符串操作"><a href="#String-字符串操作" class="headerlink" title="String 字符串操作"></a>String 字符串操作</h4><p>针对String的操作，不同DBMS的它的要求（单/双引号，区分/不区分大小写）不一样，具体参考下表</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/string-1.png" class="" title="CMU-DB-2-Advanced-SQL">
<p><strong>LIKE</strong> 关键字可以用来进行字符串匹配，匹配操作为：<code>&#39;%&#39;</code>匹配任何子串（包括空串），’_’ 匹配任何单个字符，具体例子如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 找到所有 e.cid 以 '15-' 开头的</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> enrolled <span class="keyword">AS</span> e</span><br><span class="line">    <span class="keyword">WHERE</span> e.cid <span class="keyword">LIKE</span> <span class="string">'15-%'</span></span><br><span class="line"></span><br><span class="line">// 找到所有登录名 以 <span class="string">'@c'</span> + 一个字符串结尾的</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> s.login <span class="keyword">LIKE</span> <span class="string">'%@c_'</span></span><br></pre></td></tr></table></figure>
<p>SQL 还定义了一些字符串操作的函数既可以用来输出结果也能用来作为条件，部分例子如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 取长度为5的子串</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTRING</span>(<span class="keyword">name</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="keyword">AS</span> abbrv_name</span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">sid</span> = <span class="number">53688</span></span><br><span class="line"></span><br><span class="line">// 转大写</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">UPPER</span>(s.name) <span class="keyword">LIKE</span> <span class="string">'KAN%'</span></span><br></pre></td></tr></table></figure>
<p>SQL标准里面规定可以用 <code>&#39;||&#39;</code> 来链接两个或多个字符串，其他不同DBMS也有不同的操作符/函数支持：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// SQL-92</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line">    <span class="keyword">WHERE</span> login = <span class="keyword">LOWER</span>(<span class="keyword">name</span>) || <span class="string">'@cs'</span></span><br><span class="line"></span><br><span class="line">// MSSQL</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line">    <span class="keyword">WHERE</span> login = <span class="keyword">LOWER</span>(<span class="keyword">name</span>) + <span class="string">'@cs'</span></span><br><span class="line"></span><br><span class="line">// mySQL</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line">    <span class="keyword">WHERE</span> login = <span class="keyword">CONCAT</span>(<span class="keyword">LOWER</span>(<span class="keyword">name</span>), <span class="string">'@cs'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="DATA-TIME-时间-日期操作"><a href="#DATA-TIME-时间-日期操作" class="headerlink" title="DATA/TIME 时间/日期操作"></a>DATA/TIME 时间/日期操作</h4><p>这一部分主要包括了SQL规定的一些关于操作和修改日期/时间的操作，可以作为输出或中间参数。同样，这些操作可能在不同DBMS上有不同的支持程度和具体语法，下面举一部分例子。</p>
<p>不同的DBMS有不同的方法获取获取当前日期，比如函数：<code>NOW()</code>、<code>CURRENT_TIMESTAMP()</code>，或者关键字<code>CURRENT_TIMESTAMP</code>;</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/time.png" class="" title="CMU-DB-2-Advanced-SQL">
<p>也可以可以通过 <code>EXTRACT</code> 或者 <code>&#39;-&#39;</code> 或者 <code>DATEDIFF</code> 等等各种方法来获取日期信息（同样根据不同DBMS有不同语法）</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/time_difference.png" class="" title="CMU-DB-2-Advanced-SQL">
<h3 id="Output-Control-Redirection"><a href="#Output-Control-Redirection" class="headerlink" title="Output Control + Redirection"></a>Output Control + Redirection</h3><h4 id="Output-redirection-输出重定向"><a href="#Output-redirection-输出重定向" class="headerlink" title="Output redirection 输出重定向"></a>Output redirection 输出重定向</h4><p>SQL 支持将输出保存到另一个表格里面，这个操作需要满足两个条件：</p>
<ul>
<li>输出表格不能已经被定义</li>
<li>输出表格需要和输入表格有相同类型并且列数相同</li>
</ul>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// SQL-02</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cid <span class="keyword">INTO</span> CourseIds</span><br><span class="line">    <span class="keyword">From</span> enrolled;</span><br><span class="line"></span><br><span class="line">// mySQL</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> CourseIDs (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cid <span class="keyword">FROM</span> enrolled</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>同时也支持通过 <code>INSECT</code> 关键字将 <code>SELECT</code> 输出的 tuple 插入到已经存在的表格里：</p>
<ul>
<li>内部的 <code>SELECT</code> 必须输出和目标表格相同列数的 tuple</li>
<li>不同 BDMS 对两者重复项有不同的处理选项和语法</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> CourseIds</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cid <span class="keyword">FROM</span> enrolled)</span><br></pre></td></tr></table></figure>
<h4 id="Output-Control"><a href="#Output-Control" class="headerlink" title="Output Control"></a>Output Control</h4><p>SQL 支持用 <code>ORDER</code> 关键字根据 tuple 中的一列或多列的值进行排序，语法是</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/SORT.png" class="" title="CMU-DB-2-Advanced-SQL">
<p>我们还可以用 <code>LIMIT</code> 来限制输出 tuples 的数量，并用 OFFSET 来规定一个输出范围</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// LIMIT &lt;count&gt; [OFFSET]</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line">    <span class="keyword">WHERE</span> login <span class="keyword">LIKE</span> <span class="string">'%@cs'</span></span><br><span class="line">    <span class="keyword">LIMIT</span> <span class="number">20</span> <span class="keyword">OFFSET</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="Nested-Queries-嵌套查找"><a href="#Nested-Queries-嵌套查找" class="headerlink" title="Nested Queries 嵌套查找"></a>Nested Queries 嵌套查找</h3><p>这里指的是查找指令中包括另一个查找指令，这种情况通常很难优化，但是会出现在各种地方，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 这里第一个出现的sid是关联在student上的，第二个是关联在enrolled上的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span></span><br><span class="line">    <span class="keyword">sid</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> enrolled)</span><br></pre></td></tr></table></figure>
<p>如果有多个查找命令时，可以用以下几种方式指定输出的结果</p>
<ul>
<li><code>ALL</code>：输出的 tuple 需要满足所有查找命令</li>
<li><code>ANY</code>：输出的 tuple 需要满足至少一个查找命令</li>
<li><code>IN</code>：和<code>ANY</code>等效</li>
<li><code>EXISTS</code>：至少返回一行</li>
</ul>
<p>例子</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 获得上这门课的学生的姓名</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">sid</span> = <span class="keyword">ANY</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> enrolled</span><br><span class="line">        <span class="keyword">WHERE</span> cid = <span class="string">'15-445'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">// ver2：查找命令也可以放在另一个查找命令的输出语句里</span><br><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> S.name <span class="keyword">FROM</span> student <span class="keyword">AS</span> S</span><br><span class="line">        <span class="keyword">WHERE</span> S.sid = E.SID) <span class="keyword">AS</span> sname</span><br><span class="line"><span class="keyword">FROM</span> enrolled <span class="keyword">AS</span> E</span><br><span class="line"><span class="keyword">WHERE</span> cid = <span class="string">'15-445'</span></span><br></pre></td></tr></table></figure>
<p>如果想要获得一个比较复杂的结果，比如找到一个学生，他至少注册了一门课，并且在这里面id是最高的，我们可能想到用以下方法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 不合标准！s.name 需要出现在HAVING里，否则结果未定义</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(e.sid), s.name</span><br><span class="line">    <span class="keyword">FROM</span> enrolled <span class="keyword">AS</span> e, student <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> e.sid = s.sid</span><br></pre></td></tr></table></figure>
<p>这个时候我们可以用到<code>ALL</code>关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// sid 需要满足两个<span class="keyword">SELECT</span>里面所有的表达式</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span> =&gt; <span class="keyword">ALL</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> enrolled</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// ver2: 也可以用<span class="keyword">IN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">sid</span>) <span class="keyword">FROM</span> enrolled</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// ver3: 通过排序+规定范围输出</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> enrolled</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">sid</span> <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>假设我们需要找到所有没人注册的课程，可以用<code>NOT EXIST</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 内部的参数也可以用到外部查找命令的表格</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> course</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> enrolled</span><br><span class="line">    <span class="keyword">WHERE</span> course.cid = enrolled.cid</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Window-Functions-窗口函数"><a href="#Window-Functions-窗口函数" class="headerlink" title="Window Functions 窗口函数"></a>Window Functions 窗口函数</h3><p>窗口函数指的是对一系列 tuples 关于单行进行计算，和聚合函数类似，但是最后tuple不会集中在一个tuple上，语法是</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// FUNC-NAME 可以是聚合函数或者别的特殊函数</span><br><span class="line">// OVER 内部可以定义怎么切分数据或者对数据排序</span><br><span class="line"><span class="keyword">SELECT</span> ... FUNC-<span class="keyword">NAME</span>(...) <span class="keyword">OVER</span> (...)</span><br><span class="line">    <span class="keyword">FROM</span> tableNAME</span><br></pre></td></tr></table></figure>
<p>上述的聚合函数可以包括之前提到的所有函数，特殊函数则是指：</p>
<ul>
<li><code>ROW_NUMBER()</code>  当前行的行号</li>
<li><code>RANK()</code> 当前行的排序位置</li>
</ul>
<p><code>OVER()</code>的内部可以用<code>PARTITION BY</code>来指定特定的组，如：</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/over_partition.png" class="" title="CMU-DB-2-Advanced-SQL">
<p>假如我们想找到每门课上拿最高分的学生，可以：</p>
<img src="/2020/04/20/CMU-DB-2-Advanced-SQL/rank.png" class="" title="CMU-DB-2-Advanced-SQL">
<h3 id="Common-Table-Expressions-常见的表格表达式"><a href="#Common-Table-Expressions-常见的表格表达式" class="headerlink" title="Common Table Expressions 常见的表格表达式"></a>Common Table Expressions 常见的表格表达式</h3><p>除了用嵌套查找以外还能用一些常见表达式来进行查找，可以看成一个临时的表格，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">with</span> 产生了一个tuple里面只有一个值<span class="number">1</span></span><br><span class="line"><span class="keyword">WITH</span> cteName <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> cteName</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WITH</span> cteName (col1, col2) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> col1 + col2 <span class="keyword">FROM</span> cteName</span><br><span class="line"></span><br><span class="line">// 之前提到的例子，找到一个学生，他至少注册了一门课，并且在这里面<span class="keyword">id</span>是最高的</span><br><span class="line"><span class="keyword">WITH</span> cteSource (maxId) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">sid</span>) <span class="keyword">FROM</span> enrolled</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student, cteSource</span><br><span class="line"><span class="keyword">WHERE</span> student.sid = cteSource.maxId</span><br><span class="line"></span><br><span class="line">// recursion，打印<span class="number">1</span>到<span class="number">10</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cteSource (counter) <span class="keyword">AS</span> (</span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    (<span class="keyword">SELECT</span> counter + <span class="number">1</span> <span class="keyword">FROM</span> cteSource</span><br><span class="line">    <span class="keyword">WHERE</span> counter &lt; <span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> cteSource</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>[CMU-15-445/645] - 介绍</title>
    <url>/2020/04/20/CMU-DB-1/</url>
    <content><![CDATA[<p>今天开始学习<a href="https://15445.courses.cs.cmu.edu/fall2019/" target="_blank" rel="noopener">Databases Systems CMU 15-445/645/ Fall 2019</a>，课程比较硬核，重点主要集中在怎么样设计一个数据库系统，希望能坚持学完。第一课主要是课程介绍以及介绍一些关于数据库管理系统的基础概念，包括关系模型，以及关于retional algebra 关系代数的一些基本操作。</p>
<a id="more"></a>
<h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><ol>
<li><p>课程主要集中在以下几个方面：</p>
<ul>
<li>Relational Databases</li>
<li>Storage</li>
<li>Execution</li>
<li>Concurrency Control</li>
<li>Recovery</li>
<li>Distributed Databases</li>
<li>Potpourri (集合)</li>
</ul>
</li>
<li><p>教材</p>
<p> 主要参考 <a href="https://www.db-book.com/db7/index.html" target="_blank" rel="noopener">Database System Concepts (第七版)</a> 以及课程笔记。</p>
</li>
<li><p>Project</p>
<p> 本课将会从零开始实现一个存储管理器，用的语言是C++17。项目将基于一个教学用数据库管理系统<a href="https://github.com/cmu-db/bustub" target="_blank" rel="noopener">BusTub</a>，该系统的大致架构为：</p>
<ul>
<li>Disk-Oriented Storage</li>
<li>Volcano-style Query Processing</li>
<li>Pluggable APIs</li>
<li><em>Currently does not support SQL</em></li>
</ul>
</li>
</ol>
<h2 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设我们现在需要一个音乐商店（类似iTunes）来管理所有的歌手和专辑，那么我们需要存储的信息包括：<strong>歌手信息</strong>和<strong>歌手发布的专辑信息</strong>。最简单的思路是将数据库以CSV文件的方式来存储，具体实现方式可以是这样：</p>
<ul>
<li>用一个单独的文件来存储每个我们需要的信息（在这个例子里面就是歌手信息和专辑信息）</li>
<li><p>每次应用想读取信息可以通过解析这些文件来获取</p>
  <img src="/2020/04/20/CMU-DB-1/%E9%9F%B3%E4%B9%90%E5%95%86%E5%BA%97%E4%BE%8B%E5%AD%90.png" class="" title="CMU-DB-1">
</li>
</ul>
<p>当我们想找Ice Cube的信息的时候，我们可以通过下面的Python来实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">    record = parse(line)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">"Ice Cube"</span> == record[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">print</span> int(record[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>但是这种简单的实现方式会遇到很多问题：</p>
<ul>
<li>怎么保证在每个专辑项的时候都保证歌手名字格式是一致的？</li>
<li>假如某个人不小心在输入年份的时候输入了一个不合法的string导致没办法转成整数怎么办？</li>
<li>当一个专辑有多个创作者是怎么办？</li>
</ul>
<p>除此之外还有很多实现上的细节需要注意：</p>
<ul>
<li>怎么找到一条特定记录？通过上面的for-loop方法在数据量很大的时候效率会变得很低</li>
<li>怎么保证这样的数据库系统可以兼容多平台（手机、平板、电脑）或者多种编程语言？</li>
<li>当两个线程想同时向一个文件写入时怎么保证不会互相覆盖？</li>
</ul>
<p>另外还考虑数据库的安全问题：</p>
<ul>
<li>当程序在往数据库写入记录的时候数据库突然崩溃了怎么办？</li>
<li>如果我们向复制数据库在多台机器以保证高可用性的时候需要注意什么？</li>
</ul>
<p>基于上面提到的问题，我们需要实现一个通用的数据库管理系统(Database Management System)来对数据库进行信息的<strong>存储</strong>和<strong>分析</strong>，这个系统需要能做到允许用户<em>自定义</em>，<em>创建</em>，<em>写入查找</em>，<em>更新</em>，<em>管理</em>一个数据库</p>
<h3 id="数据库系统模型介绍"><a href="#数据库系统模型介绍" class="headerlink" title="数据库系统模型介绍"></a>数据库系统模型介绍</h3><ol>
<li><p>Relational Model (关系模型)</p>
<p> 早期的数据库系统很难构建和维护，用户在构建系统之前需要清楚知道以后他会怎么使用，软件使用和硬件实现方式耦合度很高，直到1970 年 Ted Codd 提出了一个数据库的抽象概念来避免这种情况，这个模型主要包括以下三个要点：</p>
<ul>
<li>将数据库以关系 (relation) 的方式存在一个简单的数据结构里面</li>
<li>数据将会通过高级语言来进行访问</li>
<li>物理存储方式留给第三方具体实现（抽象本身不包括实现方式，用户不需要自己实现）</li>
</ul>
</li>
<li><p>Data models &amp; Schema</p>
<p> 这里提出了两个概念：</p>
<ul>
<li>data model：有关怎么描述数据在数据库里面里面的一系列描述方式</li>
<li><p>schema：针对一种特定数据模型给出的对该类型数据的描述方式（这一部分其实不太清楚，看看后续有没有具体的例子）</p>
<p>总的来说，数据模型抽象的概括了我们怎么样存储数据，schema则是说明了具体存了哪些内容</p>
</li>
</ul>
</li>
<li><p>一些常见的data model</p>
<ul>
<li>Relational：绝大部分的DBMS都是用这个模型，这门课也是学习这种模型</li>
<li>Key/Value：这个包括下面直到Column-family都是属于NoSql的模型</li>
<li>Graph</li>
<li>Document</li>
<li>Column-family</li>
<li>Array/Matrix：机器学习里面常用这种模型</li>
<li>Hierarchical：最后两种比较少见</li>
<li>Network</li>
</ul>
</li>
<li><p>Relational Model</p>
<p> Relational Model主要包括以下三个要素：</p>
<ul>
<li>Structure(结构)：有关关系和他们的具体内容的定义（描述）</li>
<li>Integrity（完整性）：保证数据库的内容符合相关约束条件（给定一个数据库怎么判断他是不是符合标准）</li>
<li>Manipulation（操作）：怎么访问和更改数据库的内容</li>
</ul>
</li>
</ol>
<h4 id="音乐商店例子：数据库描述"><a href="#音乐商店例子：数据库描述" class="headerlink" title="音乐商店例子：数据库描述"></a>音乐商店例子：数据库描述</h4><p>根据这三个要素，再回头看最初提到的音乐商店的例子：</p>
<img src="/2020/04/20/CMU-DB-1/%E4%BE%8B%E5%AD%90.png" class="" title="CMU-DB-1">
<p>在这个例子里面，<strong>relation(关系)</strong>指的就是所有描述一个记录的无序集合 (unordered set)，这里每一行表示了一个艺术家的记录，包括了姓名，年份和国家；其中一个特定的记录（record）被称为<strong>tuple（元组）</strong>，它包括了该记录所有的参数（value），一般来说每个参数都是不能再细分的（数、字符串等等，不能是数据，向量），null参数是任何tuple的成员之一。在这个例子里我们可以说<em>n-ary Relation = Table with n columns</em>，一个n维的relation可以用一个n列的表格来表示。</p>
<p>在一个relation中我们可以用<strong>primary key（主键）</strong>来特定的标识出某个tuple，某一些DBMS会在你没有定义定义primary key的时候自动创建一个内部primary key，例如SQL:2003会产生一个序列、MySQL会自动递增一个序号，这时表格可能会下图这样子的，需要注意的是，这个id不代表记录的任何属性，只是我们用来标识出他的一个记号，这个记号也有可能不会显式地显示出来</p>
<img src="/2020/04/20/CMU-DB-1/%E5%B8%A6%E4%B8%BB%E9%94%AE%E7%9A%84%E4%BE%8B%E5%AD%90.png" class="" title="CMU-DB-1">
<p>除此之外，我们还需要有个机制来联系两个relation，所以还引入了一个<strong>foreign key（外键）</strong>，这个键主要用来在一个tuple里面通过他来联系到另一个relation里面的另一个tuple，在这个例子指的就是艺术家和专辑之间的联系，如下图：</p>
<img src="/2020/04/20/CMU-DB-1/%E5%A4%96%E9%94%AE%E4%BE%8B%E5%AD%901.png" class="" title="CMU-DB-1">
<p>但是这里可以发现一个问题，但专辑不止有一个艺术家的时候怎么办？前面提到了每一个value必须是不可再分的，所以不能用一个数组来保存，这个时候我们可以用第三个relation来描述这两个relation之间的联系，这个relation里面每一个tuple只需要包含两个value：艺术家的id和专辑的id，如下图所示：</p>
<img src="/2020/04/20/CMU-DB-1/%E5%A4%96%E9%94%AE%E4%BE%8B%E5%AD%902.png" class="" title="CMU-DB-1">
<h4 id="音乐商店例子：数据库操作"><a href="#音乐商店例子：数据库操作" class="headerlink" title="音乐商店例子：数据库操作"></a>音乐商店例子：数据库操作</h4><p>在确认了怎么表示一个数据库之后我们需要来操作它，这里我们主要关心把一个信息存进数据库和把它提取出来，这里主要两种方式：</p>
<ul>
<li>Procedural：每次查询制定好一个策略（不是具体的实现）用来给DBMS来执行查找</li>
<li>Non-Procedural：查询操作不指定具体查找方法</li>
</ul>
<p>这两种方式的具体应用分别是<strong>Relational Algebra（关系代数）</strong>和<strong>Relational Calculus（关系演算）</strong>，这门课里面我们主要关注第一种查找方式。</p>
<p>Relational Algebra里面基于集合（没有重复元素）的运算法则规定了七种基本运算来获取和操作一个relation里面的tuple，其中每一个操作的输入是一个或多个relation，输出是一个新的reltaion：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\sigma$</td>
<td style="text-align:center">Select</td>
</tr>
<tr>
<td style="text-align:center">$\pi$</td>
<td style="text-align:center">Projection</td>
</tr>
<tr>
<td style="text-align:center">$\cup$</td>
<td style="text-align:center">Union</td>
</tr>
<tr>
<td style="text-align:center">$\cap$</td>
<td style="text-align:center">Intersection</td>
</tr>
<tr>
<td style="text-align:center">$-$</td>
<td style="text-align:center">Difference</td>
</tr>
<tr>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">Product</td>
</tr>
<tr>
<td style="text-align:center">$\Join$</td>
<td style="text-align:center">Join</td>
</tr>
</tbody>
</table>
</div>
<p>下面对每一个操作进行介绍：</p>
<h5 id="Select（选择）"><a href="#Select（选择）" class="headerlink" title="Select（选择）"></a>Select（选择）</h5><p>选择操作是从一个relation里面选出一个tuple的子集满足给定的选择条件，作用和一个filter类似，具体语法是$\sigma_{predicate}(R)$，可以看看下面的例子,对同一个relation用不同的条件可以输出不同的结果（也是一个relation），这个操作对应SQL里面WHERE语句：</p>
<img src="/2020/04/20/CMU-DB-1/select.png" class="" title="CMU-DB-1">
<h5 id="Projection（投影）"><a href="#Projection（投影）" class="headerlink" title="Projection（投影）"></a>Projection（投影）</h5><p>给定一个relation，投影操作可以输出一个只包括tuple里面的特定参数(attributes)新的relation，通过这个操作可以重新安排参数的顺序，也可以对所有tuple的某个参数进行统一的修改，效果和对应的SQL语句如下图所示，具体的语法是$\pi_{A1,A2,…,An}(R)$:</p>
<img src="/2020/04/20/CMU-DB-1/projection.png" class="" title="CMU-DB-1">
<h5 id="Union（并集）"><a href="#Union（并集）" class="headerlink" title="Union（并集）"></a>Union（并集）</h5><p>联合操作比较简单，就是把两个relation合成一个新的relation，语法是$R\cup S$，效果如下所示，值得注意的是这个操作的两个输入relation需要有完全一样顺序的参数，否则不会匹配（另外这个例子里面好像不会去重？？）</p>
<img src="/2020/04/20/CMU-DB-1/union.png" class="" title="CMU-DB-1">
<h5 id="Intersection（交集）"><a href="#Intersection（交集）" class="headerlink" title="Intersection（交集）"></a>Intersection（交集）</h5><p>对两个relation取共同部分，同样需要两个relation有完全一样的参数和顺序，语法是$R\cap S$：</p>
<img src="/2020/04/20/CMU-DB-1/Intersection.png" class="" title="CMU-DB-1">
<h5 id="Difference（差集）"><a href="#Difference（差集）" class="headerlink" title="Difference（差集）"></a>Difference（差集）</h5><p>差集的输入是两个relation，输出所有在第一个relation出现过但没有在第二个relation出现的tuple组成的relation，语法是$R-S$</p>
<img src="/2020/04/20/CMU-DB-1/difference.png" class="" title="CMU-DB-1">
<h5 id="Product-叉乘"><a href="#Product-叉乘" class="headerlink" title="Product (叉乘)"></a>Product (叉乘)</h5><p>叉乘取两个relation作为输入，输出两个relation中各自所有tuple的排列组合产生的tuple并组成新的relation，语法是$R\times S$，类似SQL的cross join，效果如下</p>
<img src="/2020/04/20/CMU-DB-1/product.png" class="" title="CMU-DB-1">
<h5 id="Join-（联合）"><a href="#Join-（联合）" class="headerlink" title="Join （联合）"></a>Join （联合）</h5><p>Join取两个relation并输出一个新的relation，其中的tuple是这两个relation都包含的一部分（可能有共同的一个或多个参数），语法是$R\Join S$，类似SQL的NATURAL JOIN</p>
<img src="/2020/04/20/CMU-DB-1/join.png" class="" title="CMU-DB-1">
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>除了七种基本操作以外，relational algebra还有一些额外的操作，例如：Rename - $\rho$, Assignment - $R\leftarrow S$, Duplicate Elimination - $\delta$, Aggregation $\gamma$, sorting - $\tau$, Division - $R \div S$</p>
<p>相对于最初提到具体的某个具体的实现（for-loop），用relational algebra来实现某个查找相对来说虽然抽象程度更高，但是同一个查找可能不同的algebra实现方式可能效率不同，比如$\sigma_{b_{id}=102(R\Join S)} vs. (R\Join(\sigma_{b_{id}=102}(S)))$。对用户而言他在执行某个查找的时候只需要提出这样一个要求，来避免具体的实现细节（针对不同的数据库可能不同的执行顺序效率不同）：</p>
<ul>
<li>Retrieve the joined tuples from R and S where b_id equals 102.</li>
</ul>
<p>值得注意的是，虽然现在SQL已经是事实上的标准，relational model独立于任何一种特定的查询语言，用这种模型的好处是不需要去了解特定的实现细节（比如要不要用for循环去查找等等），而其中关系代数定义了关系数据库里面最基本的操作。</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]分布式系统-distributed system</title>
    <url>/2020/04/19/distributed-system/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了分布式系统中最基础的一些概念的方法。</p>
<a id="more"></a>
<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ol>
<li><p>What is a distributed system?</p>
<p> <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/distributed_system.png" width="300"></p>
<ul>
<li>Cooperating processes in a computer network</li>
<li><p>Degree of integration</p>
<ul>
<li>Loose: Internet applications, email, web browsing</li>
<li>Medium: remote execution, remote file systems</li>
<li>Tight: process migration, distributed file systems</li>
</ul>
</li>
<li><p>Advantage</p>
<ul>
<li>Speed: parallelism, less contention</li>
<li>Reliability: redundancy, fault tolerance, “NSPF”</li>
<li>Scalability: incremental growth, economy of scale</li>
<li>Geographic distribution: low latency, reliability</li>
</ul>
</li>
<li><p>Disadvantages</p>
<ul>
<li><p><em>Fundamental problems</em> of decentralized control</p>
<ul>
<li>State uncertainty: no shared memory or clock</li>
<li>Action uncertainty: matually conflicting decisions</li>
</ul>
</li>
<li><p>Distributed algorithms are complex</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Is distribution better? <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/distributed_system2.png" width="180" style="float: right;"></p>
<ul>
<li>Single fast server with single queue</li>
<li><p>Multiple slower servers with separate queues</p>
<ul>
<li>Typically better than the first one</li>
</ul>
</li>
<li><p>Multiple slower servers, single queue</p>
<ul>
<li>Better than the first two</li>
</ul>
</li>
<li><p>Little’s Law: $N = \lambda W$</p>
<ul>
<li>Use to calculate processing time (assuming stable)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Models-used-in-cooperating-system"><a href="#Models-used-in-cooperating-system" class="headerlink" title="Models used in cooperating system"></a>Models used in cooperating system</h2><ol>
<li><p>The Client/Server Model</p>
<ul>
<li><p>Client</p>
<ul>
<li>Short-lived process that makes requests</li>
<li>“User-side” of application</li>
</ul>
</li>
<li><p>Server</p>
<ul>
<li>Exports well-defined requests/response interface</li>
<li>Long-lived process that waits for requests</li>
<li>Upon receiving request, carries it out (may spawn)</li>
</ul>
</li>
</ul>
</li>
<li><p>Peer-to-Peer</p>
<ul>
<li><p>A peer talks directly with another peer</p>
<ul>
<li>No intermediary (e.g., central servel) involved</li>
<li>Symmetric (unlike asymmetric client/server)</li>
</ul>
</li>
<li><p><em>In actuality, may be dynamic client/server</em></p>
<ul>
<li>A requests file from B; A acts as client, B as server</li>
<li>C can now request file from A; A acts as server</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Distributed-Algorithms"><a href="#Distributed-Algorithms" class="headerlink" title="Distributed Algorithms"></a>Distributed Algorithms</h3><ol>
<li><p>Event ordering</p>
<ul>
<li>Order events given no shared clock/memory</li>
<li><p>Happened-before relations: $\rightarrow$</p>
<ul>
<li>A, B events in same process and A before B: $A\rightarrow B$</li>
<li>A is a send event, B is a receive event: $A\rightarrow B$</li>
<li>If $A\rightarrow B$ and $B\rightarrow C$, then $A\rightarrow C$</li>
</ul>
</li>
<li><p>Implementation</p>
<ul>
<li>Timestamp all events based on local clock</li>
<li>Upon receiving a message, advance local clock</li>
<li>Resolve ties by ordering machines</li>
</ul>
</li>
<li><p>Example</p>
<ul>
<li><p>Example 1 (When timing conflicting, follow rules above):</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/event_ordering_example3.png" width="300"></p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/event_ordering_example1.png" width="300"></p>
</li>
<li><p>Example 2:</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/event_ordering_example4.png" width="300"></p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/event_ordering_example5.png" width="300"></p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/event_ordering_example2.png" width="300"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Leader election</p>
<ul>
<li>Many distributed algorithms rely on leader</li>
<li>Need to determine if leader exists; if not elect</li>
<li><p>Bully algorithm (elect leader L)</p>
<ul>
<li>Every process is numbered (priority): P1, P2, …</li>
<li>$P_j$ sends request to L, no reply; tries to elect itself</li>
<li>$P_j$ sends “Can I be leader?” to all $P_{k&gt;j}$</li>
<li>No replies, $P_j$ sends to all $P_{i&lt;j}$, “I am leader”, done</li>
<li>If some $P_{k&gt;j}$ replies, $P_j$ let $P_k$ try to elect itself</li>
<li>If no message from $P_k$, $P_j$ tries to elect itself again</li>
</ul>
</li>
</ul>
</li>
<li><p>Mutual exclusion</p>
<ul>
<li><p>Centralized approach</p>
<ul>
<li>Single process acts as coordinator server</li>
<li>Request, reply (to allow entrance), release</li>
</ul>
</li>
<li><p>Distributed approach</p>
<ul>
<li>Process sends time-stamped request to all others</li>
<li>Waits until it receives replies from all (ok to other)</li>
<li>Enter critical section (may get requests, defers)</li>
<li>Upon exiting, responds (to release) to all deferred</li>
<li>Use timestamps to order “simultaneous” requests</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]网络-networks</title>
    <url>/2020/04/19/networks/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了网络的概念，包括网络的类型和协议的概念。并且简单介绍了一下OSI7层模型，包括addressing和routing的过程。</p>
<a id="more"></a>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><ol>
<li><p>What is a Network?</p>
<ul>
<li><p>Network</p>
<ul>
<li>Set of computing nodes</li>
<li>Connected by communication links</li>
<li>Allow data transfer by a sender to a receiver</li>
</ul>
</li>
<li><p>Internetwork: a network of networks</p>
<ul>
<li>The “Internet” is a global internetwork</li>
<li>Nodes communicate using IP (Internet Protocol)</li>
</ul>
</li>
</ul>
</li>
<li><p>Types of Networks</p>
<ul>
<li><p>By topology: ring, star, bus, graph</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/type_of_network.png" width="280"></p>
</li>
<li><p>By geographic coverage</p>
<ul>
<li>LAN: local area network (spanning floor, building)</li>
<li>WAN: wide area network (spanning state, country)</li>
</ul>
</li>
</ul>
</li>
<li><p>Circuit-switch vs. Packet switching</p>
<ul>
<li><p>Circuit switching: establish path, send data</p>
<ul>
<li>Reserve resources provide performance control</li>
<li><p>Example: telephone system</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/circuit_switching.png" width="280"></p>
</li>
</ul>
</li>
<li><p>Packet switching: forward packets hop to hop</p>
<ul>
<li>Fair sharing despite burst, statistical multiplexing</li>
<li><p>Example: postal system</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/packet_switching.png" width="280"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><ol>
<li><p>What is protocol?</p>
<ul>
<li>Goal: get message from sender to receiver</li>
<li><p>Protocol</p>
<ul>
<li>agreed message format and transfer procedure</li>
</ul>
</li>
<li><p>Multiparty, so no central thread of control</p>
<ul>
<li>Sender and reciver are separate processes</li>
</ul>
</li>
<li><p>Expectations of operation</p>
<ul>
<li>first you do x, then I do y, then you do z,…</li>
<li>If you do q, I’ll do p</li>
</ul>
</li>
</ul>
</li>
<li><p>Message</p>
<ul>
<li><p>Message: contains header and data</p>
<ul>
<li>Similar terms: packet, datagram, frame</li>
</ul>
</li>
<li><p>Data: what sender wants to receiver to know</p>
</li>
<li><p>Header: information to support protocol</p>
<ul>
<li>Source and destination addresses</li>
<li>State of protocol operation</li>
<li>Error control (to check intergity of received data)</li>
</ul>
</li>
<li><p>Example:</p>
<ul>
<li><p>Assume: Ann sends message to Bob locally (same city)</p>
<ul>
<li>Message format: (from, to), message contents</li>
<li><p>Transfer procedure: post on refrigerator</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/message1.png" width="280"></p>
</li>
</ul>
</li>
<li><p>What if Ann sends message to Bob in different cities</p>
<ul>
<li>Message format: address(es) on envelope, letter</li>
<li><p>Transfer procedure: postal system</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/message2.png" width="280"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Summary (<em>Layering: Separation of Functions</em>)</p>
<ul>
<li><p>Ann and Bob</p>
<ul>
<li>Don’t have to know about delivery</li>
<li>However, aid postal system by providing addresses</li>
</ul>
</li>
<li><p>Postal System</p>
<ul>
<li>Only has to know addresses and how to deliver</li>
<li>Doesn’t care about “data”: Ann, Bob, letter</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="7-Layers-of-OSI-Open-Systems-Interconnection-Refernce-Model"><a href="#7-Layers-of-OSI-Open-Systems-Interconnection-Refernce-Model" class="headerlink" title="7 Layers of OSI (Open Systems Interconnection) Refernce Model"></a>7 Layers of OSI (Open Systems Interconnection) Refernce Model</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">layer</th>
<th style="text-align:left">name</th>
<th style="text-align:left">function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">Application</td>
<td style="text-align:left">application protocol, e.g., HTTP</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">Presentation</td>
<td style="text-align:left">syntax, network format</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">Session</td>
<td style="text-align:left">start/stop/manage connections</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">Transport</td>
<td style="text-align:left">segment, reliability, flow control</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">Network</td>
<td style="text-align:left">logical addressing, routing</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">Link</td>
<td style="text-align:left">physical addressing, framing</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Physical</td>
<td style="text-align:left">0’s and 1’s over a wire</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>Internet Protocol Stack</p>
<ul>
<li>“Hourglass” design</li>
<li>Application: Email, Web</li>
<li>Session: sockets</li>
<li>Transport: TCP, UDP, …</li>
<li>Network: IP (Only one kind of protocol in this layer, which makes Internet Internet!)</li>
<li>Link: Ethernet, ATM, …</li>
<li>Physical</li>
</ul>
</li>
<li><p>Encapsulation</p>
<ul>
<li>Higher level n with lower level n - 1</li>
<li>Can also have level within a level: tunneling</li>
<li>Multiplexing and de-multiplexing</li>
</ul>
</li>
<li><p>Addresses</p>
<ul>
<li><p>Generally, three levels of addresses</p>
<ul>
<li>Domain names: cs.ucsd.edu</li>
<li>Logical addresses (IP): 128.53.27.92</li>
<li>Physical addresses (Ethernet): 0x27A5BB17019D</li>
</ul>
</li>
<li><p>Address resolution</p>
<ul>
<li>Mapping higher level name to lower level name</li>
<li>Techniques: table lookup, formula, protocol</li>
</ul>
</li>
<li><p>Sizes of address spaces</p>
<ul>
<li><p>IPv4 (version 4, current/past)</p>
<ul>
<li>32 bit addresses</li>
<li>$2^{32}$ = 4 billion addresses</li>
</ul>
</li>
<li><p>IPv6 (version 6, future/current)</p>
<ul>
<li>128 bit addresses</li>
<li>$2^{128} = 2^8\times (2^{10})^{12} = 256 \times (10^3)^{12} = 2.56 \times 10^{38}$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Routing</p>
<ul>
<li><p>Routing: how to get packet from A to B</p>
<ul>
<li><p>A forwards to X; X to Y; Y to Z; Z to B</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/routing_example.png" width="300"></p>
</li>
</ul>
</li>
<li><p>Each intermediate node can be a decision point</p>
<ul>
<li>Static: always make the same decision</li>
<li>Dynamic: decision can change (e.g., based on state)</li>
</ul>
</li>
</ul>
</li>
<li><p>Scalability</p>
<ul>
<li><p>How well does system grow</p>
<ul>
<li>in terms of performance, reliability, etc</li>
</ul>
</li>
<li><p>Ramifications of adding node or link</p>
<ul>
<li>Local effects vs. global effects</li>
</ul>
</li>
<li><p>Information growth: import to reduce</p>
<ul>
<li>Amount stored at nodes</li>
<li>Amount exchanged between nodes</li>
</ul>
</li>
</ul>
</li>
<li><p>Error Control</p>
<ul>
<li>Parity: even, odd, two-dimesional</li>
<li>CRC (cyclic redundance code)</li>
<li>Checksum</li>
<li>Automatic repeat request (ARQ)</li>
</ul>
</li>
<li><p><a href="https://www.wikiwand.com/en/Two_Generals%27_Problem" target="_blank" rel="noopener">The two general’s problem</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]安全机制-security</title>
    <url>/2020/04/19/security/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面的不同环境以及系统之间的威胁，包括病毒等，除此之外还介绍了一些安全机制，包括公钥和私钥的方法。</p>
<a id="more"></a>
<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ol>
<li><p>What is Computer Security?</p>
<ul>
<li><p>How to protect computer systems</p>
<ul>
<li>System contents: data, software, hardware</li>
<li>System operation: performance, reliability</li>
<li>System service: what the user sees and expects</li>
</ul>
</li>
<li><p>From various threats</p>
<ul>
<li>Theft</li>
<li>Damage</li>
<li>Disruption</li>
</ul>
</li>
</ul>
</li>
<li><p>Aspects of Security</p>
<ul>
<li><p>Confidentiality</p>
<ul>
<li>keeping a secret secret; for authorized eyes only</li>
</ul>
</li>
<li><p>Integrity</p>
<ul>
<li>maintaining accuracy; only authorized changes</li>
</ul>
</li>
<li><p>Authenticity</p>
<ul>
<li>Is it really who/what it claims to be?</li>
</ul>
</li>
<li><p>Availablity</p>
<ul>
<li>access to info/resources you need, when needed</li>
</ul>
</li>
</ul>
</li>
<li><p>Security Threats</p>
<ul>
<li><p>Interception</p>
<ul>
<li>eavesdropping</li>
</ul>
</li>
<li><p>Interruption</p>
<ul>
<li>destroying, denial of service</li>
</ul>
</li>
<li><p>Modification</p>
<ul>
<li>tampering with data or programs</li>
</ul>
</li>
<li><p>Fabrication</p>
<ul>
<li>new data/programs, replaying message</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="User-Authentication"><a href="#User-Authentication" class="headerlink" title="User Authentication"></a>User Authentication</h2><ol>
<li><p>Password</p>
<ul>
<li><p>Passwords are most common method</p>
<ul>
<li>User and computer know secret</li>
<li>User proves knowledge of secret</li>
<li>Computer checks</li>
</ul>
</li>
<li><p>Encrypted passwords</p>
<ul>
<li>Computer stores only encrypted passwords</li>
<li>User provides password</li>
<li>Computer encrypts, checks</li>
</ul>
</li>
<li><p>Problem with passwords</p>
<ul>
<li><p>Assume 100 possible characters for passwords</p>
<p>  | # chars| # passwords | 100G/s machine | 100T/s machine |<br>  | :—-: | :—-: | :—-: | :—-: |<br>  | 6 | $100^6$ | 10 sec | 10 msec |<br>  | 7 | $100^7$ | 17 min | 10 msec |<br>  | 8 | $100^8$ | 1.2 days | 1.7min |<br>  | 9 | $100^9$ | 116 days | 2.8 hr|</p>
</li>
<li><p>But most characters are uncommon, hard to remember</p>
</li>
<li>Using dictionary words (~250,000): only 2.5 usec!</li>
</ul>
</li>
</ul>
</li>
<li><p>Challenge/Response Protocol</p>
<ul>
<li><p>Challenge/response, algorithm passwords</p>
<ul>
<li>User and system know secret algorithm</li>
<li>System challenge user’s knowledge, user responds</li>
</ul>
</li>
<li><p>Example: say secret algorithm is $f(x) = x^2$</p>
<ul>
<li>System challenges user: sends system 9</li>
<li>User computes $f(x) = 9$, sends system 9</li>
<li>System concludes user must know secret algorithm</li>
<li>Next time, system can provide different challenge</li>
</ul>
</li>
<li><p>Secret is never sent, only challenge/response</p>
</li>
</ul>
</li>
</ol>
<h2 id="Threats"><a href="#Threats" class="headerlink" title="Threats"></a>Threats</h2><ol>
<li><p>Trojan Horse</p>
<ul>
<li>Greeks invaded Troy in hollow wooden horse</li>
<li><p>Program that contains hidden malicious code</p>
<ul>
<li>User thinks program does something useful</li>
<li>In actuality, it (also) does something harmful</li>
</ul>
</li>
<li><p>Program runs as process in user’s domain</p>
<ul>
<li>Can do harm to user’s environment</li>
<li>Can do harm under that user’s name</li>
</ul>
</li>
</ul>
</li>
<li><p>Trap Door</p>
<ul>
<li>Secret access point in program</li>
<li>Designer develops program for someone else</li>
<li>Once loaded in system, designer can access</li>
<li><p>Consider if trap door is added by compiler</p>
<ul>
<li>Compiler adds trap doors to programs</li>
<li>Designer of compiler can then access</li>
<li>Can’t tell from program source code</li>
<li>Even if new compiler written, must be compiled!</li>
</ul>
</li>
</ul>
</li>
<li><p>Virus</p>
<ul>
<li>Code attached to legitimate program</li>
<li><p>When program runs, the virus runs</p>
<ul>
<li>causes damage</li>
<li>spreads, attaching itself to other programs</li>
</ul>
</li>
<li><p>Disinfectants</p>
<ul>
<li>Check that programs look normal (modified)</li>
<li>Check for known virus patterns in programs</li>
</ul>
</li>
</ul>
</li>
<li><p>Internet Worm</p>
<ul>
<li>Worm: program that copies itself over network by email, finger, rsh attack</li>
</ul>
</li>
<li><p>Denial of Service</p>
<ul>
<li><p>Preventing others from using system</p>
<ul>
<li>by using lots of resources</li>
<li>by bombarding with network requests or traffic</li>
</ul>
</li>
<li><p>Example</p>
<ul>
<li>Repeatly request TCP connection</li>
<li>Don’t answer responses; system times them out</li>
<li>Eventually, no TCP ports left available</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Approach-to-clear-prevent-threats"><a href="#Approach-to-clear-prevent-threats" class="headerlink" title="Approach to clear (prevent) threats"></a>Approach to clear (prevent) threats</h2><h3 id="Intrusion-Detection"><a href="#Intrusion-Detection" class="headerlink" title="Intrusion Detection"></a>Intrusion Detection</h3><ol>
<li><p>Intrusion Detection</p>
<ul>
<li>Detecting if there is an intruder, or an attack</li>
<li><p>Signature-based</p>
<ul>
<li>Look for specific patterns of attack behavior</li>
<li>Example: repeated login attempts</li>
</ul>
</li>
<li><p>Anomaly-based</p>
<ul>
<li>Look for unusual behavior</li>
<li>Example: unusual command/system call patterns</li>
</ul>
</li>
<li><p>Solution: create audit trail (log), then analyze it</p>
</li>
</ul>
</li>
</ol>
<h3 id="Crytography"><a href="#Crytography" class="headerlink" title="Crytography"></a>Crytography</h3><ol>
<li><p>Basics</p>
<ul>
<li><p>Encoding messages to</p>
<ul>
<li>limit who can view the original message</li>
<li><p>determine who sent a message</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/crytography.png" width="350"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Secret Key Encryption</p>
<ul>
<li><p>Secret key (symmetric)</p>
<ul>
<li>Same key K is used to encrypt and decrypt</li>
<li>Sender encrypts $E_k(P)$, Receiver decrypts $D_k(E_k(P))$</li>
</ul>
</li>
<li><p>DES: Data Encryption Standard (1997)</p>
<ul>
<li>Weak due to 56-bit keys</li>
</ul>
</li>
<li><p>AES: Advanced Encryption Standard (2001)</p>
<ul>
<li>128, 192, 256-bit keys</li>
</ul>
</li>
</ul>
</li>
<li><p>Public Key Encryption</p>
<ul>
<li><p>Public key (asymetric)</p>
<ul>
<li>Different keys to encrpyt and decrypt</li>
<li>Each user has two keys: one public, one private</li>
</ul>
</li>
<li><p>If A wants to send to B</p>
<ul>
<li>A encrypts using B’s public key</li>
<li>B decrypts using its private key</li>
</ul>
</li>
<li><p>RSA (Rivest, Shamir and Adelman)</p>
</li>
</ul>
</li>
<li><p>Public key vs. Secret key</p>
<ul>
<li><p>Secret key</p>
<ul>
<li>Operates fast</li>
<li>Difficult to distribute keys</li>
</ul>
</li>
<li><p>Public key</p>
<ul>
<li>Time-consuming operation (generating random/prime number, see example below)</li>
<li>Conveninet for key distribution</li>
</ul>
</li>
<li><p>Example: Alice chats with Bob</p>
</li>
<li><p>Bob authenticates Alice</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/b2a.png" width="350"></p>
</li>
<li><p>Alice authenticates Bob</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/a2b.png" width="350"></p>
</li>
<li><p>Authentication using public key</p>
<ul>
<li>Alice: sends $K_{B,pub}(A, R_A)$ to Bob (uses Bob’s public key)</li>
<li><p>Bob:</p>
<ul>
<li>Decrypts: $K_{B,priv}(K_{B,pub}(A, R_A))\rightarrow (A, R_A)$</li>
<li>Encrypts and sends $K_{A,pub}(R_A, R_B, K)$ to Alice</li>
</ul>
</li>
<li><p>Alice:</p>
<ul>
<li>Decrypts: $K_{A,priv}(K_{A,pub}(R_A, R_B, K))\rightarrow$ “It’s Bob”</li>
<li>Encrypts and sends $K(R_B)$ to Bob</li>
</ul>
</li>
<li><p>Bob: Decrypts $K(K(R_B)) = R_B \rightarrow$ “it’s Alice”</p>
</li>
<li><p>whole process:</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/b2a2b.png" width="350"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Digitial Signatures</p>
<ul>
<li><p>If Alice wants to digitially sign message to Bob</p>
<ul>
<li><p>Encrypt M using $K_{A,priv}$ and send $K_{A,priv}(M)$ to Bob</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/digital_signature_1.png" width="350"></p>
</li>
</ul>
</li>
<li><p>When Bob receives, decrypts using $K_{A, pub}$</p>
<ul>
<li>can decrypt only if from Alice</li>
</ul>
</li>
<li><p>To sign and keep private</p>
<ul>
<li>Alice sends $K_{B,pub}(M, K_{A, pirv}(M))$ to Bob</li>
<li>Only Bob can decryptL $K_{B,priv}(K_{B,pub}(M, K_{A,priv}(M))$</li>
<li><p>Decrypts using $K_{A,pub}$ proving Alice signed it</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/digital_signature_2.png" width="350"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]保护-protection</title>
    <url>/2020/04/19/protection/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面对文件和进程资源的保护方法，包括用户权限和用户组管理。</p>
<a id="more"></a>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><ol>
<li><p>Introduction</p>
<ul>
<li>Process access resources</li>
<li><p>Resources are shared, need to be protected</p>
<ul>
<li>from process without permission</li>
<li>from improper access by a process</li>
</ul>
</li>
<li><p>What is the right protection model?</p>
</li>
<li>What are the mechanism?</li>
</ul>
</li>
<li><p>The kernel enforces protection</p>
<ul>
<li>To pretect resources, have kernel “own” them, then kernel can allow access temporairily</li>
<li>To access a resource, a process must ask for it, then kernel can test whether access should be given</li>
<li><p>One a process is given access</p>
<ul>
<li>kernel can prevent others for gaining access</li>
<li>kernel may/may not be able to take away access</li>
</ul>
</li>
<li><p>This assumes kernel operates correctly</p>
</li>
</ul>
</li>
<li><p>Protecting the kernel</p>
<ul>
<li>The kernel itself must be protected</li>
<li><p>Mechanism</p>
<ul>
<li>Memory protecion</li>
<li>Protected mode of operation: kernel vs. user</li>
<li>Clock interrupt, so kernel eventually gets control</li>
</ul>
</li>
<li><p>Notice, mechanisms are hardware supported</p>
</li>
<li>Protected kernel can protect other resources</li>
</ul>
</li>
<li><p>Goals supported by kernel</p>
<ul>
<li>Allow range of permissions</li>
<li>Allow user to set/get them</li>
<li>Be fast/simple for common use</li>
<li>Support user expressing complex permissions</li>
</ul>
</li>
</ol>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><h3 id="Simple-model"><a href="#Simple-model" class="headerlink" title="Simple model"></a>Simple model</h3><ol>
<li><p>A formal model of protection</p>
<ul>
<li>Protection: how to limit access to a resource</li>
<li>Resource: object that requires protection</li>
<li>Domain: set of (resource, permission) pairs</li>
<li>Process: accesses resources within domain</li>
</ul>
</li>
<li><p>Protection Matrix</p>
<ul>
<li><p>Example: (X, Y: Resources A,B: Domains)</p>
<p>  |   |  X  |  Y  | A | B |<br>  |—-|—-  | —- |—-|—-|<br>  | A | r,w | r,w |   |   |<br>  | B | w   | r   |   |   |</p>
</li>
<li><p>Can describe all domains as a matrix</p>
<ul>
<li>Rows are domains</li>
<li>Columns are resources</li>
<li>Matrix entry [d, r] contains permissions/rights</li>
</ul>
</li>
<li><p>Access Control Lists (For resource)</p>
<ul>
<li>For each resource, list (domain, permissions) pairs</li>
<li>ACL is associated with resource</li>
<li>Like a registry: if name is on list, ok to access</li>
<li>Can be inefficient: must lookup on each access</li>
<li>Revocation is easy; just remove from list</li>
</ul>
</li>
<li><p>Capability Lists (For domain)</p>
<ul>
<li>For each domain, list (resource, permissions pairs)</li>
<li>Capability list associated with each domain</li>
<li>Like key/ticker: if you have it, you get access</li>
<li>Efficient: on access, just produce capability</li>
<li>Hard to revoke</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="UNIX-Protecion"><a href="#UNIX-Protecion" class="headerlink" title="UNIX Protecion"></a>UNIX Protecion</h3><ol>
<li><p>Basic</p>
<ul>
<li><p>Associated with each file is set of permissions</p>
<ul>
<li>Permission bits r/w/x for owner, group, world</li>
<li>Limited form of access control list</li>
</ul>
</li>
<li><p>Protection domain: UID (user account ID) + …</p>
<ul>
<li>A process is always in some domain</li>
</ul>
</li>
<li><p>When process opens file, check permission</p>
</li>
<li><p>If ok, provide process with a capability</p>
<ul>
<li>Future operations then carried out efficiently</li>
</ul>
</li>
</ul>
</li>
<li><p>More</p>
<ul>
<li>For common case, r/w/x for o/g/w adequate</li>
<li>For special cases, can extend via user program</li>
<li>SETUID mechanism: causes domain switch</li>
<li><p>If executable file has SETUID bit set</p>
<ul>
<li>Process runs in domain of owner (of executable)</li>
<li>Therefor, it runs with all the rights of the owner</li>
</ul>
</li>
</ul>
</li>
<li><p>Example</p>
<ul>
<li>Pat has a file “Bil” of bibliography references</li>
<li>Chris wants to read and add entries</li>
<li>But, Chris lacks permissions (only Pat can r/w)</li>
<li>Pat wisher to allow append access (only add entris to the back), but how?</li>
<li><p>Solution:</p>
<ul>
<li>Pat can provide program (e.g., EditBib): only reads/appends</li>
<li><p>Set permissions</p>
<ul>
<li>of program: execute (for Chris), and SETUID on</li>
<li>of Bib file: read/write only for Pat, not Chris</li>
</ul>
</li>
<li><p>When Chris executes EditBib, runs as Pat (since SETUID on, domain switch to Pat’s domain)</p>
</li>
<li>Program only does read/append.</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]输入/输出系统-I/O system</title>
    <url>/2020/04/19/IO-system/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面输入系统系统的概念，包括硬件上的组成以及软件的结构。</p>
<a id="more"></a>
<h2 id="I-O-basic"><a href="#I-O-basic" class="headerlink" title="I/O basic"></a>I/O basic</h2><ol>
<li><p>Intro</p>
<ul>
<li><p>I/O = Input/Output</p>
<ul>
<li>Input from attached device to CPU/memory</li>
<li>Output from CPU/memory to device</li>
</ul>
</li>
<li><p>Synchronization and transferring data</p>
</li>
</ul>
</li>
<li><p>Issues</p>
<ul>
<li><p>Problems:</p>
<ul>
<li>So many different types of I/O devices</li>
<li>Wide range: speed, operation, data transfer units</li>
</ul>
</li>
<li><p>Questions:</p>
<ul>
<li>How does a process initiate I/O?</li>
<li>How is synchronization achieved?</li>
<li>How is data transferred?</li>
</ul>
</li>
</ul>
</li>
<li><p>Background: I/O Hardware</p>
<ul>
<li><p>CPU and device (controller) communicate via</p>
<ul>
<li>I/O instructions</li>
<li>Memory instructuions (memory-mapped)</li>
</ul>
</li>
<li><p>Data transfer: progammed I/O vs. DMA (direct memory access)</p>
</li>
<li><p>Synchronization: polling vs. interrupts</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/hardware_io.png" width="500"></p>
</li>
</ul>
</li>
<li><p>Buffered/Unbuffered I/O</p>
<ul>
<li><p>Pros:</p>
<ul>
<li>What if pages containing buffer are paged out?</li>
<li>What if entire process is swapped out?</li>
<li>Can pin pages, but if too many processes do this?</li>
</ul>
</li>
<li><p>Cons:</p>
<ul>
<li>Memory copying is expensive</li>
<li>Consider effect on caches</li>
</ul>
</li>
</ul>
</li>
<li><p>Dealing with Complexity of Devices</p>
<ul>
<li><p>Many different types of devices</p>
<ul>
<li>Classify by shared characteristics</li>
<li>Imposes structure: shared code, lower complexity</li>
</ul>
</li>
<li><p>Dimensions</p>
<ul>
<li>Varaible vs. fixed size units</li>
<li>Sequential vs. random-access</li>
<li>Synchronous vs. asynchronous</li>
<li>Speed of operation</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="I-O-system"><a href="#I-O-system" class="headerlink" title="I/O system"></a>I/O system</h2><ol>
<li><p>I/O system Intro</p>
<ul>
<li><p>Software that deals with I/O</p>
<ul>
<li>Mostly in the kernel</li>
<li>Also in processes (in form of library, e.g., stdio)</li>
</ul>
</li>
<li><p>Separated into two portions</p>
<ul>
<li>Device-dependent</li>
<li>Device- independent</li>
</ul>
</li>
<li><p>Structure: Layered</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/IO_system_structure.png" width="500"></p>
</li>
</ul>
</li>
<li><p>Device Dependent: Device Drivers</p>
<ul>
<li><p>Encapsulates device-dependent code</p>
<ul>
<li>Contains device-specific register reads/write</li>
</ul>
</li>
<li><p>Implements a standard interface</p>
<ul>
<li>open(), close(), read(), write()</li>
</ul>
</li>
<li><p>Interrupt handlers</p>
<ul>
<li>Executes when I/O completes</li>
<li>Updates data structure</li>
<li>Wakes up waiting process</li>
</ul>
</li>
</ul>
</li>
<li><p>Device-Independent I/O</p>
<ul>
<li>Uniform interfacing for device drivers</li>
<li>Naming, protection</li>
<li>Uniform block size</li>
<li>Buffering, caching</li>
<li>Storage allocation</li>
<li>Locking</li>
<li>Error handling</li>
</ul>
</li>
<li><p>User-space I/O <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/user_space_io.png" width="180" style="float: right;"></p>
<ul>
<li><p>Convenient interface</p>
<ul>
<li>printf() vs. write()</li>
</ul>
</li>
<li><p>User-level buffering</p>
<ul>
<li>Unix: stdio library</li>
</ul>
</li>
<li><p>Spooling daemons</p>
<ul>
<li>Printer</li>
</ul>
</li>
</ul>
</li>
<li><p>Overall Operation</p>
<p> <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/io_operation.png" width="350"></p>
</li>
</ol>
<h3 id="Example-UNIX"><a href="#Example-UNIX" class="headerlink" title="Example: UNIX"></a>Example: UNIX</h3><ol>
<li><p>I/O Model <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/unix_io.png" width="180" style="float: right;"></p>
<ul>
<li>Uses file system interface</li>
<li>stdio.h: C standard I/O library</li>
<li><p>Block devices (disks, USB cameras, …)</p>
<ul>
<li>Fixed-size blocks</li>
<li>Randomly addressable</li>
<li>Uses buffer cache</li>
</ul>
</li>
<li><p>Character devices (serial ports, parallel ports, sound cards,…)</p>
<ul>
<li>Variable sequence of bytes</li>
<li>For non-block devices</li>
</ul>
</li>
</ul>
</li>
<li><p>I/O System Call Interface</p>
<ul>
<li>fd = open(“/dev/devname”, …)</li>
<li>close(fd)</li>
<li>nr = read(fd, buf, n)</li>
<li>nw = write(fd, buf, n)</li>
<li>ioctl(fd, cmd, buf) //(input/output control)</li>
</ul>
</li>
<li><p>Standard I/O Library</p>
<ul>
<li>fopen, fread, fwrite, fprintf, fscanf, fclose, …</li>
<li>Private buffer kept in user space</li>
<li>Minimizes the number of I/O system calls</li>
</ul>
</li>
<li><p>Software Block Cache Design</p>
<ul>
<li>Has copies of blocks that are also on disk</li>
<li><p>Upon read or write</p>
<ul>
<li>Check if a buffer contains the block</li>
<li>If not, get from disk</li>
<li>To make room, remove LRU block</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]文件系统-filesystem</title>
    <url>/2020/04/19/file-system/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面文件系统以及文件的概念，包括文件系统的组成以及访问具体文件/文件夹的方法。</p>
<a id="more"></a>
<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ol>
<li><p>Preview</p>
<ul>
<li><p>File: logical unit of storage, container of data</p>
<ul>
<li>Accessed by (name, region within file)</li>
</ul>
</li>
<li><p>File System: a structured collection of files</p>
<ul>
<li>Access control, name space, persistent storage</li>
</ul>
</li>
</ul>
</li>
<li><p>File System Abstraction</p>
<ul>
<li><p>Repository of objects</p>
<ul>
<li>Objects are data, programs for system and users</li>
<li>Objects referenced by name, to be read/written</li>
</ul>
</li>
<li><p>More than a repository</p>
<ul>
<li>Objects can be r/w, protected, shared, locked</li>
<li>Contains I/O devices: disk, keyboard, display</li>
<li>Processes: memory</li>
</ul>
</li>
<li><p>Pesistent: remains “forever”</p>
</li>
<li>Large: “unlimited” size</li>
<li>Sharing: controlled access</li>
<li>Security: protecting information</li>
</ul>
</li>
<li><p>Hierarchical File Name Space</p>
<ul>
<li><p>Name space is organized as a tree</p>
<ul>
<li>Name has components, branches start from root</li>
<li>No size restrictions</li>
<li>Intuitive for users</li>
</ul>
</li>
<li><p>Example: UNIX “Pathnames”</p>
<ul>
<li>Absolute: /a/b/c</li>
<li>Relative: b/c relative to /a</li>
<li>Not strictly a tree: links</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><ol>
<li><p>Attributes</p>
<ul>
<li>Type (recognized by system or users)</li>
<li>Times: creation, accessed, modified</li>
<li>Sizes: current size, (maximum size)</li>
<li>Access control (permissions)</li>
</ul>
</li>
<li><p>Operations</p>
<ul>
<li>Creation: create, delete</li>
<li>Prepare for access: open, close, mmap</li>
<li>Access: read, write</li>
<li>Search: move to location</li>
<li>Attributes: get, set(e.g., permissions)</li>
<li>Mutual exclusion: lock, unlock</li>
<li>Name management: rename</li>
</ul>
</li>
<li><p>Read/Write model</p>
<ul>
<li>(file descriptor)fd = open(fname, usage)</li>
<li>nr = read(fd, buf, size)</li>
<li>nw = write(fd, buf, size)</li>
<li><p>close</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/read_write.png" width="300"></p>
</li>
</ul>
</li>
<li><p>Memory-mapped model</p>
<ul>
<li><p>Map file into address space</p>
<ul>
<li>mmap(addr, n, …, fd, …)</li>
<li>addr = mmap(NULL, n, …, fd, …)</li>
</ul>
</li>
<li><p>Use memory ops</p>
<ul>
<li>x = addr[5]</li>
<li>strcpy(addr, “hello”)</li>
</ul>
</li>
<li><p>Issues</p>
<ul>
<li>Efficient for multiple process sharing memory</li>
<li>If memory is written, how is file actually updated?</li>
</ul>
</li>
</ul>
</li>
<li><p>Access Control</p>
<ul>
<li>Who can access file</li>
<li>What operations are allowed</li>
<li>User interface must be simple and intuitive</li>
<li><p>Example: Unix</p>
<ul>
<li>r/w/x permissions for owner, group and everyone</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="File-System-Implementation"><a href="#File-System-Implementation" class="headerlink" title="File System Implementation"></a>File System Implementation</h2><ol>
<li><p>Goals</p>
<ul>
<li><p>Archival storage</p>
<ul>
<li>Keep forever, including previous versions</li>
</ul>
</li>
<li><p>Support various storage technologies</p>
<ul>
<li>Disks (different types), remote disks, …</li>
</ul>
</li>
<li><p>How to best achieve and balance:</p>
<ul>
<li>Performance</li>
<li>Reliability</li>
<li>Security</li>
</ul>
</li>
</ul>
</li>
<li><p>Storage Abstraction</p>
<ul>
<li><p>Hide complexity of device</p>
<ul>
<li>Model as array of blocks of data</li>
<li>Randomly addressable by block number</li>
<li><p>Typical block size: 1KB (also 4KB ~ 64KB)</p>
<ul>
<li>Generally multiple of disk sector size: 512B</li>
</ul>
</li>
</ul>
</li>
<li><p>Simple interface</p>
<ul>
<li>read(block_num, mem_addr)</li>
<li>write(block_num, mem_addr)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Typical Implementation Structure</strong></p>
<ul>
<li>Three major regions: Sequence of blocks for each one</li>
<li><p>Region 1: File System Metadata</p>
<ul>
<li>Information about file system</li>
<li><p>Sizes</p>
<ul>
<li>Files in use, free entries</li>
<li>Data blocks in use, free entries</li>
</ul>
</li>
<li><p>Free lists (or bitmaps)</p>
<ul>
<li>File control blocks</li>
<li>Data blocks</li>
</ul>
</li>
</ul>
</li>
<li><p>Region 2: File Metadata (File Control Blocks)</p>
<ul>
<li>Information about a file</li>
<li>Referenced by number/index</li>
<li><p>Contains</p>
<ul>
<li>Attributes: type, size, permissions,…</li>
<li>References to data blocks: disk block map</li>
</ul>
</li>
<li><p>Note: many file control blocks may fit in single storage block</p>
</li>
<li><p>Example:</p>
<ul>
<li>Number: 88 (index in file control block array)</li>
<li>Size: 4096 bytes</li>
<li>Permissions: rw-r—r—</li>
<li>Data blocks: set of indexes into storage array, may not be contiguous (such as 567, 7076, 9201)</li>
</ul>
</li>
</ul>
</li>
<li><p>Region 3: Data Blocks</p>
<ul>
<li>File contents</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="File-control-blocks"><a href="#File-control-blocks" class="headerlink" title="File control blocks"></a>File control blocks</h3><ol>
<li><p>Keeping track of allocated blocks</p>
<ul>
<li><p>Contiguous blocks</p>
<ul>
<li>Single sequence of blocks</li>
</ul>
</li>
<li><p>Extents</p>
<ul>
<li>Groups of contiguous blocks</li>
</ul>
</li>
<li><p>Non-contiguous blocks</p>
<ul>
<li>Blocks individually named</li>
</ul>
</li>
</ul>
</li>
<li><p>Keeping track of free blocks</p>
<ul>
<li><p>Free Block Map</p>
<ul>
<li>Compact if lots of free regions of space</li>
</ul>
</li>
<li><p>Doubly Linked List</p>
<ul>
<li>Easy to keep ordered due to fast inserts and deletes</li>
</ul>
</li>
<li><p>Bit Map</p>
<ul>
<li>Fixed size regardless of fragmentation</li>
</ul>
</li>
</ul>
</li>
<li><p>File Name to File Control Block</p>
<ul>
<li>Users access files using file names</li>
<li><p>Problem: how to translate</p>
<ul>
<li>from file name: “/sports/baseball/Padres”</li>
<li>to file control block number: 88</li>
</ul>
</li>
<li><p>Must parse file name</p>
</li>
<li>Each branch corresponds to a directory/folder</li>
<li>Each directory/folder may itself be a file</li>
</ul>
</li>
</ol>
<h3 id="Example-UNIX-v-7-Block-Map"><a href="#Example-UNIX-v-7-Block-Map" class="headerlink" title="Example: UNIX v.7 Block Map"></a>Example: UNIX v.7 Block Map</h3><ol>
<li><p>Block Map UNIX v.7</p>
<ul>
<li>Array of pointers to data blocks</li>
<li><p>13 Pointers</p>
<ul>
<li>10 direct: references 10 data blocks</li>
<li>1 singly-indirect: references $n$ data blocks</li>
<li>1 doubly-indirect: reference $n^2$ data blocks</li>
<li>1 triply-indirect: reference $n^3$ data blocks</li>
</ul>
</li>
<li><p>$n$ depends on how many pointers fit in a block</p>
<ul>
<li><p>Example: 256 4-byte pointers will fit in 1KB block</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/unix.v7.png" width="400"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Implementing UNIX Directories</p>
<ul>
<li><p>Table where each entry contains</p>
<ul>
<li>name and attributes</li>
<li>name and pointer to file control structure</li>
</ul>
</li>
<li><p>Unix (name and pointer) - pre-BSD</p>
<ul>
<li>Each entry: branch name (14), i-node number (2)</li>
<li>Berkeley Unix uses a more complex scheme to support long names</li>
</ul>
</li>
</ul>
</li>
<li><p>Example of parsing names in UNIX</p>
<ul>
<li><p>Given pathname: /sports/baseball/Padres</p>
<ul>
<li>Inode 0 block map points to data block(s) of root directory</li>
<li>Look up “sports” in root directory to get inode 22</li>
<li>Inode 22 blocks map points to data block(s) of sports directory</li>
<li>Look up “baseball” in sports directory to get inode 15</li>
<li><p>…</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/unix_exp.png" width="400"></p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/unix_exp2.png" width="500"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><ol>
<li><p>File Systems use disks for storage</p>
<p> <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/disk.png" width="500"></p>
<ul>
<li>pros: persistent, random access, cheap</li>
<li>cons: slow (mechanical)</li>
<li><p>Performance</p>
<ul>
<li><p>Accesses are time expensive: 5 ~ 20 msec</p>
<ul>
<li>Rotational latency: 2 ~ 6 msec (5200 ~ 15000 RPM)</li>
<li>Seek time: 3 ~ 13 msec</li>
<li>Transfer rate: 100+ MB/sec</li>
</ul>
</li>
<li><p>Reduced accesses by</p>
<ul>
<li>reading multiple blocks in one access (read ahead)</li>
<li>maintaining a block cache</li>
</ul>
</li>
<li><p>Cluster related blocks to reduce seek time</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Solid State Drives (SSD)</p>
</li>
</ol>
<ul>
<li>NAND-based flash memory, non-volatile</li>
<li>Unaffected by shock, magnetic fields; no noise</li>
<li>Limited number of writes, wears out with age</li>
</ul>
<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><ol>
<li><p>Caching</p>
<ul>
<li>Data blocks of files</li>
<li>File system metadata (keep in memory)</li>
<li><p>File metadata</p>
<ul>
<li>Currently active file</li>
<li>Recently used</li>
</ul>
</li>
<li><p>Block maps</p>
</li>
<li><p>File names</p>
<ul>
<li>Name to file metadata translations</li>
</ul>
</li>
</ul>
</li>
<li><p>Clustering</p>
<ul>
<li><p>Blocks that exhibit locality of reference</p>
<ul>
<li>Directory, and files within that directory</li>
<li>The inodes of the directory and files</li>
</ul>
</li>
<li><p>Strategy</p>
<ul>
<li>Place related blocks close to each other: clustering</li>
<li>Reduces disk head movement and seek time</li>
</ul>
</li>
</ul>
</li>
<li><p>Block size</p>
<ul>
<li><p>trade off</p>
<ul>
<li>the larger the block, the better the throughput</li>
<li>The smaller the block, the less wasted space</li>
</ul>
</li>
<li><p>technology trend</p>
<ul>
<li>Disk density is increasing faster than disk speed</li>
<li>Make disk blocks larger: 1KB $\rightarrow$ 8KB, 64KB, 1MB</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Reliability"><a href="#Reliability" class="headerlink" title="Reliability"></a>Reliability</h3><ol>
<li><p>Consistency</p>
<ul>
<li>Buffer cache reduces disk access</li>
<li>If system crashes, block modifications lost</li>
<li><p>To improve file system consistency</p>
<ul>
<li>write out modified blocks periodically</li>
<li>write out critical blocks</li>
</ul>
</li>
<li><p>Critical blocks: file system meta-data</p>
<ul>
<li>Directories, i-nodes, free block lists</li>
</ul>
</li>
</ul>
</li>
<li><p>Journaling</p>
<ul>
<li>Journal: log of file (or file system) updates</li>
<li>For every update, create log entry</li>
<li>Write log entry out to disk (part of journal)</li>
<li><p>If crash occurs:</p>
<ul>
<li>Look at journal entries</li>
<li>Check if mods properly reflected in file system</li>
<li>Update appropriately</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]虚拟内存-virtual memory</title>
    <url>/2020/04/19/virtual_memory/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面虚拟内存的概念，主要是对上一节课的逻辑内存的一部分补充，关于segment和page的概念可以参考上一篇笔记。</p>
<a id="more"></a>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><ol>
<li><p>Segments and Pages</p>
<ul>
<li><p>Structuring memory as segements/pages allows:</p>
<ul>
<li>partitioning memory for convenient allocation</li>
<li>reorganizing memory for convenient usage</li>
</ul>
</li>
<li><p>Approaches</p>
<ul>
<li>Relocation via address translation</li>
<li>Protection via matching operations with objects</li>
</ul>
</li>
<li><p>Result: a logically organized memory</p>
</li>
</ul>
</li>
<li><p>Optimization</p>
<ul>
<li><p>Not all pieces need to be in memory</p>
<ul>
<li>Need only piece being referenced</li>
<li>Other pieces can be on disk</li>
<li>Bring pieces in only when needed</li>
</ul>
</li>
<li><p>Illusion: there is much more memory</p>
</li>
<li><p>Needed:</p>
<ul>
<li>A way to identify whether a piece is in memory</li>
<li>A way to bring in a piece (from where to where?)</li>
<li>Relocation (address translation)</li>
</ul>
</li>
</ul>
</li>
<li><p>From logical to virtual memory</p>
<ul>
<li><p>Logical memory becomes virtual memory</p>
<ul>
<li>Still logical (seperate organization from physical)</li>
<li>Virtual: memory seems to exist, regardless of how (memory or disk)</li>
</ul>
</li>
<li><p>Virtual memory: illusion of large memory</p>
<ul>
<li>Keep only portion of logical memory in physical</li>
<li>Rest is kept on disk (larger, slower, cheaper)</li>
<li>Unit of memory is segment or page (or both)</li>
</ul>
</li>
<li><p>Logical address space $\rightarrow$ virtual address space</p>
</li>
</ul>
</li>
</ol>
<h2 id="Virtual-memory-based-on-paging"><a href="#Virtual-memory-based-on-paging" class="headerlink" title="Virtual memory based on paging"></a>Virtual memory based on paging</h2><ol>
<li><p>Paged virtual memory</p>
<ul>
<li>All of pages reside on disk</li>
<li>Some also reside in physical memory (which ones?)</li>
</ul>
</li>
<li><p>Contents of page table entry</p>
<ul>
<li>Valid: is entry valid (page in physical memory or not)</li>
<li>Ref: has this page been referenced yet?</li>
<li>Mod: has this page been modified?</li>
<li>Frame: what frame is this page in?</li>
<li>Prot: what are the allowable operations?</li>
</ul>
</li>
<li><p>Address Translation</p>
<ul>
<li><p>Process:</p>
<ul>
<li>Get entry: index page table with page number</li>
<li><p>If valid bit is off, which cause a page fualt, then trap into kernel</p>
<ul>
<li>Find page on disk</li>
<li><p>Read it into a free frame</p>
<ul>
<li>may need to make room if there is no available frame: page replacement</li>
</ul>
</li>
<li><p>Record frame number in page table entry</p>
</li>
<li>Set valid bit and other fields</li>
</ul>
</li>
<li><p>Retry instruction (return from page-fault trap)</p>
</li>
</ul>
</li>
<li><p>Possible faults under segmentation/paging</p>
<ul>
<li><p>two kinds of address:</p>
<ul>
<li>Virtual address: (segment s, page p, offset i)</li>
<li>Physical address: (frame f, offset i)</li>
</ul>
</li>
<li><p>[ ] Use s to index segment table (to get page table)</p>
<ul>
<li>may get a segment fualt</li>
</ul>
</li>
<li><p>[ ] Check bound (Is p &lt; bound?)</p>
<ul>
<li>may get a segmentation violation</li>
</ul>
</li>
<li><p>[ ] Use p to index page table (to get frame f)</p>
<ul>
<li>may get a page fault</li>
</ul>
</li>
<li><p>[ ] Physical address: concatenate f and i</p>
</li>
</ul>
</li>
<li><p>Cost of page faults is high</p>
<ul>
<li>Disk: 5 ~ 6 orders magnitude slower than RAM</li>
<li><p>Example:</p>
<ul>
<li>RAM access time: 100 nsec</li>
<li>Disk access time: 10 msec</li>
<li>p = page fault probability</li>
<li>Effective access time: 100 + p * 10,000,000 nsec</li>
<li>if p = 0.1%, effective access time = 10,100 nsec (100 times slower!)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Possible-implementation"><a href="#Possible-implementation" class="headerlink" title="Possible implementation"></a>Possible implementation</h2><ol>
<li><p>Principle of Locality</p>
<ul>
<li><p>Not all pieces referenced uniformly over time</p>
<ul>
<li>Make sure most referenced pieces in memory</li>
<li>If not, thrashing: constant fetching of pieces</li>
</ul>
</li>
<li><p>References cluster in time/space</p>
<ul>
<li>Will be same or neighboring areas</li>
<li>Allows prediction based on past</li>
</ul>
</li>
</ul>
</li>
<li><p>Page replacement policy</p>
<ul>
<li>Goal: remove page not in locality of reference</li>
<li><p>Page replacement is about:</p>
<ul>
<li>which page(s) to remove</li>
<li>when to remove them</li>
</ul>
</li>
<li><p>How to do it in cheapest way possible, with:</p>
<ul>
<li>least amount of additional hardware</li>
<li>least amount of software overhead</li>
</ul>
</li>
</ul>
</li>
<li><p><em>Basic Page Replacement Algorithms</em></p>
<ul>
<li><p>FIFO: select page that is oldest</p>
<ul>
<li>Simple: keep pointer to next frame after last loaded</li>
<li>Doesn’t perform well (oldest may be popular)</li>
</ul>
</li>
<li><p>OPT: Optimal Page Replacement</p>
<ul>
<li>Optimal: replace page that will be accessed furthest in future</li>
<li><p>Not realistic:</p>
<ul>
<li>Requires predicting the future</li>
<li>Useful as a benchmark</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>LRU: Least Recently Used</strong></p>
<ul>
<li><p>Replace page that was least recently used</p>
<ul>
<li>LRU means used furthest in the past</li>
</ul>
</li>
<li><p>Takes advantage of locality of reference</p>
</li>
<li>Must have some way of tracking frame with LRU page : requires hardware support</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><ol>
<li><p><strong>Approximating LRU: Clock Algorithm</strong></p>
<ul>
<li><p>Select page that is old and not recently used</p>
<ul>
<li>Clock (second chance) is approximation of LRU</li>
</ul>
</li>
<li><p>Hardware support: reference bit</p>
<ul>
<li>Associated with each frame is a reference bit</li>
<li>Reference bit is in page table entry</li>
</ul>
</li>
<li><p>How reference bit is used</p>
<ul>
<li>When frame filled with page, set bit to 0 (by OS)</li>
<li>If frame is accessed, set bit to 1 (by hardware)</li>
</ul>
</li>
<li><p><em>Working process</em></p>
<ul>
<li>Arrange all frames in circle (clock)</li>
<li>Clock hand: next frame to consider</li>
<li><p>Page fault: find frame</p>
<ul>
<li>If ref bit 0, select frame</li>
<li>Else, set ref bit to 0</li>
<li>Advance clock hand</li>
<li>If frame found, break out of loop, else repeat</li>
</ul>
</li>
<li><p>If frame had modified page, must write it to disk</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Resident Set Management</p>
<ul>
<li><p>Resident set: process’s pages in physical memory</p>
<ul>
<li>One set per process</li>
<li>How big should resident set be? Which pages?</li>
<li>Who provides frame (same process or another)?</li>
</ul>
</li>
<li><p>Local: limit frame selection to request process</p>
<ul>
<li>Isolates effects of page behavior on processes</li>
<li>Inefficient: some processes have unused frames</li>
</ul>
</li>
<li><p>Global: select any frame (from any process)</p>
<ul>
<li>Efficient: resident sets grow/shrink accordingly</li>
<li>No isolation: process can negatively affect another (by replacing other process’s important pages)</li>
</ul>
</li>
</ul>
</li>
<li><p>Multiprogramming Level</p>
<ul>
<li>Multiprogramming level: number of processes in physical memory (non-empty resident sets)</li>
<li>Goal: increase multiprogramming level - how?</li>
<li>However, beyond certain point: thrashing (make processor utilization pretty low since many processes may not be working)</li>
<li>Resident set should contain the working set</li>
</ul>
</li>
<li><p>Denning’s Working Set Model</p>
<ul>
<li><p>Introduction</p>
<ul>
<li><p>Working set: $W(t, \Delta)$</p>
<ul>
<li>Pages referenced during last delta (process time)</li>
</ul>
</li>
<li><p>Process given frames to hold working set</p>
</li>
<li>Add/remove pages according to $W(t, \Delta)$</li>
<li>If working set doesn’t fit, swap process out</li>
</ul>
</li>
<li><p>Working set is a local replacement policy</p>
<ul>
<li>Process’s page fault behavior doesn’t affect others</li>
</ul>
</li>
<li><p>Problem: difficult to implement</p>
<ul>
<li>Must timestamp pages in working set</li>
<li>Must determine if timestamp older than $t - \Delta$</li>
<li>How should $\Delta$ be determined?</li>
</ul>
</li>
<li><p>Contrast to Clock</p>
<ul>
<li>Clock: simple, easy to implement, global policy</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]逻辑内存-logicalmemory</title>
    <url>/2020/04/19/logical_memory/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面逻辑内存的概念，包括页(page)和段(segment)的概念和实现。</p>
<a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol>
<li><p>Definition</p>
<ul>
<li>Logical memory = a process’s memory</li>
<li>As viewed (referenced) by a process</li>
<li>Allocated without regard to physical memory</li>
</ul>
</li>
<li><p>Problems with sharing memory</p>
<ul>
<li><p>The addressing problem</p>
<ul>
<li>Compiler generates memory reference</li>
<li>Unknown where process will be located</li>
</ul>
</li>
<li><p>The protection problem</p>
<ul>
<li>Modifying another process’s memory</li>
</ul>
</li>
<li><p>The space problem</p>
<ul>
<li>The more processes there are, the less memory each individually can have</li>
</ul>
</li>
</ul>
</li>
<li><p>Logical vs. Physical Addressing <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/logical_physical.png" width="150" style="float: right;"></p>
<ul>
<li><p>Logical addresses</p>
<ul>
<li>Assumes seperate memory starting at 0</li>
<li>Compiler generated</li>
<li>Independent of location in physical memory</li>
</ul>
</li>
<li><p>Convert logical to physical</p>
<ul>
<li>Via software: at load time</li>
<li>Via hardware: at access time</li>
</ul>
</li>
<li><p>Hardware for Logical addressing <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/memory_protection.png" width="180" style="float: right;"></p>
<ul>
<li>Base register filled with start address</li>
<li>To translate logical address, add base</li>
<li>Achieves relocation</li>
<li>To more process: change base</li>
</ul>
</li>
<li><p>Protection</p>
<ul>
<li>Bound register works with base register</li>
<li><p>Is address &lt; bound</p>
<ul>
<li>Yes: add to base</li>
<li>No: invalid address, TRAP</li>
</ul>
</li>
<li><p>Achieves protection</p>
</li>
</ul>
</li>
<li><p>Memory Registers are part of context</p>
<ul>
<li><p>On every context switch</p>
<ul>
<li>Load base/bound register for selected process</li>
<li>Only kernel does loading of these register</li>
<li>Kernel must be proetced from all processes</li>
</ul>
</li>
<li><p>Benefit</p>
<ul>
<li>Allows each proces to be seperated located</li>
<li>Protecs each process from all others</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Process mempory allocation</p>
<ul>
<li><p>Process address space</p>
<ul>
<li><p>Text: program instruction</p>
<ul>
<li>excute-only, fixed size</li>
</ul>
</li>
<li><p>Data: varaible (static, heap)</p>
<ul>
<li>read/write, variable size</li>
<li>dynamic allocation by request</li>
</ul>
</li>
<li><p>Stack: activation records, local variable</p>
<ul>
<li>read/write, varibale size</li>
<li>Automatic growth/shrinkage</li>
</ul>
</li>
</ul>
</li>
<li><p>Fitting process into memory</p>
<ul>
<li>Must find large enough hole</li>
<li>May not succeed even if enought fragment space</li>
<li>Even successul, it’s inefficient since space must be allocated for potential growth area</li>
</ul>
</li>
<li><p>Solution: break process into pieces</p>
<ul>
<li>Distribute into available holes</li>
<li>Two approaches: Segment and Page</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Segementation"><a href="#Segementation" class="headerlink" title="Segementation"></a>Segementation</h2><ol>
<li><p>Segemented Address Space</p>
<ul>
<li>Address space is a set of segments</li>
<li><p>Segment: a linearly addressed memory</p>
<ul>
<li>Typically contains logically-related information</li>
<li>Examples: program code, data, stack</li>
</ul>
</li>
<li><p>Each segment has an identifier s, and a size N</p>
<ul>
<li>s between 0 and S-1, S = max number of segments</li>
</ul>
</li>
<li><p><em>Logical addresses are of the form (s, i)</em></p>
<ul>
<li>offset i within segment s, i must be less than N</li>
</ul>
</li>
<li><p>Example</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/segment_example.png" width="400"></p>
</li>
</ul>
</li>
<li><p>Segment-based address translation</p>
<ul>
<li>Problem: how to translate a logical address (s, i) into physical address a?</li>
<li><p>Solution: use a segment (translate) table (ST)</p>
<ul>
<li>to segment s into base physical address b = ST(s)</li>
<li>then add b and i</li>
</ul>
</li>
<li><p>physical address a = ST(s) + i</p>
</li>
</ul>
</li>
<li><p><em>Segment Table</em> <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/ST.png" width="180" style="float: right;"></p>
<ul>
<li>One table per process (typically)</li>
<li><p>Table entry elements</p>
<ul>
<li>V: valid bit</li>
<li>Base: segment location</li>
<li>Bound: segment size</li>
<li>Perm: permissions</li>
</ul>
</li>
<li><p>Location in memory given by</p>
<ul>
<li>Segment table base register(hardware)</li>
<li>Segment table size register(hardware)</li>
</ul>
</li>
<li><p>Address translation</p>
<ul>
<li>physical address a = base of s + i</li>
<li><p>do a series of checks</p>
<ul>
<li>s &lt; STSR? -&gt; is segment identifier valid or not?</li>
<li>V == 1? -&gt; the corresponding entry is valid?</li>
<li>i &lt; Bound? -&gt; logical address is out of bound?</li>
<li>Perm(op) -&gt; that block has required operation(r/w/x)?</li>
<li><p>Then access that physical address</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/physical_address_check.png" width="300"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Sizing the segment table</strong></p>
<ul>
<li><p>Given 32 bit logical, 1 GB physical memory (max)</p>
<ul>
<li>5 bit segment number, 27 bit offset</li>
</ul>
</li>
<li><p>Logical address</p>
<ul>
<li><p>Segement s: number of bits n specifies maxsize of table, where number of entries = $2^n$</p>
<ul>
<li>if 32 entries, n = 5</li>
</ul>
</li>
<li><p>Offset i: number of bits n specifies maxsize of segment</p>
<ul>
<li>27 bits needed to size up to 128MB</li>
</ul>
</li>
</ul>
</li>
<li><p>segment table</p>
<ul>
<li>V: 1 bit</li>
<li><p>Base: number of bits needed to address physical memory</p>
<ul>
<li>30 bits needed to address 1GB</li>
</ul>
</li>
<li><p>Bound: number of bits needed to specify max segment size</p>
<ul>
<li>27 bits needed to size up to 128MB</li>
</ul>
</li>
<li><p>Perm: assume 3 bit (r/w/x)</p>
</li>
<li><p>one entry: $1 + 30 + 27 + 3 + … = 61$+ bits $\approx$ 8 bytes</p>
</li>
<li>whole table: 32 * 8 = 256 bytes</li>
</ul>
</li>
</ul>
</li>
<li><p>Pros and Cons</p>
<ul>
<li><p>Pros: Each segment can be</p>
<ul>
<li>located independently</li>
<li>seperately protected</li>
<li>grown/shrunk independently</li>
<li>Segments can be shared by processes (via segment table)</li>
</ul>
</li>
<li><p>Cons: Variable-size allocation</p>
<ul>
<li>Difficult to find holes in physical memory</li>
<li>External fragmentation</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><ol>
<li><p>Paged Address Space <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/Paging.png" width="180" style="float: right;"></p>
<ul>
<li><p>Logical (process) memory</p>
<ul>
<li>Linear sequence of pages</li>
</ul>
</li>
<li><p>Physical memory</p>
<ul>
<li>Linear sequence of frames</li>
</ul>
</li>
<li><p>Pages and frames</p>
<ul>
<li>Frame: a physical unit of information</li>
<li>A page fits exactly into a frame</li>
<li>Fixed size, all pages/frames same size</li>
</ul>
</li>
</ul>
</li>
<li><p>Page-based Logical Addressing</p>
<ul>
<li><p>Form of logical address: (p, i)</p>
<ul>
<li>p is page number, 0 to N - 1</li>
<li>i is offset within page, since page size is fixed, i is guaranteed to be less than page size, no need to check</li>
</ul>
</li>
<li><p>Size of logical address space</p>
<ul>
<li>$N_L$ = max number of pages</li>
<li>$N_L \times$ page size = size of logical address space</li>
</ul>
</li>
</ul>
</li>
<li><p>Frame-based Physical Addressing</p>
<ul>
<li><p>Form of physical address: (f, i)</p>
<ul>
<li>f is frame number, 0 to N - 1</li>
<li>i is offset within frame, less than frame size</li>
</ul>
</li>
<li><p>Size of physical address space</p>
<ul>
<li>$N_p$ = max number of frames</li>
<li>$N_p \times$ frame size = size of physical address space</li>
</ul>
</li>
</ul>
</li>
<li><p>Page-based address translation</p>
<ul>
<li>Problem: how to translate logical address (p, i) into physical address (f, i)</li>
<li><p>Solution: use a page (translation) table PT</p>
<ul>
<li>translate page p into frame f = PT(p)</li>
<li>then concatenate f and i</li>
</ul>
</li>
<li><p>Physical address (f, i) = PT(p) || i = (PT(p), i)</p>
</li>
</ul>
</li>
<li><p><strong>Page table</strong></p>
<ul>
<li>Each page of logical memory correspondings to entry in page table</li>
<li>Page table maps logical page into frame of physical memory</li>
<li>One table per process (typically)</li>
<li><p>Table entry elements</p>
<ul>
<li>V: valid bit</li>
<li>DPB: demand paging bits</li>
<li>Frame: page location</li>
</ul>
</li>
<li><p>Location in memory given by</p>
<ul>
<li>Page table base register(PTBR) (hardware)</li>
<li>Page table size register(PTSR) (hardware)</li>
</ul>
</li>
<li><p>Address translation</p>
<ul>
<li>Physical address = frame of p || offset i</li>
<li><p>Do a series of checks (similar to segmenatation)</p>
<ul>
<li>p &lt; PTSR?</li>
<li>V == 1?</li>
<li>Perm(op)?</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Sizing the page table</strong></p>
<ul>
<li><p>Given 32 bit logical, 1 GB physical memory (max)</p>
<ul>
<li>20 bit page number, 12 bit offset</li>
</ul>
</li>
<li><p>Logical address</p>
<ul>
<li>page p: 20 bits to address $2^{20} =$ 1M entries</li>
<li>offset i: 12 bits, page size = frame size = $2^{12} =$ 4096 bytes.</li>
</ul>
</li>
<li><p>Page table</p>
<ul>
<li>V: 1 bit</li>
<li>DPB: 3 bits</li>
<li>Frame: 18 bits to address $2^{30}/2^{12}$ frames</li>
<li>Perm: 3bits</li>
<li>One entry: $1+3+18+3+…= 25$+ bits $\approx$ 4 bytes</li>
<li>Whole table size = 1M * 4 = 4 MB</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Address-translation"><a href="#Address-translation" class="headerlink" title="Address translation"></a>Address translation</h2><ol>
<li><p>Segments vs. Pages</p>
<ul>
<li><p>Segment is good “logical” unit of information</p>
<ul>
<li>Can be sized to fit any contents</li>
<li>Makes sense to share (e.g., code, data)</li>
<li>Can be protected according to contents</li>
</ul>
</li>
<li><p>Page is good “physical” unit of information</p>
<ul>
<li>Simple memory management</li>
</ul>
</li>
</ul>
</li>
<li><p>Combining segments and pages <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/segment_page.png" width="250" style="float: right;"></p>
<ul>
<li><p>Logical memory</p>
<ul>
<li>composed of segments</li>
</ul>
</li>
<li><p>Each segment</p>
<ul>
<li>composed of pages</li>
</ul>
</li>
<li><p>Segment table</p>
<ul>
<li>Maps each segment to a page table</li>
</ul>
</li>
<li><p>Page tables</p>
<ul>
<li>Maps each page to physical page frames</li>
</ul>
</li>
</ul>
</li>
<li><p>Address Translation</p>
<ul>
<li>Logical address: [segment s, page p, offset i]</li>
<li><p>Do various checks</p>
<ul>
<li>s &lt; STSR, V == 1, p &lt; bound, perm(op)</li>
<li>May get a segmentation violation</li>
</ul>
</li>
<li><p>Use s to index segment table to get page table</p>
</li>
<li>Use p to index page table to get frame f</li>
<li><p>Physical address = concatenate (f, i)</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/Segment_Page_Address.png" width="300"></p>
</li>
</ul>
</li>
</ol>
<h2 id="More-on-addressing"><a href="#More-on-addressing" class="headerlink" title="More on addressing"></a>More on addressing</h2><ol>
<li><p>Cost of translation</p>
<ul>
<li><p>Each lookup costs another memory reference</p>
<ul>
<li>For each reference, additional references required</li>
<li>Slows machine down by factor of 2 or more</li>
</ul>
</li>
<li><p>Take advantage of locality of reference</p>
<ul>
<li>Most references are to a small number of pages</li>
<li>Keep translation of these in high-speed memory</li>
</ul>
</li>
<li><p>Problem: don’t know which pages till accessed</p>
</li>
</ul>
</li>
<li><p><strong>Translation Look-aside Buffer (TLB)</strong></p>
<ul>
<li>Fast memory keeps most recent translations</li>
<li>If key matches, get frame number</li>
<li><p>else wait for normal translation (in parallel)</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/TLB.png" width="400"></p>
</li>
</ul>
</li>
<li><p>Translation Cost with TLB</p>
<ul>
<li><p>Cost is determined by</p>
<ul>
<li>Speed of memory: ~100 nsec</li>
<li>Speed of TLB: ~5 nsec</li>
<li>Hit ratio: fraction of refs satisfied by TLB, ~99%</li>
</ul>
</li>
<li><p>Speed with no address translation: 100 nsec</p>
</li>
<li><p>Speed with address translation</p>
<ul>
<li>TLB miss: 200 nsec (100% slowdown)</li>
<li>TLB hit: 105 nsec (5% slowdown)</li>
<li>Average: 105 x 0.99 + 200 x 0.01 ~ 106 nsec</li>
</ul>
</li>
</ul>
</li>
<li><p>TLB Design Issues</p>
<ul>
<li><p>The larger the TLB</p>
<ul>
<li>the higher the hit rate</li>
<li>the slower the reponse</li>
<li>the greater the expense</li>
</ul>
</li>
<li><p>TLB has a major effect on performance!</p>
<ul>
<li>Must be flushed on context switched</li>
<li>Alternative: tagging entries with PIDs</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]内存管理-memory_management</title>
    <url>/2020/04/19/memory_management/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面对内存的分配以及管理方式</p>
<a id="more"></a>
<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ol>
<li><p>Allocation of memory occurs when</p>
<ul>
<li>new process is created</li>
<li>process requests more memory</li>
</ul>
</li>
<li><p>Freeing of memory occurs when</p>
<ul>
<li>process exits</li>
<li>process no longer needs memory it requested</li>
</ul>
</li>
<li><p>Memory overview</p>
<ul>
<li><p>Porcess memory store:</p>
<ul>
<li>Text: code of program</li>
<li>Data: static varibales, heap</li>
<li>Stack: automatic variables, activation records</li>
<li>Other: shared memory regions</li>
</ul>
</li>
<li><p>Process memory address space <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/process_mem.png" width="120" style="float: right;"></p>
<ul>
<li><p>Address space</p>
<ul>
<li>set of addresses to access memory</li>
<li>Typically, linear and sequential</li>
<li>0 to N-1</li>
</ul>
</li>
<li><p>Example (right):</p>
<ul>
<li>Text of size X at 0 ~ X-1</li>
<li>Data of size Y at X ~ X+Y-1</li>
<li>Stack of size Z at N-Z ~ N-1(grow reversely)</li>
</ul>
</li>
</ul>
</li>
<li><p>Compiler’s model of memory</p>
<ul>
<li><p>Compiler generates memory address</p>
<ul>
<li>Address ranges of text, data, stack</li>
<li>allow data and stack to grow</li>
</ul>
</li>
<li><p>What is not known in compiler</p>
<ul>
<li>Physical memory size</li>
<li>Allocated region of physical memory</li>
</ul>
</li>
</ul>
</li>
<li><p>Memory characteristics</p>
<ul>
<li>Size, fixed or variable (max size)</li>
<li>Permission: r, w, x</li>
</ul>
</li>
</ul>
</li>
<li><p>Goal: support multiple processes</p>
<ul>
<li><p>Support programs running “simultaneously”</p>
<ul>
<li>implement process abstraction</li>
<li>Multiplex CPU time over all runnable processes</li>
<li>Disk r/w speed is low: must keep multiple processes in memory</li>
</ul>
</li>
<li><p>Process requires more than CPU time: memory</p>
</li>
</ul>
</li>
<li><p>Memory issues and topics</p>
<ul>
<li>Where should process memories be placed? -&gt; Memory Management</li>
<li>How does the compiler model memory? -&gt; Logical memory model, segmentation</li>
<li>How to deal with limited physical memory? -&gt; Virtual memory, paging</li>
<li>Machanism and Policies</li>
</ul>
</li>
</ol>
<h2 id="Memory-Managemeng-Implementation"><a href="#Memory-Managemeng-Implementation" class="headerlink" title="Memory Managemeng Implementation"></a>Memory Managemeng Implementation</h2><ol>
<li><p>example process <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/memory_allocate.png" width="150" style="float: right;"></p>
<ul>
<li>Phsical memory starts as one empty “hole”</li>
<li>When processes are created, areas get allocated</li>
<li><p>To allocate memory</p>
<ul>
<li>find large enough hole</li>
<li>allocate region within hole</li>
<li>mostly leaves smaller hole (when the hole size does not exactly match the size of process memory)</li>
<li>when process exit (or memeory no longer needed), release that area, which create a new hole, coaleasce with adjacent</li>
</ul>
</li>
<li><p>problem: if there are multiple holes, which to select?</p>
<ul>
<li><p><em>First fit: simple, fast</em></p>
<ul>
<li>consider tradeoff: fit vs. search time</li>
<li>memory is cheap, time is expensive</li>
</ul>
</li>
<li><p>Best fit: optimal, must check every hole, leaves very small fragments</p>
</li>
<li>Worst fit: leaves large fragments, must check every hole</li>
</ul>
</li>
<li><p>complication: is region fixed or variable size?</p>
</li>
</ul>
</li>
<li><p>Fragmentation</p>
<ul>
<li>Over time, memory becomes fragmented, there may be signficant unused space (fragmented)</li>
<li><p>Internal fragmentation</p>
<ul>
<li>Unused space within (allocated) block</li>
<li>Cannot be allocated to others</li>
<li>Can come in handy for growth (for stack or heap)</li>
</ul>
</li>
<li><p>External fragmentation</p>
<ul>
<li>Unused space outside any blocks (holes)</li>
<li>Can be allocated (too small/not useful)</li>
</ul>
</li>
<li><p>Approaches</p>
<ul>
<li><p>Compaction</p>
<ul>
<li>Simple idea</li>
<li>Very time consuming</li>
</ul>
</li>
<li><p>Break block (to be allocated) into sub-blocks</p>
<ul>
<li>Easier to fit</li>
<li>But complex</li>
</ul>
</li>
<li><p>Use pre-sized holes</p>
<ul>
<li><p>Same-sized holes:</p>
<ul>
<li>all holes same, easy allocation</li>
<li>may be too small which is inflexible</li>
</ul>
</li>
<li><p>Varaiety of sizes (small, medium, large)</p>
<ul>
<li>more flexible</li>
<li>complex</li>
<li>what should sizes be? how to determine</li>
</ul>
</li>
<li><p>Not adaptable, cause internel fragmentation</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Some rules</p>
<ul>
<li><p>50% Rule: m = n / 2</p>
<ul>
<li>Block: an allocated block</li>
<li>Hole: free space between blocks</li>
<li>m = number of holes</li>
<li>n = number of blocks</li>
</ul>
</li>
<li><p><strong>Unused Memory Rule: f = k / (k + 2)</strong></p>
<ul>
<li>Given average size of blocks and holes are known</li>
<li>b = average size of blocks</li>
<li>h = average size of holes</li>
<li>k = h / b, ratio of average hole-to-block size</li>
<li>f = k / (k + 2) is fraction space lost to holes</li>
</ul>
</li>
<li><p>Usage:</p>
<ul>
<li>k = 1, f = 1/3 -&gt; avg hole size = avg block size, 33% waste</li>
<li>k = 2, f = 1/2 -&gt; avg hole size = 2 * avg block size, 50% waste</li>
<li>k = 8, f = 4/5 -&gt; avg hole size = 8 * avg block size, 80% waste</li>
</ul>
</li>
<li><p>Limits</p>
<ul>
<li><p>In general, f increases with increasing k</p>
<ul>
<li>as $k \rightarrow \infty, f \rightarrow 1$</li>
</ul>
</li>
<li><p>Alternatively, f decreases with decreasing k</p>
<ul>
<li>as $k \rightarrow 0, f \rightarrow 0$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>The Buddy System</strong></p>
<ul>
<li>Partition into power-of-2 size chunks</li>
<li><p>Allocation: given request for size r</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find chunk larger than r (else return failure)</span><br><span class="line">while (r &lt; sizeof(chunk) &#x2F; 2)</span><br><span class="line">    divide chunk into buddies (each 1&#x2F;2 size)</span><br><span class="line">allocate the chunk</span><br></pre></td></tr></table></figure>
</li>
<li><p>Free: free the chunk and coalesce with buddy</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free the chunk</span><br><span class="line">while (buddy is also free)</span><br><span class="line">    coalesce</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/Buddy.html" target="_blank" rel="noopener">visualization</a></p>
</li>
<li><p>Data structure for buddy-system -&gt; binary tree</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]死锁-deadlock</title>
    <url>/2020/04/19/deadlock/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面死锁概念包括出现的原因，以及避免（防止出现）以及解决办法（出现死锁时最好的方法是重启大法！！）</p>
<a id="more"></a>
<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ol>
<li><p>Definition</p>
<ul>
<li>Set of processes are permanently blocked<ul>
<li>Unblocking of one relies on progress of another, but none can make progress</li>
</ul>
</li>
<li><p>Example</p>
<ul>
<li>Process A holding resource X, waiting for resource Y</li>
<li>Process B holding Y, waiting for X</li>
<li><p>these two process will not be able to make any progress</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/deadlock.png" width="200"></p>
</li>
</ul>
</li>
<li><p>Another example: memory</p>
<ul>
<li>Total memory = 200MB</li>
<li>P1 holds 80MB, requests 60MB</li>
<li>P2 holds 70MB, requests 80MB</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><strong>Four conditions for Deadlock</strong></strong></p>
<ul>
<li>Mutual Exclusion<ul>
<li>Only one process may use a resouce at a time</li>
</ul>
</li>
<li>Hold-and-Wait<ul>
<li>Process holds resouce while waiting for another</li>
</ul>
</li>
<li>No Preemption<ul>
<li>Can’t take a resource away from a process</li>
</ul>
</li>
<li>Circular Wait<ul>
<li>The waiting process form a cycle</li>
</ul>
</li>
</ul>
</li>
<li><p>Attack the Deadlock Problem</p>
<ul>
<li>Deadlock prevention<ul>
<li>Make deadlock impossible by removing one (or more)condition</li>
</ul>
</li>
<li>Deadlock Avoidance<ul>
<li>Avoid getting into situations that lead to deadlock</li>
</ul>
</li>
<li>Deadlock Detection<ul>
<li>Don’t try to stop deadlocks</li>
<li>If they happen, detect and resolve</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Attck-the-deadlock"><a href="#Attck-the-deadlock" class="headerlink" title="Attck the deadlock"></a>Attck the deadlock</h2><ol>
<li><p>Deadlock prevention</p>
<ul>
<li>Mutual exclusion -&gt; relax where sharing is possible</li>
<li>Hold-and-Wait -&gt; Get all resources simultaneously (wait until all free)</li>
<li>No preemption -&gt; allow resources to be taken away</li>
<li>Circular wait -&gt; order all the resources, force ordered acquisition</li>
</ul>
</li>
<li><p>Deadlock Avoidance</p>
<ul>
<li>Avoid getting into situations that lead to deadlock<ul>
<li>Selective prevention</li>
<li>Remove condition only when deadlock is possible</li>
</ul>
</li>
<li>Works with incremental resource requests<ul>
<li>Resources are asked for in increments</li>
<li>Do not grant request than can lead to a deadlock</li>
</ul>
</li>
<li>Need maximum resource requirements</li>
<li><p><strong>Banker’s Algorithm</strong></p>
<ul>
<li>Fixed number of processes and resources</li>
<li>System state: either safe or unsafe<ul>
<li>Depends on allocation of resources to processes</li>
</ul>
</li>
<li>Safe: deadlock is absolutely avoidable<ul>
<li>Can avoid deadlock by certain order of execution</li>
</ul>
</li>
<li>Unsafe: deadlock is possible(but not certain)<ul>
<li>May not be able to avoid deadlock</li>
</ul>
</li>
<li><p>Diagram</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/banker_algorithm.png" width="200"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Deadlock Detection (<em>mostly used!</em>)</p>
<ul>
<li><p>Method</p>
<ul>
<li>Periodically try to detect if a deadlock occurred</li>
<li>Do something (or nothing) about it</li>
</ul>
</li>
<li><p>Resoning</p>
<ul>
<li>Deadlocks rarely happen</li>
<li>Cost of prevention or avoidance not worth it</li>
<li>Deal with them in special way (may costly)</li>
</ul>
</li>
<li><p>Recovery from deadlock</p>
<ul>
<li>Terminate all deadlocked process (reboot)</li>
</ul>
</li>
<li>Terminate deadlocked processed one at a time<ul>
<li>need to detect</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]进程间通信-inter process communication(IPC)</title>
    <url>/2020/04/19/inter_process_communication/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面不同进程之间通信的算法和实现。</p>
<a id="more"></a>
<ol>
<li><p>Cooperating Processes and IPC</p>
<ul>
<li><p>Advantage of Cooperating Processes</p>
<ul>
<li>performance: speed<ul>
<li>Exploit inherent parallelism of computation</li>
<li>Allow some parts to proceed why other do I/O</li>
</ul>
</li>
<li>Modularity: resuable self-contained programs<ul>
<li>Each may do a useful task on its own</li>
<li>May also be useful as a sub-task for others</li>
</ul>
</li>
<li><p>Examples:</p>
<p> <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/cooperating_processes_example.png" width="350"></p>
</li>
</ul>
</li>
<li><p>IPC: communication between processes</p>
</li>
<li><strong>IPC requires</strong>:<ul>
<li>data transfer</li>
<li>synchronization</li>
</ul>
</li>
<li><strong>Three abstraction for IPC</strong><ul>
<li>shared memory + semaphores</li>
<li>monitors</li>
<li>message passing</li>
</ul>
</li>
</ul>
</li>
<li><p>The producer/consumer problem</p>
<ul>
<li>Producer produces data, inserts in shared buffer</li>
<li>Consumer removes data from buffer, consumes it</li>
<li>Cooperation: Producer feeds Consumer<ul>
<li>How does data get from producer to consumer?</li>
<li>How does consumer wait for producer?</li>
</ul>
</li>
<li><p>Example:</p>
<p><img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/producer_consumer.png" width="350"></p>
</li>
</ul>
</li>
<li><p>Shared memory + semaphore</p>
<ul>
<li><p>implementation:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shared <span class="keyword">int</span> buf[N], in = <span class="number">0</span>, out = <span class="number">0</span>;</span><br><span class="line">sem filledslots = <span class="number">0</span>, emptyslots = N, mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer1, 2, ...</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  wait (emptyslots); <span class="comment">// wait for available empty slots</span></span><br><span class="line">  wait (mutex); <span class="comment">// avoid racondition</span></span><br><span class="line">  buf[in] = Produce();</span><br><span class="line">  in = (in + <span class="number">1</span>) % N;</span><br><span class="line">  signal(mutex);</span><br><span class="line">  signal(filledslots); <span class="comment">// increment the number of filled slots</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer1, 2, ...</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  wait(filledslot);</span><br><span class="line">  wait(mutex);</span><br><span class="line">  Consume(buf[out]);</span><br><span class="line">  out = (out + <span class="number">1</span>) % N;</span><br><span class="line">  signal(mutex);</span><br><span class="line">  signal(emptyslots);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>work for multiple producers and consumer</p>
</li>
<li>Not easy to understand(many wait/signal statements), easily leads to bugs</li>
</ul>
</li>
<li><p>monitors</p>
<ul>
<li><p>Programming language contruct for IPC</p>
<ul>
<li>monitors are variables requiring controlled access</li>
<li>accessd via procedures</li>
<li>condition variables<ul>
<li>wait(cond)</li>
<li>signal(cond)</li>
</ul>
</li>
</ul>
</li>
<li><p>Only one process can be active inside monitor</p>
</li>
<li><p>Usage</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a possible monitor implementation (provided by programming language)</span></span><br><span class="line">monitor ProducerConsumer &#123;</span><br><span class="line">  <span class="keyword">int</span> buf[N], in = <span class="number">0</span>, out = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">  cond slotavail, itemavail;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PutItem</span> <span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == N) wait(slotavail);</span><br><span class="line">    buf[in] = item;</span><br><span class="line">    in = (in + <span class="number">1</span>) % N;</span><br><span class="line">    count++;</span><br><span class="line">    signal(itemavail);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">GetItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) wait(itemavail);</span><br><span class="line">    item = buf[out];</span><br><span class="line">    out = (out + <span class="number">1</span>) % N;</span><br><span class="line">    count--;</span><br><span class="line">    signal(slotavail);</span><br><span class="line">    <span class="keyword">return</span> (item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  PutItem(Produce());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  Consume(GetItem());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mechanism</p>
<p> <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/monitors.png" width="400"></p>
</li>
<li><p>more on Monitors</p>
<ul>
<li>If one process A siganl condition c while another process B is waiting on c, at that time two process are able to run at the same time, which breaks mutual exclusion. <strong>So each process only signal condition just before returning.</strong></li>
<li><em>Contition variable have no memory</em><ul>
<li>It has no value and only indicate whether an event occurs or not</li>
<li>Signal without someone waiting does nothing</li>
<li>Signal is “lost”</li>
</ul>
</li>
<li>Monitors bring structure to IPC<ul>
<li>localizes critical sections and synchronization</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Message Passing</p>
<ul>
<li><p>Model:</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/Message_Passing.png" width="400"></p>
</li>
<li><p>methods:</p>
<ul>
<li>send(destination, &amp;message)</li>
<li>receive(source, &amp;message)</li>
</ul>
</li>
<li><p>Data transfer: in to and out of kernel message buffer</p>
</li>
<li><p>Synchronization: receive blocks to wait for message</p>
</li>
<li><p>Usage</p>
<ul>
<li><p>basic</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* NO SHARED MEMORY */</span></span><br><span class="line"><span class="comment">// Producer</span></span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">item = Produce();</span><br><span class="line">send(Consumer, &amp;item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer</span></span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">receive(Producer, &amp;item);</span><br><span class="line">Consume(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>with Flow Control</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Producer</span></span><br><span class="line"><span class="keyword">int</span> item, empty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    item = Produce();</span><br><span class="line">    receive (Consumer,&amp;empty);</span><br><span class="line">    send(Consumer, &amp;item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer</span></span><br><span class="line"><span class="keyword">int</span> item, empty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> N times &#123;</span><br><span class="line">    send(Producer, &amp;empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    receive(Producer, &amp;item);</span><br><span class="line">    send(Producer, &amp;empty);</span><br><span class="line">    Consume(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>more on Message Passing</p>
<ul>
<li><p>who should message be addressed to?</p>
<ul>
<li>ports(“mailbox”) rather than specific process</li>
</ul>
</li>
<li><p>how to make process recieve from anyone?</p>
<ul>
<li>pid = receive(*, &amp;message)?</li>
</ul>
</li>
<li>kernel buffering: outstanding message<ul>
<li>message sent that haven’t been received yet</li>
</ul>
</li>
<li>Good praradigm for IPC over networks</li>
<li>Safer than shard memory paradigms</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]同步-synchronization</title>
    <url>/2020/04/19/synchronization/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，这一课主要介绍了操作系统里面进程同步的算法，主要是信号量 (Semaphores) 的使用。</p>
<a id="more"></a>
<h2 id="Problem-introduction"><a href="#Problem-introduction" class="headerlink" title="Problem introduction"></a>Problem introduction</h2><ol>
<li><p>Introduction</p>
<ul>
<li>synchronization: events happen at the same time</li>
<li>Process synchronization<ul>
<li>Events in process that occur “at the same time”</li>
<li>one process have to wait for another</li>
</ul>
</li>
<li>Usage<ul>
<li>prevent race conditions</li>
<li>wait for resources to become available</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>race condition</strong></p>
<ul>
<li>race condition: two process which should run sequently accidentally run at the same time (which cause a bug)</li>
<li>To avoid race conditions:<ul>
<li>identify related <em>critical sections</em><ul>
<li>Section of code excuted by different processes</li>
<li>critical sections must run <em>atomically</em> w.r.t each other</li>
</ul>
</li>
<li>Enforce <em>mutual exclusion</em><ul>
<li>only one process is allowed to be active in critical section</li>
</ul>
</li>
</ul>
</li>
<li><em>Atomic</em><ul>
<li>atomic means “indivisible”</li>
<li>effective atomicity<ul>
<li>interrupt may occur, but it shouldn’t has effect on that section caused by other processes</li>
</ul>
</li>
<li>How to determine wether a critical section is atomic<ul>
<li>Consider effect of critical section in isolation</li>
<li>Consider interruptions: if the result is same, then it is OK.</li>
</ul>
</li>
</ul>
</li>
<li><em>Mutual exclusion</em><ul>
<li>Surrond critical section with entry/exit code</li>
<li>entry code act as a barrier<ul>
<li>if another process is critical section, block current process till it exit</li>
<li>Otherwise, allow process to proceed</li>
</ul>
</li>
<li>Exit code should release other entry barriers</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><strong>Requirements for good solution</strong></strong></p>
<ul>
<li>Given<ul>
<li>multiple cooperating process</li>
<li>each with related critical sections</li>
</ul>
</li>
<li>At most one process in a critical section</li>
<li>Can’t prevent entry if no others in critical section</li>
<li>Should eventually be able to enter critical section</li>
<li>No assumptions about CPU speed or number.</li>
</ul>
</li>
</ol>
<h2 id="Different-approaches-for-mutual-exclusion-workable"><a href="#Different-approaches-for-mutual-exclusion-workable" class="headerlink" title="Different approaches for mutual exclusion (workable)"></a>Different approaches for mutual exclusion (workable)</h2><ol>
<li><p>Peterson’s solution</p>
<ul>
<li><p>implementation</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shared <span class="keyword">int</span> <span class="built_in">turn</span>;</span><br><span class="line">shared <span class="keyword">bool</span> intent[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P0</span></span><br><span class="line">intent[<span class="number">0</span>] = TRUE;</span><br><span class="line"><span class="built_in">turn</span> = <span class="number">1</span>; <span class="built_in">turn</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (intent[<span class="number">1</span>] &amp;&amp; <span class="built_in">turn</span>==<span class="number">1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; critical section &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">intent[<span class="number">0</span>] = FALSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1</span></span><br><span class="line">intent[<span class="number">1</span>] = TRUE;</span><br><span class="line"><span class="keyword">while</span> (intent[<span class="number">0</span>] &amp;&amp; <span class="built_in">turn</span>==<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; critical section &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">intent[<span class="number">1</span>] = FALSE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>if competition occur, take turns, otherwise enter</p>
</li>
<li>for competing process number larger than 2, the solution will become more complex</li>
</ul>
</li>
<li><p>Test-and-Set Lock Instruction: TSL</p>
<ul>
<li><p>requirement: TSL mem</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span> <span class="title">atomically</span> <span class="params">(i.e., locking the memory bus)</span></span></span><br><span class="line">    [test if mem == 0 AND set mem = 1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>a possible C function implementation for TSL (it should be guaranteed atomic)</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TSL(<span class="keyword">int</span> *lockptr) &#123;</span><br><span class="line">    <span class="keyword">int</span> oldval;</span><br><span class="line">    oldval = *lockptr</span><br><span class="line">    *lockptr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((oldval == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mutual exclusion  using TSL</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shared <span class="keyword">int</span> lock = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// P0</span></span><br><span class="line"><span class="keyword">while</span> (! TSL(&amp;lock));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; critical section &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">lock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1</span></span><br><span class="line"><span class="keyword">while</span> (! TSL(&amp;lock));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; critical section &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">lock = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>shared variable solution using TSL(int *)</p>
<ul>
<li>test if lock == 0 (if so, will return 1; else 0)</li>
<li>before returning, sets lock to 1</li>
</ul>
</li>
<li>simple, works for any number of threads</li>
<li>still suffering from busy waiting</li>
</ul>
</li>
<li><p><em>Semaphores</em></p>
<ul>
<li>Synchronization varaible<ul>
<li>takes on integer values (non-negative)</li>
<li>can cause a process to block/unblock</li>
</ul>
</li>
<li>wait and signal operations (<strong>must be atomic, use a lower-level mechanism</strong>)<ul>
<li>wait(s) block if zero, else decrement</li>
<li>signal(s) unblock a process if any, else increment</li>
</ul>
</li>
<li><p>no other operations allowed (<strong>cannot change/test value of semaphore</strong>)</p>
</li>
<li><p>simple, works for n processes</p>
</li>
<li>busy-waiting still exist, but it lies inside semephore, which last shorter</li>
<li><p>Implementation</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait(sem s) &#123;</span><br><span class="line">    s.n = s.n – <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        addProc (me, s.L); <span class="comment">// add process to waiting list</span></span><br><span class="line">        block (me);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(sem s) &#123;</span><br><span class="line">    s.n = s.n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!empty (s.L)) &#123;</span><br><span class="line">        p = removeProc (s.L); <span class="comment">// select a process from waiting list to release</span></span><br><span class="line">        unblock (p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Only synchronization, no information transfer</p>
<ul>
<li>no way for a process to tell it blocked</li>
</ul>
</li>
</ul>
</li>
<li><p>Usage of semaphore</p>
<ul>
<li><p>basic usage example</p>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sem mutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//P0</span></span><br><span class="line">wait(mutex);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; critical section &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">signal(mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1</span></span><br><span class="line">wait(mutex);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; critical section &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">signal(mutex)</span><br></pre></td></tr></table></figure>
</li>
<li><p>order how processes execute</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sem cond = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; to be done before P1 &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">signal(cond);</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1</span></span><br><span class="line">wait(cond);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt; to be done after P0 &gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]进程调度-scheduling</title>
    <url>/2020/04/19/scheduling/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，第三课主要介绍了操作系统里面进程调度的一些基本算法以及相关的一些分类。</p>
<a id="more"></a>
<h2 id="Basic-problem-and-goal"><a href="#Basic-problem-and-goal" class="headerlink" title="Basic problem and goal"></a>Basic problem and goal</h2><ol>
<li><p>Problem introduction</p>
<ul>
<li>Given multiple processes and one CPU, which process gets CPU and when?</li>
<li>How much CPU time does each process get?</li>
<li>Possible approaches:<ul>
<li>Let one process keep CPU till done then switch to another</li>
<li>Each process uses CPU a bit and passed it on</li>
<li>Ech process gets proportinal to what they pay (demand)</li>
</ul>
</li>
<li>Which policy(ies) is the best?<ul>
<li>Depends on the goals of the system<ul>
<li>Personal computer</li>
<li>Large time-shared computer</li>
<li>computer controlling a nuclear power plant…</li>
</ul>
</li>
<li>Even one system might have multiple(and somtimes conflicting) goals</li>
</ul>
</li>
</ul>
</li>
<li><p>Some parameters needed in scheduling</p>
<ul>
<li>Arrival time: time that process is created</li>
<li>Service time: CPU time needed to complete (most time unknown to the kernel)</li>
<li>Turnaround time: from arrival to departure (actually time needed to finish the process, including running time and waiting time)</li>
<li>Try to minimizes average turnaround time</li>
</ul>
</li>
</ol>
<h2 id="Different-scheduling-policies"><a href="#Different-scheduling-policies" class="headerlink" title="Different scheduling policies"></a>Different scheduling policies</h2><h3 id="Let-one-process-run-till-done-non-preemptive"><a href="#Let-one-process-run-till-done-non-preemptive" class="headerlink" title="Let one process run till done (non-preemptive)"></a>Let one process run till done (non-preemptive)</h3><ol>
<li><p>Consider the service time for each process (suppose each process arrived at the same time)</p>
<ul>
<li><em>Longest first vs shortest first</em>: Let the longest/shortest processes among all the process created and not yet exit to run till done and then decide the next</li>
<li><strong>Proven: Shortest first is optimal</strong></li>
<li>However, the service time is unknown to the kernel in most of the time</li>
</ul>
</li>
<li><p>Consider the arrival time</p>
<ul>
<li><em>First come first serve(FCFS) vs Last come first serve(LCFS)</em>: Allocate the CPU to process arrived earliest or latest.</li>
<li>First come first serve(FCFS)<ul>
<li>non-preemptive, simple, no stavation</li>
<li>poor for short process arrived late</li>
</ul>
</li>
<li>Last come first serve(LCFS)<ul>
<li>simple</li>
<li>starvation, poor for short process arrived early</li>
</ul>
</li>
</ul>
</li>
<li><p>Shortest process next (SPN)</p>
<ul>
<li>when one process finish, select the process with shortest service time</li>
<li><strong>Proven: optimal for non-preemptive policies</strong></li>
<li>may cause starvation (when short process keep arriving, long process get no chance to run)</li>
<li>However, the service time is unknown to the kernel in most of the time</li>
</ul>
</li>
</ol>
<h3 id="Select-process-when-each-quantum-end-preemptive"><a href="#Select-process-when-each-quantum-end-preemptive" class="headerlink" title="Select process when each quantum end (preemptive)"></a>Select process when each quantum end (preemptive)</h3><ol>
<li><p>Round Robin (RR)</p>
<ul>
<li>Time-slice: each process gets quantum in turn</li>
<li>Preemptive, simple, no starvation</li>
<li>Each process waits at most (n - 1) x quantum (supposed n is fixed)</li>
</ul>
</li>
<li><p>Shortest remaing time (SRT)</p>
<ul>
<li>At the end of each quantum, select process with shortest remaining time</li>
<li><strong>Proven: optimal for preemptive policies</strong></li>
<li>may cause starvation (same case as SPN)</li>
<li>Assumes service times are known (which is difficult)</li>
</ul>
</li>
<li><p>Multi-level feedback queues <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/MLFQ.png" width="120" style="float: right;"></p>
<ul>
<li>Priority queues 0 to N (from high to low)</li>
<li>new processes enter queue 0 (highest priority)</li>
<li>Each quantum select from highest priority queue (FIFO within the queue)</li>
<li>For each process selected, run it for $T = 2^k$ quantums<ul>
<li>if the process used T quantums, move it next loewer queue</li>
<li>if the process used less than T quantums, back to same queue<ul>
<li>due to yield or higher priority arrival</li>
</ul>
</li>
</ul>
</li>
<li>Periodically boost (all to the queue 0)</li>
<li>Features:<ul>
<li>Complex, adaptive, highly responsive</li>
<li>Favors shorter over longer, possible starvation (higher priority queue run shorter time)</li>
</ul>
</li>
<li><p>Example</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/MLFQ_example.png" width="320"></p>
</li>
</ul>
</li>
<li><p>Priority scheduling</p>
<ul>
<li>Select process with highest priority</li>
<li>Calculate priority based some external criteria<ul>
<li>E.g., priority = $\frac{1}{CPU_{time used}}$</li>
</ul>
</li>
</ul>
</li>
<li><p>Fair share (Proportional share)</p>
<ul>
<li>Assumed ach process requests ome CPU utilization</li>
<li>Goal: utilization over long run, actual $\approx$ request</li>
<li>Select process with minimum actual/request ratio, when some processes have same minumum ratio, randomly choose one.</li>
<li>involving float number calculation in each quantum, maybe over head.</li>
</ul>
</li>
<li><p>Stride shceduling (practical implementation for Fair share)</p>
<ul>
<li>For each process x with certain CPU utilization requested, calculate strides: $S_x = \frac{1}{R_x}$</li>
<li>For each process x maintain pass value $P_x$ (initialized 0)</li>
<li>In each quantum:<ul>
<li>Select process x with minimum pass value P to run</li>
<li>Increment pass value with selected process by its stride value: $P_x = P_x + S_x$</li>
</ul>
</li>
<li>Optimization: use only intergers for $R_x, S_x, P_x$<ul>
<li>Calucalte $S_x = \frac{L}{R_x}$, where L is very large like 1000000.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Real-Time-Scheduling"><a href="#Real-Time-Scheduling" class="headerlink" title="Real Time Scheduling"></a>Real Time Scheduling</h3><h4 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h4><ul>
<li><p>Reason (correctness) for real-time scheduling</p>
<ul>
<li>depends on logical result of computations</li>
<li>timeing for these result</li>
</ul>
</li>
<li><p>Type of real-time systems</p>
<ul>
<li>hard vs. soft real-time</li>
<li>Periodic vs. aperiodic</li>
</ul>
</li>
</ul>
<h4 id="Type-of-processes"><a href="#Type-of-processes" class="headerlink" title="Type of processes"></a>Type of processes</h4><ul>
<li><p>Periodic Process (Tasks)</p>
<ul>
<li>A periodic process has a fixed frequency at which it needs to run.</li>
<li>Before each deadline it must run for a certain CPU time</li>
<li>For each process with a period, we have C (CPU burst needed), T (period), U (C/T, utilization)</li>
<li><p>Example</p>
<p><img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/PP_exp.png" width="320"></p>
</li>
</ul>
</li>
<li><p>Aperiodic Process</p>
<ul>
<li>Aperiodic processes have no fixed, cyclical, frequency between events.</li>
<li>For this type of process, real-time scheduling is not necessary</li>
</ul>
</li>
</ul>
<h4 id="Different-real-time-Scheduling"><a href="#Different-real-time-Scheduling" class="headerlink" title="Different real-time Scheduling"></a>Different real-time Scheduling</h4><ol>
<li><p>Earliest Deadline First (EDF)</p>
<ul>
<li>schedule process with earliest deadline</li>
<li><em>if a earlier deadline process appears, preempt</em></li>
<li>Pros:<ul>
<li>works for periodic and aperiodic processes</li>
<li>Achieve 100% utilization (igoniring overhead)</li>
</ul>
</li>
<li>Cons:<ul>
<li>Expensive: requires ordering by deadline frequently</li>
</ul>
</li>
<li><p>Example:</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/EDF.png" width="320"></p>
</li>
</ul>
</li>
<li><p>Rate Monotonoic Scheduling (RMS)</p>
<ul>
<li>If periodic processes exist, priorityize based on rates</li>
<li>At start of period, select highest priority</li>
<li>Preempty if necessary</li>
<li>When burst done, wait till next period</li>
<li>Deadline met require:  <strong>$U_1 + … + U_n \leq n (2 ^ {1/n} - 1)$</strong></li>
<li><p>Example:</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/RMS.png" width="320"></p>
</li>
</ul>
</li>
<li><p>More on RMS</p>
<ul>
<li>RMS is simple and efficient (static priority)</li>
<li>RMS is <strong>optimal for static priority algorithms</strong><ul>
<li>if RMS can’t schedule, no other static priority can</li>
</ul>
</li>
<li>RMS is limited in what it guarantees<ul>
<li><strong>Utilization bounded by $n(2^{1/n}-1) &gt; \ln{2}$ ~ 69%</strong></li>
<li>if bounded exceeded, no guarantess (but may not fail)</li>
</ul>
</li>
<li>RMS is limited to periodic processes</li>
</ul>
</li>
</ol>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">scheduling policy</th>
<th style="text-align:left">feature</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FCFS</td>
<td style="text-align:left">very simple, non-preemptive</td>
</tr>
<tr>
<td style="text-align:left">RR</td>
<td style="text-align:left">simple, preemptive</td>
</tr>
<tr>
<td style="text-align:left">SPN</td>
<td style="text-align:left">threoretical, non-preemptive</td>
</tr>
<tr>
<td style="text-align:left">SRT</td>
<td style="text-align:left">threoretical, preemptive</td>
</tr>
<tr>
<td style="text-align:left">MLFQ</td>
<td style="text-align:left">adaptive, reponsive, complex</td>
</tr>
<tr>
<td style="text-align:left">Priority</td>
<td style="text-align:left">external criteria</td>
</tr>
<tr>
<td style="text-align:left">FS</td>
<td style="text-align:left">proportional allocation</td>
</tr>
<tr>
<td style="text-align:left">EDF</td>
<td style="text-align:left">100% utilization, high overhead</td>
</tr>
<tr>
<td style="text-align:left">RMS</td>
<td style="text-align:left">&lt; 100%, low overhead</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]分时系统-timesharing</title>
    <url>/2020/04/19/timesharing/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，第二课主要介绍了分时系统里时间分配的概念，以及内核 (kernel) 和用户 (user) 层面上实现thread的区别以及优缺点。</p>
<a id="more"></a>
<ol>
<li><p>Definition</p>
<ul>
<li>Multiple processes share single CPU resources</li>
<li>Conceptually, each process makes progress over time</li>
<li>Practically, each perioadcally get quantum of CPU time<ul>
<li><em>quantum</em> : a basic time unit for CPU to allocate for a cycle</li>
</ul>
</li>
<li>Illusion of parallel progress by rapidly switching CPU</li>
</ul>
</li>
<li><p>Implementation</p>
<ul>
<li>Kernel keeps track of progress of each process</li>
<li>Divided the states (progress) of each process:<ul>
<li>Running: actually running (making progress), using CPU</li>
<li>Ready: able to make progress, but not using CPU</li>
<li>Blocked: unable to make progress (waiting other resources like memory, I/O etc), cannot use CPU</li>
</ul>
</li>
<li>Kernel selects a ready process and let it use CPU</li>
</ul>
</li>
<li><p>Process State Diagram<img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/process_state_diagram.png" width="220" style="float: right;"></p>
<ul>
<li>Dispatch: allocated the CPU to a process</li>
<li>Preempt: take away CPU from process</li>
<li>Sleep: process gives up CPU to wait for event</li>
<li>Wakeup: event occurred, make process ready</li>
</ul>
</li>
<li><p>Kernel</p>
<ul>
<li>A seperate memory space that store kernel code that support user processes to run<ul>
<li>systems calls: fork(), exit(), read(), write(), yield(),…</li>
<li>management: context switching, scheduling,…</li>
</ul>
</li>
<li>Keep track of state of each process<ul>
<li>each process has a unique ID</li>
</ul>
</li>
<li>Store other info needed<ul>
<li>areas of memory being used</li>
<li>contents of CPU contexts</li>
<li>other…</li>
</ul>
</li>
<li>runs as an extension of current process<ul>
<li>when system call (process give up control to kernel voluntarily)</li>
<li>hardware interrupt (preemption)<ul>
<li>timer</li>
</ul>
</li>
</ul>
</li>
<li><p>Has text, data and multiple stack (each for each process/thread)</p>
<ul>
<li><p>even if two process share the same code, use seperate memory(text, data, stack) to store state of each process</p>
<p><img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/multi_process_kernel.png" width="450"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Threads</p>
<ul>
<li>It’s a single sequential path of execution</li>
<li>Abstraction: independent of memory(may have different implementation like user-level and kernel-level)</li>
<li>A thread is a part of a process<ul>
<li>Lives in the memory of a process (share global variable)</li>
<li>Multiple threads may exist in a process</li>
</ul>
</li>
<li>To the user: unit of parallelism</li>
<li>To the kernel: unit of schedulability</li>
</ul>
</li>
<li><p>User-level threads vs Kernel-level threads</p>
<ul>
<li><p>user-level thread:</p>
<ul>
<li>Implement stacks for different threads in user space (actually share the stack in kernel)</li>
<li>Pros:<ul>
<li>Threads call and management in user level</li>
<li>Efficient: no need to trapped into kernel (which is heavy)</li>
<li>No need for kenerl support of threads</li>
</ul>
</li>
<li><p>Cons:</p>
<ul>
<li>no true parallelism (kernel see no threads but process)</li>
<li><p>mulitple CPU cannot let multiple threads in one process run at the same time</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/user_threads.png" width="450"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>kernel-level thread:</p>
<ul>
<li>Implement stacks for different threads in kernel space</li>
<li>Pros:<ul>
<li>can achieve true prallelism</li>
</ul>
</li>
<li><p>Cons:</p>
<ul>
<li><p>overhead: thread switch requires kernel call</p>
<p>  <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/kernel_thread.png" width="450"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Distinguish:</p>
<ul>
<li>Where is the thread abstraction supported: kernel code or user code</li>
<li>Where is the thread running: user space or kernel space</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>[UCSD CSE120]进程-process</title>
    <url>/2020/04/19/process/</url>
    <content><![CDATA[<p>本文是我在上UCSD的 <a href="http://cseweb.ucsd.edu/classes/wi20/cse120-a/" target="_blank" rel="noopener">CSE 120: Principles of Operating Systems (Winter 2020)</a> 整理的笔记，第一课主要介绍了操作系统以及进程的一些基本概念。</p>
<a id="more"></a>
<ol>
<li><p>Definition</p>
<ul>
<li>Abstraction of a running program (<em>dynamic</em>)</li>
<li>While program is just static code</li>
</ul>
</li>
<li><p>Resources</p>
<ul>
<li>CPU<ul>
<li>Processing cycles (CPU time)</li>
<li>Execute intstructions</li>
</ul>
</li>
<li>Memory<ul>
<li>Bytes or words</li>
<li>maintain state</li>
</ul>
</li>
<li>Other resources (I/O)</li>
</ul>
</li>
<li><p><strong>Context of a Process (machine and kernel-related state)</strong></p>
<ul>
<li>CPU context<ul>
<li>PC (program counter)</li>
<li>SP (stack pointer)</li>
<li>FP (frame pointer)</li>
<li>GP (general pointer)</li>
</ul>
</li>
<li>Memory context<ul>
<li>program code</li>
<li>static variables(init, uninit)</li>
<li>heap</li>
<li>shared memory</li>
<li>stack of activation records</li>
</ul>
</li>
<li>Other (kernel-related state, …)</li>
</ul>
</li>
<li><p>Process memory structure <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/process%20memory.png" width="120" style="float: right;"></p>
<ul>
<li>Text area: code (program instruction)</li>
<li>Data<ul>
<li>Global variable</li>
<li>Static variable (local and global)</li>
<li>Heap</li>
</ul>
</li>
<li>Stack<ul>
<li>Activation records</li>
<li>Automatic growth/shrinkage</li>
</ul>
</li>
</ul>
</li>
<li><p>Process stack <img src="https://raw.githubusercontent.com/XiaotaoGuo/OS-Notes/master/imgs/process%20stack.png" width="180" style="float: right;"></p>
<ul>
<li>Stack of activation records</li>
<li>An activation records stores:<ul>
<li>return address</li>
<li>link to previous record</li>
<li>local varibale</li>
<li>other</li>
</ul>
</li>
<li>Stack pointer points to top</li>
</ul>
</li>
<li><p>Multi-Processes</p>
<ul>
<li>Goal: support several processes running “simultaneously” or let one process intentionally yield to another process</li>
<li>Method: Context switching<ul>
<li>Switch process A (running) to process B (waiting) while store context (state) of process A (since it’s not finished)</li>
<li>process<ul>
<li>save context of current process<ul>
<li>save GP</li>
<li>save SP</li>
<li>save PC</li>
</ul>
</li>
<li>load context of next process<ul>
<li>load GP</li>
<li>load SP</li>
<li><strong>load PC (must be last, once PC is loaded, the process B begins to run (PC indicates instruction execution))</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>常用资源工具整理</title>
    <url>/2020/04/19/%E5%B8%B8%E7%94%A8%E8%B5%84%E6%BA%90%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="博客-amp-主题配置-（Hexo）"><a href="#博客-amp-主题配置-（Hexo）" class="headerlink" title="博客 &amp; 主题配置 （Hexo）"></a>博客 &amp; 主题配置 （Hexo）</h2><ul>
<li><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty" target="_blank" rel="noopener">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a><br> 视频讲解建立hexo博客以及部署到github pages上，需要注意下建立博客的过程最好不用root模式，只需要用chown改变npm的权限就可以了，不然后续写博客可能比较麻烦</p>
</li>
<li><p><a href="https://www.zyjdn.com/2020/02/05/Hexo-NexT%E4%B8%BB%E9%A2%98/" target="_blank" rel="noopener">Hexo-NexT主题</a><br> 这篇文章和博主的后续几篇主要包括hexo-next主题（目前更新到next版本7.0+）里面的基础配置</p>
</li>
<li><p><a href="https://blog.csdn.net/maosidiaoxian/article/details/85220394" target="_blank" rel="noopener">如何在Hexo中对文章md文件分类</a><br> 利用 post 的 permalink 属性和 hexo 的 new_post_name 实现按日期文件夹（按年或者按月）归类文章</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/111614119" target="_blank" rel="noopener">Github + Hexo 搭建个人博客超详细教程</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/111796666" target="_blank" rel="noopener">Hexo 双线部署到 Coding 和 GitHub 提升访问速度</a><br> 这两篇主要参考github和coding双线部署以及域名绑定</p>
</li>
<li><p><a href="https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">hexo - Next 主题添加评论功能</a><br> 添加评论功能</p>
</li>
<li><p><a href="https://www.yanlongwang.net/website/statistics-visitor-traffic/" target="_blank" rel="noopener">How to configure visitor traffic for a Hexo website / 如何统计 Hexo 网站的访问地区和IP</a><br> 配置clustrmaps.com查看访问者分布</p>
</li>
<li><p><a href="https://github.com/DesertsP/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a><br> 结合Valine进行评论管理和通知</p>
</li>
</ul>
<h2 id="zsh相关"><a href="#zsh相关" class="headerlink" title="zsh相关"></a>zsh相关</h2><ul>
<li><p><a href="https://www.zhihu.com/question/21418449" target="_blank" rel="noopener">zsh基本配置</a><br> zshrc基本配置，主要用了antigen管理插件和prezto管理prompt</p>
</li>
<li><p><a href="https://mikebuss.com/2014/04/07/customizing-prezto/" target="_blank" rel="noopener">Customizing Your Prezto Prompt</a><br> 选择prezto主题</p>
</li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>轮式里程计运动模型及标定</title>
    <url>/2020/04/18/%E8%BD%AE%E5%BC%8F%E9%87%8C%E7%A8%8B%E8%AE%A1%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%A0%87%E5%AE%9A/</url>
    <content><![CDATA[<p>本文是我在学习深蓝学院的激光slam第二课的学习笔记，这一课主要介绍了两轮差分底盘的运动模型以及怎么对里程计数据进行校正。</p>
<a id="more"></a>
<h2 id="轮式里程计模型"><a href="#轮式里程计模型" class="headerlink" title="轮式里程计模型"></a>轮式里程计模型</h2><h3 id="两轮差分底盘的运动学模型"><a href="#两轮差分底盘的运动学模型" class="headerlink" title="两轮差分底盘的运动学模型"></a>两轮差分底盘的运动学模型</h3><ol>
<li><p>优点</p>
<ul>
<li>结构简单</li>
<li>便宜，只需要两个电机（驱动器）</li>
<li>模型简单，并且可以实现任何轨迹跟踪</li>
</ul>
</li>
<li><p>差分模型及运动解算</p>
 <img src="/2020/04/18/%E8%BD%AE%E5%BC%8F%E9%87%8C%E7%A8%8B%E8%AE%A1%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%A0%87%E5%AE%9A/diffence_model.png" class="" title="2-wheel-odometry-model-calibration&#x2F;diffence_model.png">
<ul>
<li>考虑两轮在做半径为r的圆周运动，v和w是底盘中心的线速度和角速度，$v_{L/R}$ 和 $\omega_{L/R}$ 分别对应左/右轮子的线速度和角速度，d为底盘中心离两侧轮子的距离，b为两轮之间的距离（b = 2d）</li>
<li>目标：根据两轮的角速度（编码器测出的数据）以及其他参数求出底盘中心（机器人）运动的线速度v和角速度w</li>
<li><p>求解：</p>
<ul>
<li><p>根据两轮绕圆周中心的角速度相等：</p>
<script type="math/tex; mode=display">\frac{v_L}{r - d} = \frac{v_R}{r + d}</script><script type="math/tex; mode=display">\rightarrow v_L(r + d) = v_R(r - d)</script><script type="math/tex; mode=display">\rightarrow (v_L - v_R)r = (v_R + v_L)d</script><script type="math/tex; mode=display">\rightarrow r = \frac{v_R + v_L}{v_R - v_L}d</script></li>
<li><p>因此，</p>
<script type="math/tex; mode=display">r + d = \frac{v_R + v_L}{v_R - v_L}d + d = 2\frac{v_R}{v_R - v_L}d</script></li>
<li><p>根据底盘中心和两轮角速度相等：</p>
<script type="math/tex; mode=display">\omega = \frac{v_R}{r + d} = \frac{v_R - v_L}{2d}</script></li>
<li><p>根据$v = \omega r$</p>
<script type="math/tex; mode=display">\omega = \frac{\omega_Rr_R - \omega_Lr_L}{2d}</script><script type="math/tex; mode=display">v = \omega r = \frac{v_R - v_L}{2d}\frac{v_R + v_L}{v_R - v_L}d = \frac{v_R + v_L}{2} = \frac{\omega_Rr_R + \omega_Lr_L}{2}</script></li>
<li><p>整理得</p>
<script type="math/tex; mode=display">\begin{bmatrix}v \\ \omega\end{bmatrix} = \begin{bmatrix} \frac{r_L}{2} & \frac{r_R}{2} \\ -\frac{r_L}{b} & \frac{r_R}{b}\end{bmatrix}\begin{bmatrix}\omega_L \\ \omega_R\end{bmatrix} = J\begin{bmatrix}\omega_L \\ \omega_R\end{bmatrix}</script></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="轨迹推算（Dead-Reckoning）"><a href="#轨迹推算（Dead-Reckoning）" class="headerlink" title="轨迹推算（Dead Reckoning）"></a>轨迹推算（Dead Reckoning）</h3><ol>
<li><p>示意图</p>
 <img src="/2020/04/18/%E8%BD%AE%E5%BC%8F%E9%87%8C%E7%A8%8B%E8%AE%A1%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%A0%87%E5%AE%9A/dead_reckoning.png.png" class="" title="2-wheel-odometry-model-calibration&#x2F;dead_reckoning.png.png">
</li>
<li><p>递推公式</p>
<ul>
<li><p>假设</p>
<ul>
<li>当前位姿（世界坐标系下）为$(x, y, \theta)$</li>
<li>运动增量（车体坐标系下）为$(dx, dy, d\theta)$</li>
</ul>
</li>
<li><p>求解更新后的位姿</p>
<script type="math/tex; mode=display">\begin{bmatrix}x \\ y \\ \theta\end{bmatrix}=\begin{bmatrix}x \\ y \\ \theta\end{bmatrix} + \begin{bmatrix}\cos{\theta} & -\sin{\theta} & 0 \\ \sin{\theta} & \cos{\theta} & 0 \\ 0 & 0 & 1\end{bmatrix}\begin{bmatrix}dx \\ dy \\ d\theta\end{bmatrix}</script></li>
<li><p><em>加入噪声后</em></p>
<script type="math/tex; mode=display">\begin{bmatrix}x \\ y \\ \theta\end{bmatrix}=\begin{bmatrix}x \\ y \\ \theta\end{bmatrix} + \begin{bmatrix}\cos{\theta} & -\sin{\theta} & 0 \\ \sin{\theta} & \cos{\theta} & 0 \\ 0 & 0 & 1\end{bmatrix}\begin{bmatrix}dx + \epsilon_x \\ dy + \epsilon_y \\ d\theta + \epsilon_\theta\end{bmatrix}</script></li>
<li><p>噪声会随时间积累，所以dead reckoning精度会越来越低</p>
</li>
</ul>
</li>
</ol>
<h2 id="轮式里程计标定"><a href="#轮式里程计标定" class="headerlink" title="轮式里程计标定"></a>轮式里程计标定</h2><h3 id="线性最小二乘的基本概念"><a href="#线性最小二乘的基本概念" class="headerlink" title="线性最小二乘的基本概念"></a>线性最小二乘的基本概念</h3><ul>
<li><p>求解线性方程组 $Ax = b$，其中</p>
<ul>
<li>$A$ 为 $m\times n$ 的矩阵</li>
<li>$x$ 为 $n\times 1$ 的向量</li>
<li>当 $m &gt; n$ 时为超定方程组，方程组无解。实际情况中进行slam时移动机器人约束条件远远多于状态维度，通常为此种情况，此时需要求解最小二乘解</li>
</ul>
</li>
<li><p>最小二乘解</p>
<p>  $x^*=(A^TA)^{-1}A^Tb$</p>
</li>
</ul>
<h3 id="线性最小二乘在里程计标定中的应用"><a href="#线性最小二乘在里程计标定中的应用" class="headerlink" title="线性最小二乘在里程计标定中的应用"></a>线性最小二乘在里程计标定中的应用</h3><ol>
<li><p>主要方法包括：</p>
<ul>
<li>直接线性方法：通用性强，实现简单，精度不高（因此实际中比较少直接使用）</li>
<li>基于模型的方法：精度高，实现复杂，特异性强（实际中较多使用）</li>
</ul>
</li>
<li><p>直接线性方法</p>
<ul>
<li>用激光雷达的scan-match数据作为真值$u_i^*$</li>
<li>里程计测量数据为$u_i$</li>
<li><p>假设两者成线性关系$u_i^* = Xu_i$，其中：</p>
<p>  $X = \begin{bmatrix}x_{11} &amp; x_{12} &amp; x_{13} \\x_{21} &amp; x_{22} &amp; x_{23} \\x_{31} &amp; x_{32} &amp; x_{33}\end{bmatrix}$</p>
</li>
<li>标定过程就是求解$X$的过程（如何矫正里程计测量数据）</li>
<li><p>对于每一组数据，有以下关系：</p>
<script type="math/tex; mode=display">\begin{aligned}u_{ix}x_{11} + u_{iy}x_{12} + u_{i\theta}x_{13} = u_{ix}^* \\ u_{ix}x_{21} + u_{iy}x_{22} + u_{i\theta}x_{23} = u_{iy}^* \\ u_{ix}x_{31} + u_{iy}x_{32} + u_{i\theta}x_{33} = u_{i\theta}^*\end{aligned}</script></li>
<li><p>写成矩阵形式有：</p>
<script type="math/tex; mode=display">\begin{bmatrix}u_{i_x} & u_{iy} & u_{i\theta} & 0 & 0 & 0& 0 & 0 & 0\\ 0 & 0 & 0 &u_{i_x} & u_{iy} & u_{i\theta}& 0 & 0 & 0\\0 & 0 & 0& 0 & 0 & 0 &u_{i_x} & u_{iy} & u_{i\theta}\end{bmatrix}\begin{bmatrix}x_{11}\\x_{12}\\ ... \\ x_{33}\end{bmatrix} = \begin{bmatrix}u^*_{ix} \\ u^*_{iy} \\ u^*_{i\theta}\end{bmatrix}</script><script type="math/tex; mode=display">\rightarrow A_i\vec{X} = b_i</script></li>
<li><p>对于所有n个数据点有：</p>
<script type="math/tex; mode=display">A = \begin{aligned}A_1 \\ ...\\ A_n\end{aligned}</script><script type="math/tex; mode=display">b = \begin{aligned}
      b_1 \\ ... \\ b_n
  \end{aligned}</script></li>
<li><p>此时可以用最小二乘求解</p>
</li>
</ul>
</li>
<li><p>基于模型方法</p>
<ul>
<li><p>运动学模型</p>
<script type="math/tex; mode=display">\begin{bmatrix}v \\ \omega\end{bmatrix} = \begin{bmatrix} \frac{r_L}{2} & \frac{r_R}{2} \\ -\frac{r_L}{b} & \frac{r_R}{b}\end{bmatrix}\begin{bmatrix}\omega_L \\ \omega_R\end{bmatrix} = J\begin{bmatrix}\omega_L \\ \omega_R\end{bmatrix} = \begin{bmatrix}J_{11} & J_{12} \\ J_{21} & J_{22}\end{bmatrix}</script><ul>
<li><p>知道 $v$ 和 $\omega$ 之后，可以根据采样时间积分求得机器人状态 $(x(t), y(t), \theta(t))$：</p>
<script type="math/tex; mode=display">\begin{aligned}
  \theta(t) &= \int\omega(t)dt \\
  x(t) &= \int v(t)\cos{(\theta(t))}dt \\
  y(t) &= \int v(t)\sin{(\theta(t))}dt
  \end{aligned}</script></li>
</ul>
</li>
<li><p>根据匀速运动假设（采样时间内机器人保持匀速运动），及运动学模型有：</p>
<script type="math/tex; mode=display">\begin{aligned}
  \omega(t) = \omega = J_{21}\omega_{L} + J_{22}\omega_{R} \\
  v(t) = v = J_{11}\omega_{L} + J_{12}\omega_{R}
  \end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}
  J_{11} &= -\frac{b}{2}J_{21} \\
  J_{12} &= \frac{b}{2}J_{22}
  \end{aligned}</script><script type="math/tex; mode=display">\rightarrow v(t) = v = \frac{b}{2}(-J_{21}\omega_{L} + J_{22}\omega_{R})</script></li>
<li><p><em>已知两轮的角速度 $\omega_L$ 和 $\omega_R$，需要求解两轮半径（$r_L$ 和 $r_R$）和两轮之间的距离 $b$</em></p>
</li>
<li><p>基本过程：</p>
<ul>
<li>假设激光雷达位于车体的正中心</li>
<li>激光雷达的匹配值作为观测值</li>
<li>里程计的积分值作为预测值</li>
<li>_通过最小化预测值和观测值的差即可得到里程计的参数_</li>
<li>里程计的积分值用$r_x$ , $r_y$ , $r_θ$ 表示，激光雷达的匹配值用 $s_x$ , $s_y$ , $s_θ$ 表示</li>
</ul>
</li>
</ul>
</li>
<li><p>具体求解过程</p>
<ul>
<li><p>角度积分表达式(单一时间数据点)</p>
<script type="math/tex; mode=display">\begin{aligned} r_\theta(t) &=
   \int \omega(t)dt = \int J_{21}\omega_{L} + J_{22}\omega_Rdt \\
    r_\theta(t) &= (\omega_L\Delta T \:\:\: \omega_R\Delta T)(\begin{aligned}J_{21} \\J_{22}\end{aligned}) = s_\theta
   \end{aligned}</script><script type="math/tex; mode=display">\rightarrow A_0 J_2 = s_{\theta 0}</script></li>
<li><p>结合所有时间数据点可以求解 $Ax = b$，可以求得 $J_{21}$ 和 $J_{22}$</p>
</li>
<li><p>在已知 $J_{21}$ 和 $J_{22}$ 的情况下，对里程计的位置积分可以表示成与参数b成线性关系（$\cos\theta_t$ 的积分可求）：</p>
<script type="math/tex; mode=display">\begin{aligned}
  r_x(t) &= \int v(t) \cos{(\theta(t))} dt \\
  &= \frac{b}{2}(-J_{21}\omega_{L} + J_{22}\omega_{R})\int \cos{(\theta(t))} dt \\
  &= c_x b  = s_x\\
  r_y(t) &= \int v(t) \sin{(\theta(t))} dt \\
  &= \frac{b}{2}(-J_{21}\omega_{L} + J_{22}\omega_{R})\int \sin{(\theta(t))} dt \\
  &= c_y b = s_y
  \end{aligned}</script></li>
<li><p>通过罗列所有时间点的约束方程，可以通过最小二乘求解两轮距离 $b$</p>
</li>
<li><p>已知 $b, J_{21}, J_{22}$ 可以求得:</p>
<script type="math/tex; mode=display">r_L = -J_{21}b</script><script type="math/tex; mode=display">r_R = J_{22}b</script></li>
<li><p>至此轮式里程计标定完毕</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>激光slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>lidar-slam</tag>
      </tags>
  </entry>
  <entry>
    <title>激光slam介绍及相关数学基础</title>
    <url>/2020/04/18/%E6%BF%80%E5%85%89slam%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文是我在学习深蓝学院的激光slam第一课的学习笔记，这一课主要介绍了2d和3d的激光slam的一些基本概念，以及需要的一些数学基础。</p>
<a id="more"></a>
<h2 id="激光slam介绍"><a href="#激光slam介绍" class="headerlink" title="激光slam介绍"></a>激光slam介绍</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ol>
<li><p>输入</p>
<ul>
<li>里程计数据（odometry）：正常来说都会有，因为slam一般配备在移动机器人、无人车，在一些特殊场景可能没有（手持设备）</li>
<li>2d/3d激光雷达扫描结果：必须要有，在2dslam的情况下一般是单线的</li>
<li>IMU： 一般是可选的，可以没有</li>
</ul>
</li>
<li><p>输出</p>
<ul>
<li>3d点云地图：3dslam输出，在导航的时候会转成覆盖栅格地图进行导航</li>
<li>覆盖栅格地图（occupancy-grid map）：将环境分割成对栅格并输出每个栅格是否可通行</li>
<li>轨迹(trajectory) 或姿态（pose graph）</li>
</ul>
</li>
<li><p>帧间匹配方法（2d）</p>
<ul>
<li>PL-ICP(Point-to-line ICP)：利用<strong>点到线</strong>的距离做误差计算，相对于点到点的方法更加符合室内结构化场景，但比较依靠初始解</li>
<li>CSM(Correlation Scan Match)：<strong>暴力枚举</strong>所有可能的状态进行匹配相关性计算，取最优结果，（通过一定优化可以减少计算时间）</li>
<li>Optimization-Based：将地图空间看成解空间，依赖<strong>地图状态的梯度</strong>通过迭代求解，能方便引入额外约束，同样依赖初始解</li>
<li>实际常用 CSM + 梯度优化的方法，（也可以用 CSM + PL-ICP, 但是需要实际场景中有比较多结构化线段）</li>
</ul>
</li>
<li><p>帧间匹配方法（3d）</p>
<ul>
<li>Point-to-Plane ICP：用点到面的距离作误差匹配</li>
<li>Plane-to-Place ICP (GCIP): 面到面的距离</li>
<li>NDT：划分网格拟合高斯分布，因为计算速度快所以在3d场景用得多一点</li>
<li>NICP：在icp的基础上引入法向量信息（normal），角度精度较高</li>
<li>IMLS-ICP：对点云进行局部曲面拟合</li>
<li>Feature-based Method：参考视觉slam，提取特征点和描述子进行特征匹配，3d激光扫描结果信息量较多，所以可以使用</li>
</ul>
</li>
<li><p>回环检测方法</p>
<ul>
<li>Scan-to-Map</li>
<li>Map-to-Map</li>
<li>Branch and Bound &amp; Lazy Decision (延迟检测)：由于2d 激光slam对环境数据量太少，很容易造成不同场景结果相似，导致出现错误的回环，延迟检测的方法是只有在检测到<strong>多个回环</strong>的情况下并且回环都一致的时候才认为出现回环</li>
</ul>
</li>
</ol>
<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><ol>
<li><p>Filtered-based (滤波方法，目前在2d激光slam（主要是建图）已经很少使用，因为滤波方法更关注当前状态（位置），对历史信息不修正（没有回环的概念），所以不利于利用全局数据进行建图，在定位（VO，VIO等）用的较多)</p>
<ul>
<li>EKF-SLAM (1990s): 随环境增大状态量会急剧增大</li>
<li>FastSLAM (02~03)：粒子滤波，每个粒子携带一个地图</li>
<li>Gmapping (07): FastSLAM的升级版本</li>
<li>Optimal RBPF (10)：Gmapping的基础上进一步优化</li>
</ul>
</li>
<li><p>Graph-based (图优化方法)</p>
<ul>
<li>Karto-SLAM (10)：基于优化的方案（CSM + SPA）</li>
<li>Cartographer (16)：原理和Karto一样，用ceres实现，相对更完整</li>
</ul>
</li>
</ol>
<h3 id="实际应用中注意的问题"><a href="#实际应用中注意的问题" class="headerlink" title="实际应用中注意的问题"></a>实际应用中注意的问题</h3><ol>
<li><p><strong>数据预处理 (Preprocess)</strong></p>
<ul>
<li>轮式里程计标定，最好能到0.3%左右</li>
<li>激光雷达运动畸变（扫描过程中雷达的位置变化）</li>
<li>不同系统之间的时间同步（当每个传感器连接到不同处理器（cpu）上的时候系统时间可能会不一致，这个时候需要考虑时间同步获得统一时间戳）</li>
</ul>
</li>
<li><p>实际环境的问题（大部分可以通过和视觉融合来解决）</p>
<ul>
<li><p>动态物体、环境变化</p>
<ul>
<li>高动态：移动中的人，车</li>
<li>低动态：物体被移动（椅子，箱子），频率低</li>
</ul>
</li>
<li><p>几何结构相似环境：走廊等，容易发生状态退化，在3d的情况下则是比较空旷的区域，大部分点云无效导致环境退化</p>
</li>
<li>建图的操作复杂</li>
<li>全局定位</li>
<li>地面材质变化、地面凹凸不平、机器人载重变化：会造成里程计数据误差（间接改变了轮子直径）</li>
</ul>
</li>
</ol>
<h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><ol>
<li><p>位姿和转换矩阵（pose &amp; transformation matrix）</p>
<ul>
<li>假设机器人B在坐标系O中的坐标表示为 $(x, y, \theta)$</li>
<li><p>则坐标系B到坐标系O的转换矩阵为：</p>
<script type="math/tex; mode=display">T_{OB} = \begin{bmatrix}\cos{\theta} & -\sin{\theta} & x \\ \sin{\theta} & \cos{\theta} & y\\ 0 & 0 & 1 \end{bmatrix} = \begin{bmatrix}R & t \\ 0 & 1 \end{bmatrix}</script> <img src="/2020/04/18/%E6%BF%80%E5%85%89slam%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/transformation_matrix.png" class="" title="1-intro-math-basics&#x2F;transformation_matrix.png">
</li>
</ul>
</li>
<li><p>不同机器人坐标系转换</p>
<ul>
<li><p>机器人A和机器人B的坐标转换</p>
<script type="math/tex; mode=display">T_{AB} = T_{AO}T_{OB} = T_{OA}^{-1}T_{OB}</script></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>激光slam</category>
      </categories>
      <tags>
        <tag>slam</tag>
        <tag>lidar-slam</tag>
      </tags>
  </entry>
</search>
